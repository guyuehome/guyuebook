{"config":{"indexing":"full","lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"引言 机器人的发展横跨七八十年，经历了三个重要时期。 2000年前 ，机器人主要应用于工业生产，俗称工业机器人，由示教器操控，帮助工厂释放劳动力，此时的机器人并没有太多智能而言，完全按照人类的命令执行动作，更加关注电气层面的驱动器、伺服电机、减速机、控制器等设备，这是机器人的 电气时代 。 2000年后 ，计算机和视觉技术逐渐应用，机器人的类型不断丰富，出现了AGV、视觉检测等应用，此时的机器人传感器更加丰富，但是依然缺少自主思考的过程，智能化有限，只能感知局部环境，这是机器人的 数字时代 ，不过这也是机器人大时代的前夜。 2015年之后 ，随着人工智能技术的快速发展，机器人成为了AI技术的最佳载体，家庭服务机器人、送餐机器人、四足仿生机器狗、自动驾驶汽车等应用呈井喷状爆发， 智能机器人时代 正式拉开序幕。 智能机器人的快速发展，必将对机器人开发提出更高的要求，软件层面最为热点的技术之一就是机器人操作系统，这也是我们课程的主角—— Robot Operating System 。 教程链接汇总 课程视频： https://class.guyuehome.com/ 图文教程： https://book.guyuehome.com/ 教程源码： Gitee： https://gitee.com/guyuehome/ros2_21_tutorials Github： https://github.com/guyuehome/ros2_21_tutorials 教程问答： https://www.guyuehome.com/Bubble/circleDetail/id/90 博客泡圈： https://www.guyuehome.com/","text_tokens":["系统","算机","源码","com","缺少","之后","但是","机器人","更加","这是","—","计算机","感器","电气","动力","操控","。","泡圈","拉开序幕","丰富","视觉","不断丰富","2015","俗称","八十年","ai","robot","/","设备","数字","之一","计算","ros2","链接","减速","操作","太","，","id","七八十"," ","正式","视频","命令","井喷","也","：","驱动","开发","课程","高","www","序幕","和","家庭","技术","是","感知","服务","这","呈","最为","应用","博客","拉开","过程","驱动器","guyuehome","system","驾驶","有限","成为","_","年","提出","生产","业生","对","减速机","book","控制","教器","劳动","出现",":","大","不过","层面","类型","而言","伺服","机器","劳动力","tutorials","横跨","汽车","工厂","90","自主","经历","circledetail","关注","agv","21","思考","送餐","并","汇总","图文","伺服电机","热点","八十","工业","狗","仿生","传感","的","智能化","人工","完全","环境","主要","我们","引言","等","人类","检测","github",".","bubble","https","执行","发展","依然","只能","、","要求","此时","七八","工业生产","三个","传感器","状","释放","问答","爆发","载体","软件","不断","就是","十年","电机","七八十年","重要","2000","动作","时代","快速","了","四足","随着","操作系统","operating","gitee","必将","教程","智能","按照","class","由示","更","主角","于","局部","逐渐","后","最佳","没有","帮助","自动","人工智能","前夜","多","时期","控制器","年前"],"title":"引言","title_tokens":["引言"]},{"location":"#_1","text":"机器人的发展横跨七八十年，经历了三个重要时期。 2000年前 ，机器人主要应用于工业生产，俗称工业机器人，由示教器操控，帮助工厂释放劳动力，此时的机器人并没有太多智能而言，完全按照人类的命令执行动作，更加关注电气层面的驱动器、伺服电机、减速机、控制器等设备，这是机器人的 电气时代 。 2000年后 ，计算机和视觉技术逐渐应用，机器人的类型不断丰富，出现了AGV、视觉检测等应用，此时的机器人传感器更加丰富，但是依然缺少自主思考的过程，智能化有限，只能感知局部环境，这是机器人的 数字时代 ，不过这也是机器人大时代的前夜。 2015年之后 ，随着人工智能技术的快速发展，机器人成为了AI技术的最佳载体，家庭服务机器人、送餐机器人、四足仿生机器狗、自动驾驶汽车等应用呈井喷状爆发， 智能机器人时代 正式拉开序幕。 智能机器人的快速发展，必将对机器人开发提出更高的要求，软件层面最为热点的技术之一就是机器人操作系统，这也是我们课程的主角—— Robot Operating System 。","text_tokens":["系统","算机","缺少","之后","但是","机器人","更加","这是","—","计算机","感器","电气","动力","操控","。","拉开序幕","丰富","视觉","不断丰富","2015","俗称","八十年","ai","robot","设备","数字","之一","计算","减速","操作","太","，","七八十"," ","正式","命令","井喷","也","驱动","开发","课程","高","序幕","和","家庭","技术","是","感知","服务","这","呈","最为","应用","拉开","过程","驱动器","system","驾驶","有限","成为","年","提出","生产","业生","对","减速机","控制","教器","劳动","出现","大","不过","层面","类型","而言","伺服","机器","劳动力","横跨","汽车","工厂","自主","经历","关注","agv","思考","送餐","并","伺服电机","热点","八十","工业","狗","仿生","传感","的","智能化","人工","完全","环境","主要","我们","等","检测","人类","执行","发展","依然","只能","、","要求","此时","七八","工业生产","三个","传感器","状","释放","爆发","载体","软件","不断","就是","十年","电机","七八十年","重要","2000","动作","时代","快速","了","四足","随着","操作系统","operating","必将","智能","按照","由示","更","主角","于","局部","逐渐","后","最佳","没有","帮助","自动","人工智能","前夜","多","时期","控制器","年前"],"title":"引言","title_tokens":["引言"]},{"location":"#_2","text":"课程视频： https://class.guyuehome.com/ 图文教程： https://book.guyuehome.com/ 教程源码： Gitee： https://gitee.com/guyuehome/ros2_21_tutorials Github： https://github.com/guyuehome/ros2_21_tutorials 教程问答： https://www.guyuehome.com/Bubble/circleDetail/id/90 博客泡圈： https://www.guyuehome.com/","text_tokens":["课程","www","circledetail","源码","com","博客","问答","21","图文","guyuehome","泡圈","_","gitee","教程","github","book",".","class","/",":","ros2","bubble","https","id","tutorials"," ","视频","：","90"],"title":"教程链接汇总","title_tokens":["链接","汇总","教程"]},{"location":"about/","text":"学机器人，上古月居 古月居 ，是华语地区知名的ROS机器人社区（ www.guyuehome.com ），致力于为机器人学习者提供优质的交流学习平台，线上用户超过120万人，努力构建集人才、内容、校企为一体的社区生态，2011年创建至今，累积高质量内容超过1000万字、视频课程超过1000小时，出版《ROS机器人开发实践》等畅销图书，与众多高校及企业建立合作，通过AI机器人+社区生态的创新模式，赋能面向未来的人才培养。 版权声明 古月居网站的所有作品，包括但不限于课程、视频、课件和源码等均为武汉精锋微控科技有限公司合法拥有版权或依法有权使用的作品，仅限被授权用户的个人学习使用。 未经本公司书面许可，任何单位或个人不得对本网站的作品进行使用、复制、修改、抄录、传播、镜像或与其它产品捆绑使用、销售等。 违反上述声明者，本公司将追究其法律责任。 如需授权请联系 brand@guyuehome.com 。","text_tokens":["合作","违反","武汉","源码","课件","com","明者","万字","销售","追究其","机器人","创建","赋能","高质量","声明","法律","建立","面向","有限公司","（","brand","。","书面","使用","累积","精锋","公司","究其","学习","为","平台","有权","责任","内容","包括","抄录","追究","ai","致力","复制","将","，","培养","居","捆绑"," ","线上","视频","开发","课程","www","所有","人才培养","和","作品","是","进行","请","科技","1000","上","）","120","上述","guyuehome","均","有限","不","年","图书","努力","未来","优质","许可","地区","企业","学","联系","仅限","机器","构建","提供","超过","实践","小时","创新","任何","镜像","声明者","面向未来","个人","不得","交流学习","网站","未经","法律责任","校企","如需","的","畅销","知名","社区","质量","拥有","等","高校","被","交流","万人","高质","通过",".","其它","但","或","至今","单位","本","用户","、","集","致力于","古月","模式","微控","对本","《","ros","与","版权","合法","限于","学习者","2011","》","传播","出版","及","人才","生态","众多","@","修改","授权","华语","产品","一体","依法","+"],"title":"关于我们","title_tokens":["关于","我们"]},{"location":"about/#_1","text":"古月居 ，是华语地区知名的ROS机器人社区（ www.guyuehome.com ），致力于为机器人学习者提供优质的交流学习平台，线上用户超过120万人，努力构建集人才、内容、校企为一体的社区生态，2011年创建至今，累积高质量内容超过1000万字、视频课程超过1000小时，出版《ROS机器人开发实践》等畅销图书，与众多高校及企业建立合作，通过AI机器人+社区生态的创新模式，赋能面向未来的人才培养。","text_tokens":["合作","com","万字","机器人","创建","赋能","高质量","建立","面向","（","。","累积","学习","为","平台","内容","ai","致力","，","培养","居"," ","线上","视频","开发","课程","www","人才培养","是","1000","）","120","guyuehome","年","图书","努力","未来","优质","地区","企业","机器","构建","提供","超过","实践","小时","创新","面向未来","交流学习","校企","的","畅销","知名","社区","质量","等","高校","交流","万人","高质","通过",".","至今","用户","、","集","致力于","古月","模式","《","ros","与","学习者","2011","》","出版","及","人才","生态","众多","华语","一体","+"],"title":"学机器人，上古月居","title_tokens":["机器人","，","机器","居","古月","上","学"]},{"location":"about/#_2","text":"古月居网站的所有作品，包括但不限于课程、视频、课件和源码等均为武汉精锋微控科技有限公司合法拥有版权或依法有权使用的作品，仅限被授权用户的个人学习使用。 未经本公司书面许可，任何单位或个人不得对本网站的作品进行使用、复制、修改、抄录、传播、镜像或与其它产品捆绑使用、销售等。 违反上述声明者，本公司将追究其法律责任。 如需授权请联系 brand@guyuehome.com 。","text_tokens":["违反","武汉","源码","课件","com","明者","销售","追究其","法律","声明","有限公司","brand","。","书面","使用","精锋","公司","究其","学习","为","有权","责任","包括","抄录","追究","复制","将","，","居","捆绑"," ","视频","课程","所有","和","作品","进行","请","科技","上述","guyuehome","均","有限","不","许可","联系","仅限","任何","镜像","声明者","个人","不得","法律责任","网站","未经","如需","的","被","拥有","等",".","其它","但","或","单位","本","、","用户","古月","微控","对本","与","版权","合法","限于","传播","@","修改","授权","产品","依法"],"title":"版权声明","title_tokens":["版权","声明"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/","text":"ROS/ROS2是什么 智能时代，机器人正在向全场景的高度智能化方向进化，这对机器人开发提出了巨大挑战，机器人操作系统ROS应用而生。 那什么是ROS？什么又是ROS2呢？ 接下来，我们就一起掀起ROS的神秘面纱，带领大家认识一下机器人开发中这位重量级的嘉宾。 ROS的诞生 对于越来越复杂的智能机器人系统，已经不是一个人或者一个团队可以独立完成的，如何高效开发机器人，是技术层面上非常重要的一个问题，针对这个问题，一群斯坦福大学的有志青年尝试给出一个答案，那就是 机器人操作系统 。 2007年，他们诞生了这样一个想法，我们有没有可能做一款个人服务机器人，帮助我们完成洗衣做饭收拾家等一切你不想做的事情，甚至还可以在你无聊的时候，陪你聊天玩耍，最后他们真的做出来了。 当时，他们深知做出这样一款机器人并不容易，机械、电路、软件等都要涉及，而且横跨很多个专业，光靠自己肯定做不到，此时他们诞生了这样一个想法： 既然自己做不到，那为什么不联合所有人一起干呢？ 如果设计一套标准的机器人平台和其中的软件，大家都可以在这个平台上做应用开发，既然应用软件都基于同一平台，应用的分享也很容易实现，这就类似别人开发的苹果手机应用，只要你有苹果手机，同样也可以用。 说干就干，初期的机器人原型是用实验室可以找到的木头和一些零部件组成的，后期有了充足的资金，才得以实现图中这款外观精致、性能强悍的机器人—— PR2 ，Personal Robot 2代。 在上图中，我们可以看到PR2机器人已经可以完成叠毛巾、熨烫衣服、打台球、剪头发等一系列复杂的应用功能，以叠毛巾为例，这在当时是轰动机器人圈的重要研究，因为第一次有机器人可以完成柔性物体的处理，虽然效率很低，在100分钟之内只完成了5条毛巾的整理，但是在学术层面却推动机器人向前走了一大步。 这款机器人中的软件框架就是ROS的原型，所以ROS因这款个人服务机器人而生，很快也从中独立出来，成为一款用于更多机器人的软件系统。 ROS的发展 ROS诞生于2007年的斯坦福大学，这是早期PR2机器人的原型，这个项目很快被一家商业公司Willow Garage看中，类似现在的风险投资一样，他们投了一大笔钱给这群年轻人，PR2机器人在资本的助推下成功诞生。 2010年，随着PR2机器人的发布，其中的软件正式确定了名称，就叫做机器人操作系统，Robot Operating System，简称为ROS。同年，ROS也肩负着让更多人使用的使命，正式开源。 PR2机器人虽好，但是成本居高不下，几百万的价格让绝大部分开发者望而却步，官方也注意到了这个问题，所以在2011年发布了一款后期成为ROS圈爆款的机器人—— Turtlebot ，这款机器人采用扫地机器人的底盘，加上xbox游戏机中的体感传感器Kinect，直接使用笔记本电脑就可以控制，支持ROS的所有开源功能，关键是价格便宜，随着这款机器人的普及，大大推动了ROS的应用。 从2012年开始，使用ROS的人越来越多，ROS官方也开始每年举办一届ROS开发者大会—— ROS Conference ，简称 ROSCon ，来自全球的开发者会齐聚一堂分享自己使用ROS开发的机器人应用，其中不乏亚马逊、Intel、微软等大公司的身影，近两年因为疫情原因改为线上举办，名称也变为了ROS World。 经历前几年野蛮而快速的增长，ROS逐渐迭代稳定，2014年起，ROS跟随Ubuntu系统，每两年推出一个长期支持版，每个版本支持五年时间，这标志着ROS的成熟，也让ROS加快了普及的步伐。 回到时间轴的起点，ROS的创始团队原本只想做一款个人服务机器人，万万没想到， ROS被越来越多机器人使用，受限于当初设计的局限性，ROS的问题也逐渐暴露 。为了能够真正设计一款适用于所有机器人的操作系统，ROS2在2017年底正式发布，历经多年迭代，我们终于在2022年5月底，迎来了ROS2第一个长期支持版—— ROS2 Humble ，ROS2已经成熟，我们也进入了一个全新的ROS2时代。 从ROS发展的时间轴中，我们不仅可以了解到ROS的发展过程，更重要的是熟悉ROS和ROS2诞生的原因。 这里我们也把ROS2发展的时间轴单独提取出来，介于ROS在各种各样机器人中应用的问题，ROS2在2014年提出，2015年开始迭代，2017年推出第一个正式版，此后快速迭代，直到2022年推出了第一个长期支持版，本教程也会在该版本ROS2之上进行讲解。 ROS的特点 ROS怀揣“ 提高机器人软件复用率 ”的目标，促使社区快速发展和繁荣，时至今日，ROS已经广泛用于各种机器人的开发，无论是机械臂、移动机器人、水下机器人，还是人形机器人、复合机器人，统统都可以看到ROS的身影，ROS已经成为机器人领域的普遍标准。 提高机器人软件复用率，这个目标简单来讲就是 不要重新造轮子 。 正如一家做汽车的公司，从零制造汽车并不是一个明智的做法，他们通常会采购A家的轮子、B家的引擎、C家的多媒体系统，最后把这些整合到一起做成汽车。同理，我们也可以将ROS社区中已有的各种软件集合到一起，在此之上去实现自己的创意，同时还可以将自己的成果分享给别人，这样大家都可以站在巨人的肩膀上，向前走的更远，一步一步，智能机器人才会有更多沉淀和更长远的进步。 围绕这个核心目标，ROS在自身的设计上也尽量做到了模块化，由 通信机制、开发工具、应用功能、生态系统 四大部分组成。同时ROS具备多项特点，这里的ROS是ROS1和ROS2的总称， 比如： 社区是全球化 的，那就可以集合全人类的智慧来推进机器人的智能化发展； 这些智慧的结晶都会以各种各样的 应用案例在社区中沉淀 下来； ROS本身也是完全开源的， 商业许可证非常宽松 ； 对商业应用功能友好，这就代表着公司可以直接使用ROS开发商业化的机器人产品， 缩短了产品的上市时间 ； ROS也可以 跨平台使用 ，Linux、Windows、嵌入式系统都可以跑； ROS2中也新增了很多 支持工业应用 的新特性和新技术，促使ROS在越来越多领域中被使用。 ROS的社区 社区是ROS快速发展的核心动力，什么是社区呢？其实就是ROS相关资源的整合方式，比如wiki说明、问答网站、应用源码、论坛讨论等都算是社区中的元素。 ROS全球社区有几个重要网站： answers.ros.org，这是一个ROS问答网站，大家可以在上边提出任何关于ROS的问题，全球很多开发者都很乐意回答我们的问题； wiki.ros.org，这是ROS的维基百科，记录了ROS教程和各种功能包的使用； discourse.ros.org，这是ROS论坛，关于ROS开发的新鲜事都可以在这里发表和查看，比如ROS的活动、新功能包的发布等等。 index.ros.org，是ROS各种资源的一个索引网站； packages.ros.org，是ROS功能包存储的数据库。 这几个网站的使用情况基本就可以代表ROS社区的活跃度了。 上图是近几年ROS社区页面浏览量的增长曲线，从总体趋势上来看，各项增长速度都非常快，wiki作为日常使用最为频繁的网站，使用度无疑是最高的，现在每个月有 150万左右 的访问量，answers和packages现在差不多，每个月有 80万 左右，其他两个不多，四项加起来每个月基本有 250万左右 的访问量，已经是一个活跃度非常棒的社区了。 从访问人数上来看，上边这张图更为清晰， wiki每个月有20到25万人使用 ， answers每个月有15万人以上使用 ，四项加起来每个月差不多有40多万的使用人数，这些用户绝大部分都是机器人开发者，可以看到ROS使用人数是越来越多了。 这张图是根据功能包下载次数统计得到的地域排名，基本上可以代表不同国家机器人研发的活跃程度，给大家作为一个参考。 总而言之，通过这些数据，我们可以看到的是ROS发展迅猛，正在助推机器人革命这一波大浪潮，大家每一个人在其中都大有可为。 如果你希望学习机器人开发，ROS绝对会成为你开发机器人的神兵利器，本教程也绝对是你的最佳选择。 参考资料 关于本教程的参考资料，主要推荐这几个网站。 首先是最为推荐的搜索之王—— Google ，几乎所有问题，都可以在这里解决，作为开发工程师的同学，一定要掌握这个重要工具的使用方法。 其次是开源项目的主阵地—— Github ，ROS和社区中的绝大部分代码，都在这里托管，还有大量可以作为我们学习参考的开源项目都可以在这里找到，也是我们离不开的一个网站。 然后是 古月居 网站，这里有大量ROS机器人开发的技术内容和视频课程，还可以在泡泡板块中提问，也欢迎大家在这里和120万人分享你所学的知识。 最后是 本教程网站 ，会提供详细的ROS2入门教程，后续也会不断更新和扩展，努力成为大家学习ROS机器人开发的百科全书，配合课程视频学习，效果会更好。 好啦，欢迎大家来到ROS的世界，从这里开始，我们将一起踏上一段美妙的机器人开发之旅。","text_tokens":["人","”","到","局限性","其他","正如","亚马逊","趋势","一起","但是","—","有没有","方向","有","整理","肩负","2012","差不多","同时","比如","而且","笔记本电脑","尽量","设计","基于","2015","平台","投资","页面","情况","/","通信","价格","了解","，","特点","资源"," ","为了","更新","不想","org","图中","可以","要","pr2","做出","ubuntu","a","媒体","这些","课程","大部分","这里","两年","进行","学术","无疑","开源","移动机器人","250","过程","给","通常","生态系统","改为","同学","几年","限性","一大笔","index","都","历经","加","此","微软","事情","第一次","团队","举办","大量","单独","出来","沉淀","能够","据库","而言","150","便宜","智慧","扩展","world","各种各样","电路","不下","局限","版","提取","非常","国家","使命","标志","后续","总而言之","整合","踏上","网站","详细","研发","该","的","今日","方式","应用软件","这群","分享","社区","关于","等","由","主要","不开","许可证","会","浪潮","可为","不乏","一切","容易","涉及","现在","讨论","多年","各项","游戏机","挑战","上市","百科全书","大学","本","时至今日","越来","用户","接下","统统","此时","因","answers","毛巾","之旅","答案","长远","体感","同年","一大","希望","资本","同样","近两年","家","框架","加快","具备","基本上","一段","复合","问答","不同","已有","新鲜事","就是","没想到","项目","起点","工程师","根据","左右","全书","新增","暴露","做饭","一大笔钱","每","？","处理","查看","一个","肩负着","时间轴","深知","人才","上去","从中","其次","逐渐","“","上图","解决","怀揣","商业化","真的","首先","wiki","找到","面纱","才","一堂","利器","主阵地","百科","一大步","做到","次数","领域","洗衣","更好","亚马","万左右","这一波","支持","望而却步","绝大","感器","世界","百万","长期","维基","garage","跨平台","。","各种","discourse","动机","类似","一次","学习","所有人","繁荣","程度","零","台球","却","操作","四大","来讲","来看","啦","向","其实","组成","视频","下载","也","年轻人","开发","快","几乎","；","却步","叠","人数","入门","和","服务","上","低","120","初期","神兵","功能","助推","以叠","100","成本","人形","量级","版本","system","巨人","不断更新","搜索","提出","packages","40","控制","ros1","有志","大","诞生","层面","带领","名称","电脑","机器","站","明智","其中","一系列","每个","广泛","推动","干","后期","清晰","适用","一系","并","只想","专业","接下来","甚至","稳定","代码","c","疫情","地域","推荐","起","而生","同一","智能化","做成","完全","索引","两个","步伐","托管","多万","github","万人","通过","玩耍",".","已经","零部件","用于","personal","大大","没想","性能","全球","看到","认识一下","缩短","维基百","年轻","更为","得到","因为","turtlebot","在","开始","开发工具","体系","系列","早期","个","率","参考","多媒体","ros","案例","直到","可能","时代","福大","快速","特性","身影","制造","联合","当初","operating","随着","虽然","2022","生态系","教程","采购","友好","这款","更","头发","时候","很快","跑","没有","想到","普遍","存储","不是","四项","相关","熨烫","维基百科","机械","光靠","各样","linux","系统","创始","不仅","当时","然后","一下","成功","离不开","机器人","论坛","迅猛","回到","willow","标准","用","动力","时间","2010","肩膀","知识","为","高度","下","水下","促使","robot","打","条","本身","ros2","简称","资金","几百万","爆款","多项","一家","衣服","记录","推进","新鲜","移动","中","：","官方","万万","度","所有","想法","最后","技术","roscon","正在","应用","圈","windows","b","既然","浏览量","做","5","向前走","款","手机","宽松","发表","所以","受限于","数据","终于","同理","物体","还有","复杂","许可","把","围绕","全","数据库","聊天","强悍","提供","汽车","全新","提问","价格便宜","臂","任何","来到","只要","经历","做法","开发者","新","结晶","万","算是","原本","采用","很多","你","而","创意","2","工业","确定","一届","引擎","革命","google","kinect","效果","高效","木头","柔性","被","提高","排名","板块","美妙","人类","越来越","速度","之内","关键","说明","之上","轮子","发展","那","外观","、","独立","起来","部件","实验室","全人类","上边","入门教程","五年","苹果","这样","完成","得以","真正","精致","底盘","以","大家","软件","剪头发","几百","受限","不多","重要","限于","风险投资","核心","了","不要","元素","图","操作系统","增长速度","智能","注意","所学","选择","笔记","第一","代表","频繁","最佳","阵地","帮助","有人","产品","研究","多","曲线","普及","回答","进入","大有可为","棒","全人","青年","模块化","很","源码","2017","迎来","进化","实现","访问","这是","泡泡","直接","之王","给出","掀起","虽好","什么","使用","一步","进步","公司","收拾","如果","活动","大部","15","内容","风险","原型","简单","自己","看中","大笔","将","资料","来自","活跃","80","居","分钟","日常","斯坦福","问题","正式","代","线上","全球化","总体","总称","统计","无聊","重量","还","是","这","推出","对于","最为","神秘","活跃度","这个","正式版","一些","目标","工程","迭代","自身","增长","机制","一套","不","月底","成为","年","尝试","一群","巨大","对","努力","以上","humble","2007","来","25","呢","居高不下","几个","模块","别人","横跨","发布","每年","工具","这位","2014","着","软件系统","还是","讲解","浏览","张图","变为","绝对","重新","认识","复用","多媒体系统","大步","intel","个人","向前","嘉宾","说干就干","实验","或者","传感","配合","之","前","只","基本","下来","我们","游戏","为什么","充足","conference","部分","介于","针对","成果","包","等等","至今","无论是","远","嵌入","月","一定","古月","欢迎","跟随","就","熟悉","乐意","原因","轰动","无论","年底","传感器","掌握","齐聚一堂","造","一款","xbox","斯坦福大学","为例","重量级","不断","参考资料","最高","商业","从","又","大会","效率","成熟","一样","肯定","场景","2011","近几年","绝大部分","陪","笔记本","20","叫做","如何","生态","嵌入式","好","于","加上","第一个","作为","让","投了","野蛮","集合","方法","不到","访问量","他们","此后","扫地"],"title":"ROS和ROS2是什么","title_tokens":["和","是","ros","什么","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#rosros2","text":"智能时代，机器人正在向全场景的高度智能化方向进化，这对机器人开发提出了巨大挑战，机器人操作系统ROS应用而生。 那什么是ROS？什么又是ROS2呢？ 接下来，我们就一起掀起ROS的神秘面纱，带领大家认识一下机器人开发中这位重量级的嘉宾。","text_tokens":["就","这位","面纱","系统","重量","是","这","进化","一起","正在","应用","神秘","一下","机器人","认识","方向","接下来","大家","重量级","掀起","量级","ros","嘉宾","而生","的","智能化","。","时代","什么","又","场景","了","下来","提出","操作系统","巨大","？","高度","对","我们","智能","ros2","全","操作","呢","带领","向","挑战","，","机器","那"," ","接下","中","认识一下","开发"],"title":"ROS/ROS2是什么","title_tokens":["是","ros","/","什么","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#ros","text":"对于越来越复杂的智能机器人系统，已经不是一个人或者一个团队可以独立完成的，如何高效开发机器人，是技术层面上非常重要的一个问题，针对这个问题，一群斯坦福大学的有志青年尝试给出一个答案，那就是 机器人操作系统 。 2007年，他们诞生了这样一个想法，我们有没有可能做一款个人服务机器人，帮助我们完成洗衣做饭收拾家等一切你不想做的事情，甚至还可以在你无聊的时候，陪你聊天玩耍，最后他们真的做出来了。 当时，他们深知做出这样一款机器人并不容易，机械、电路、软件等都要涉及，而且横跨很多个专业，光靠自己肯定做不到，此时他们诞生了这样一个想法： 既然自己做不到，那为什么不联合所有人一起干呢？ 如果设计一套标准的机器人平台和其中的软件，大家都可以在这个平台上做应用开发，既然应用软件都基于同一平台，应用的分享也很容易实现，这就类似别人开发的苹果手机应用，只要你有苹果手机，同样也可以用。 说干就干，初期的机器人原型是用实验室可以找到的木头和一些零部件组成的，后期有了充足的资金，才得以实现图中这款外观精致、性能强悍的机器人—— PR2 ，Personal Robot 2代。 在上图中，我们可以看到PR2机器人已经可以完成叠毛巾、熨烫衣服、打台球、剪头发等一系列复杂的应用功能，以叠毛巾为例，这在当时是轰动机器人圈的重要研究，因为第一次有机器人可以完成柔性物体的处理，虽然效率很低，在100分钟之内只完成了5条毛巾的整理，但是在学术层面却推动机器人向前走了一大步。 这款机器人中的软件框架就是ROS的原型，所以ROS因这款个人服务机器人而生，很快也从中独立出来，成为一款用于更多机器人的软件系统。","text_tokens":["人","机械","光靠","找到","才","系统","青年","当时","很","一大步","洗衣","一起","但是","实现","机器人","—","有没有","有","给出","整理","标准","用","而且","。","什么","设计","基于","类似","一次","收拾","所有人","如果","平台","原型","robot","自己","打","台球","条","资金","却","操作","，","衣服","分钟"," ","斯坦福","问题","不想","组成","代","：","也","图中","可以","要","开发","做出","pr2","中","所有","叠","和","无聊","想法","还","是","技术","最后","服务","这","对于","上","应用","低","圈","学术","初期","这个","功能","一些","既然","以叠","100","做","5","向前走","款","手机","一套","不","所以","都","年","尝试","一群","成为","物体","复杂","事情","有志","第一次","团队","2007","诞生","层面","呢","出来","机器","聊天","强悍","别人","横跨","其中","一系列","电路","推动","干","只要","后期","软件系统","非常","一系","并","很多","你","专业","甚至","2","大步","个人","向前","实验","说干就干","或者","而生","同一","的","应用软件","高效","木头","只","柔性","分享","我们","等","为什么","充足","玩耍","越来越","之内","已经","零部件","用于","一切","容易","涉及","personal","针对","那","大学","外观","越来","、","性能","独立","此时","看到","因","部件","毛巾","答案","实验室","就","因为","在","一大","同样","家","苹果","轰动","这样","框架","完成","系列","得以","精致","个","一款","斯坦福大学","软件","大家","剪头发","就是","为例","ros","可能","效率","重要","福大","肯定","了","联合","做饭","图","操作系统","？","处理","虽然","陪","一个","智能","这款","如何","更","深知","头发","时候","从中","第一","很快","没有","帮助","有人","不到","不是","研究","多","他们","熨烫","真的"],"title":"ROS的诞生","title_tokens":["ros","的","诞生"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#ros_1","text":"ROS诞生于2007年的斯坦福大学，这是早期PR2机器人的原型，这个项目很快被一家商业公司Willow Garage看中，类似现在的风险投资一样，他们投了一大笔钱给这群年轻人，PR2机器人在资本的助推下成功诞生。 2010年，随着PR2机器人的发布，其中的软件正式确定了名称，就叫做机器人操作系统，Robot Operating System，简称为ROS。同年，ROS也肩负着让更多人使用的使命，正式开源。 PR2机器人虽好，但是成本居高不下，几百万的价格让绝大部分开发者望而却步，官方也注意到了这个问题，所以在2011年发布了一款后期成为ROS圈爆款的机器人—— Turtlebot ，这款机器人采用扫地机器人的底盘，加上xbox游戏机中的体感传感器Kinect，直接使用笔记本电脑就可以控制，支持ROS的所有开源功能，关键是价格便宜，随着这款机器人的普及，大大推动了ROS的应用。 从2012年开始，使用ROS的人越来越多，ROS官方也开始每年举办一届ROS开发者大会—— ROS Conference ，简称 ROSCon ，来自全球的开发者会齐聚一堂分享自己使用ROS开发的机器人应用，其中不乏亚马逊、Intel、微软等大公司的身影，近两年因为疫情原因改为线上举办，名称也变为了ROS World。 经历前几年野蛮而快速的增长，ROS逐渐迭代稳定，2014年起，ROS跟随Ubuntu系统，每两年推出一个长期支持版，每个版本支持五年时间，这标志着ROS的成熟，也让ROS加快了普及的步伐。 回到时间轴的起点，ROS的创始团队原本只想做一款个人服务机器人，万万没想到， ROS被越来越多机器人使用，受限于当初设计的局限性，ROS的问题也逐渐暴露 。为了能够真正设计一款适用于所有机器人的操作系统，ROS2在2017年底正式发布，历经多年迭代，我们终于在2022年5月底，迎来了ROS2第一个长期支持版—— ROS2 Humble ，ROS2已经成熟，我们也进入了一个全新的ROS2时代。 从ROS发展的时间轴中，我们不仅可以了解到ROS的发展过程，更重要的是熟悉ROS和ROS2诞生的原因。 这里我们也把ROS2发展的时间轴单独提取出来，介于ROS在各种各样机器人中应用的问题，ROS2在2014年提出，2015年开始迭代，2017年推出第一个正式版，此后快速迭代，直到2022年推出了第一个长期支持版，本教程也会在该版本ROS2之上进行讲解。","text_tokens":["人","普及","一堂","到","进入","各样","系统","创始","不仅","局限性","2017","暴露","亚马逊","迎来","成功","但是","亚马","机器人","这是","—","支持","望而却步","绝大","直接","回到","感器","willow","肩负","百万","2012","长期","虽好","garage","。","时间","笔记本电脑","各种","使用","2010","公司","类似","设计","为","2015","大部","投资","风险","原型","下","robot","自己","看中","大笔","简称","几百万","ros2","操作","价格","爆款","了解","重要","来自","一家","，"," ","斯坦福","问题","正式","线上","为了","中","也","年轻人","官方","pr2","开发","可以","ubuntu","万万","却步","所有","大部分","这里","和","是","两年","roscon","服务","进行","这","推出","应用","圈","开源","这个","正式版","功能","过程","给","助推","成本","改为","做","迭代","几年","版本","system","5","款","增长","限性","一大笔","月底","所以","成为","年","提出","历经","受限于","终于","humble","控制","微软","把","举办","大","2007","团队","诞生","单独","名称","电脑","居高不下","出来","机器","能够","便宜","world","各种各样","全新","发布","其中","价格便宜","每年","每个","推动","不下","经历","2014","局限","版","开发者","着","后期","提取","讲解","适用","变为","原本","采用","使命","标志","而","只想","稳定","intel","个人","疫情","确定","一届","起","传感","该","的","kinect","前","这群","被","分享","游戏","等","步伐","我们","conference","会","越来越","部分","关键","不乏","已经","现在","之上","介于","大大","多年","没想","游戏机","发展","大学","本","越来","、","全球","年轻","跟随","就","turtlebot","在","同年","体感","一大","开始","资本","近两年","因为","原因","五年","加快","熟悉","年底","早期","真正","传感器","底盘","齐聚一堂","一款","xbox","斯坦福大学","软件","几百","没想到","ros","项目","起点","商业","从","受限","直到","大会","成熟","时代","福大","一样","快速","限于","风险投资","身影","了","当初","一大笔钱","随着","操作系统","operating","绝大部分","2011","每","一个","2022","教程","肩负着","笔记本","注意","叫做","更","时间轴","于","加上","笔记","逐渐","很快","第一","第一个","让","投了","野蛮","想到","多","他们","此后","扫地"],"title":"ROS的发展","title_tokens":["ros","的","发展"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#ros_2","text":"ROS怀揣“ 提高机器人软件复用率 ”的目标，促使社区快速发展和繁荣，时至今日，ROS已经广泛用于各种机器人的开发，无论是机械臂、移动机器人、水下机器人，还是人形机器人、复合机器人，统统都可以看到ROS的身影，ROS已经成为机器人领域的普遍标准。 提高机器人软件复用率，这个目标简单来讲就是 不要重新造轮子 。 正如一家做汽车的公司，从零制造汽车并不是一个明智的做法，他们通常会采购A家的轮子、B家的引擎、C家的多媒体系统，最后把这些整合到一起做成汽车。同理，我们也可以将ROS社区中已有的各种软件集合到一起，在此之上去实现自己的创意，同时还可以将自己的成果分享给别人，这样大家都可以站在巨人的肩膀上，向前走的更远，一步一步，智能机器人才会有更多沉淀和更长远的进步。 围绕这个核心目标，ROS在自身的设计上也尽量做到了模块化，由 通信机制、开发工具、应用功能、生态系统 四大部分组成。同时ROS具备多项特点，这里的ROS是ROS1和ROS2的总称， 比如： 社区是全球化 的，那就可以集合全人类的智慧来推进机器人的智能化发展； 这些智慧的结晶都会以各种各样的 应用案例在社区中沉淀 下来； ROS本身也是完全开源的， 商业许可证非常宽松 ； 对商业应用功能友好，这就代表着公司可以直接使用ROS开发商业化的机器人产品， 缩短了产品的上市时间 ； ROS也可以 跨平台使用 ，Linux、Windows、嵌入式系统都可以跑； ROS2中也新增了很多 支持工业应用 的新特性和新技术，促使ROS在越来越多领域中被使用。","text_tokens":["机械","”","到","各样","全人","linux","系统","模块化","正如","做到","领域","一起","实现","机器人","支持","直接","有","标准","同时","比如","跨平台","。","时间","各种","一步","动机","使用","肩膀","公司","进步","设计","尽量","平台","繁荣","水下","简单","零","促使","自己","通信","本身","ros2","将","四大","多项","来讲","一家","，","特点"," ","组成","推进","移动","全球化","中","也","：","可以","开发","a","媒体","总称","；","这些","这里","和","还","最后","是","技术","这","上","应用","移动机器人","开源","这个","b","功能","windows","给","通常","生态系统","人形","目标","做","向前走","巨人","自身","机制","宽松","成为","都","对","同理","此","ros1","许可","把","围绕","来","机器","沉淀","模块","别人","智慧","各种各样","站","汽车","明智","臂","工具","广泛","做法","新","还是","结晶","着","非常","重新","复用","并","很多","多媒体系统","创意","整合","工业","c","向前","引擎","的","智能化","今日","做成","之","完全","下来","提高","社区","分享","我们","由","被","人类","许可证","会","越来越","部分","已经","用于","成果","至今","发展","轮子","那","上市","无论是","时至今日","远","、","嵌入","统统","全球","越来","看到","缩短","长远","全人类","就","开发工具","在","具备","体系","家","无论","这样","复合","以","造","率","已有","软件","大家","多媒体","就是","ros","案例","从","商业","新增","快速","核心","身影","制造","了","不要","特性","一个","生态系","采购","智能","友好","更","人才","生态","上去","嵌入式","“","代表","跑","普遍","集合","产品","不是","多","怀揣","商业化","他们"],"title":"ROS的特点","title_tokens":["特点","ros","的"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#ros_3","text":"社区是ROS快速发展的核心动力，什么是社区呢？其实就是ROS相关资源的整合方式，比如wiki说明、问答网站、应用源码、论坛讨论等都算是社区中的元素。 ROS全球社区有几个重要网站： answers.ros.org，这是一个ROS问答网站，大家可以在上边提出任何关于ROS的问题，全球很多开发者都很乐意回答我们的问题； wiki.ros.org，这是ROS的维基百科，记录了ROS教程和各种功能包的使用； discourse.ros.org，这是ROS论坛，关于ROS开发的新鲜事都可以在这里发表和查看，比如ROS的活动、新功能包的发布等等。 index.ros.org，是ROS各种资源的一个索引网站； packages.ros.org，是ROS功能包存储的数据库。 这几个网站的使用情况基本就可以代表ROS社区的活跃度了。 上图是近几年ROS社区页面浏览量的增长曲线，从总体趋势上来看，各项增长速度都非常快，wiki作为日常使用最为频繁的网站，使用度无疑是最高的，现在每个月有 150万左右 的访问量，answers和packages现在差不多，每个月有 80万 左右，其他两个不多，四项加起来每个月基本有 250万左右 的访问量，已经是一个活跃度非常棒的社区了。 从访问人数上来看，上边这张图更为清晰， wiki每个月有20到25万人使用 ， answers每个月有15万人以上使用 ，四项加起来每个月差不多有40多万的使用人数，这些用户绝大部分都是机器人开发者，可以看到ROS使用人数是越来越多了。 这张图是根据功能包下载次数统计得到的地域排名，基本上可以代表不同国家机器人研发的活跃程度，给大家作为一个参考。 总而言之，通过这些数据，我们可以看到的是ROS发展迅猛，正在助推机器人革命这一波大浪潮，大家每一个人在其中都大有可为。 如果你希望学习机器人开发，ROS绝对会成为你开发机器人的神兵利器，本教程也绝对是你的最佳选择。","text_tokens":["人","回答","wiki","维基百科","到","大有可为","棒","利器","百科","源码","很","其他","次数","趋势","这一波","万左右","访问","论坛","这是","机器人","迅猛","绝大","有","差不多","维基","动力","比如","什么","。","各种","discourse","使用","学习","15","活动","如果","大部","页面","程度","情况","来看","活跃","其实","80","，","资源","记录"," ","新鲜","问题","日常","org","：","中","总体","可以","下载","开发","快","也","；","度","这些","大部分","这里","人数","和","统计","是","这","上","最为","应用","正在","活跃度","无疑","神兵","250","功能","给","助推","浏览量","几年","增长","index","发表","不","成为","都","提出","加","数据","以上","packages","40","大","25","呢","几个","而言","数据库","据库","机器","150","发布","其中","任何","每个","开发者","新","浏览","非常","万","算是","张图","清晰","绝对","国家","很多","你","总而言之","整合","网站","地域","革命","研发","的","方式","索引","基本","两个","社区","关于","我们","等","多万","排名","万人","通过","会",".","速度","越来越","部分","已经","说明","浪潮","可为","现在","讨论","包","等等","各项","发展","本","越来","、","用户","全球","月","起来","更为","answers","看到","维基百","得到","上边","就","乐意","在","希望","基本上","问答","不同","参考","大家","新鲜事","就是","ros","最高","从","左右","不多","根据","重要","快速","核心","增长速度","了","元素","每","近几年","？","查看","绝大部分","一个","教程","20","选择","代表","上图","作为","频繁","最佳","存储","多","四项","访问量","曲线","相关"],"title":"ROS的社区","title_tokens":["ros","的","社区"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.1_ROS%E5%92%8CROS2%E6%98%AF%E4%BB%80%E4%B9%88/#_1","text":"关于本教程的参考资料，主要推荐这几个网站。 首先是最为推荐的搜索之王—— Google ，几乎所有问题，都可以在这里解决，作为开发工程师的同学，一定要掌握这个重要工具的使用方法。 其次是开源项目的主阵地—— Github ，ROS和社区中的绝大部分代码，都在这里托管，还有大量可以作为我们学习参考的开源项目都可以在这里找到，也是我们离不开的一个网站。 然后是 古月居 网站，这里有大量ROS机器人开发的技术内容和视频课程，还可以在泡泡板块中提问，也欢迎大家在这里和120万人分享你所学的知识。 最后是 本教程网站 ，会提供详细的ROS2入门教程，后续也会不断更新和扩展，努力成为大家学习ROS机器人开发的百科全书，配合课程视频学习，效果会更好。 好啦，欢迎大家来到ROS的世界，从这里开始，我们将一起踏上一段美妙的机器人开发之旅。","text_tokens":["首先","找到","主阵地","百科","更好","然后","一起","离不开","—","机器人","泡泡","绝大","有","之王","。","使用","知识","学习","大部","内容","ros2","资料","将","啦","，","居"," ","问题","更新","视频","中","也","要","可以","开发","几乎","课程","所有","大部分","这里","入门","和","还","最后","是","技术","这","最为","120","开源","这个","工程","同学","不断更新","搜索","成为","都","努力","还有","大量","几个","机器","扩展","世界","提供","提问","来到","工具","你","后续","踏上","代码","推荐","网站","详细","google","配合","的","效果","不开","主要","关于","社区","托管","我们","板块","分享","美妙","github","万人","会","部分","百科全书","本","一定","古月","欢迎","之旅","在","入门教程","开始","一段","掌握","参考","大家","不断","参考资料","项目","ros","工程师","全书","从","重要","绝大部分","一个","教程","所学","好","其次","作为","阵地","方法","解决"],"title":"参考资料","title_tokens":["资料","参考","参考资料"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/","text":"ROS2对比ROS1 在学习ROS2之前，你也许听说或使用过ROS1，ROS2从名称上来看，不就是在第二代ROS么，变化能有多大？ 我们就ROS1和ROS2做一个对比，看看这其中的变化到底有多大。 ROS1的局限性 首先来看第一个问题： 为什么会有ROS2？Why ROS2？ 当然是因为ROS1有一些问题了，具体是什么问题呢？从ROS发展的历史中，我们似乎可以找到答案。 ROS最早的设计目标就是开发这样一款PR2家庭服务机器人，这款机器人绝大部分时间都是独立工作，为了让他具备充足的能力： 它搭载了 工作站级别的计算平台 和各种先进的通信设备，不用担忧算力不够，有足够的实力支持各种复杂的实时运算和处理； 由于是单兵作战，通信绝大部分都自己内部完成，那就可以用有线连接， 保证了良好的网络连接 ，没有丢数据或者黑客入侵的风险； 这台机器人最终虽然小批量生产，但是由于 高昂的成本和售价 ，也只能用于学术研究。 随着ROS的普及，应用ROS的机器人类型已经和PR2机器人有了天翻地覆的问题，也并不具备PR2这样的条件，那原本针对PR2设计的软件框架，就会出现一些问题，比如： 要在资源有限的 嵌入式系统 中运行； 要在 有干扰的地方 保证通信的可靠性； 要做成 产品走向市场 ，甚至用在自动驾驶汽车和航天机器人上。 类似的问题不断涌现，致使更加适合各种机器人应用的新一代ROS诞生了，也就是我们课程的主角——ROS2。 全新的ROS2 ROS2怀揣变革智能机器人时代的历史使命，在设计之初，就考虑到要满足各种各样机器人应用的需求。 多机器人系统 ：未来机器人一定不会是独立的个体，机器人和机器人之间也需要通信和协作，ROS2为多机器人系统的应用提供了标准方法和通信机制。 跨平台 ：机器人应用场景不同，使用的控制平台也会有很大差异，比如自动驾驶汽车中的算力性能肯定比AMR机器人强很多，为了让所有机器人都可以运行ROS2，ROS2可以跨平台运行于Linux、Windows、MacOS、RTOS，甚至是没有任何系统的微控制器（MCU）上，这样我们就不用纠结自己的控制器能不能用ROS了。 实时性 ：机器人运动控制和很多行为策略要求机器人具备实时性，比如机器人要可靠得在100ms内发现前方的行人，或者稳定的在1ms周期内完成运动学、动力学的解算，ROS2为类似这样的实时性需求提供了基本保障。 网络连接 ：无论在怎样的网络环境下，ROS2都可以尽量保障机器人大量数据的完整性和安全性，比如在wifi信号不好的时候数据也要尽力发送过去，在有黑客入侵风险的场景下要对数据进行加密解密。 产品化 ：，大量机器人已经走向我们的生活，未来还会越来越多，ROS2不仅可以用于机器人研发阶段，还可以直接搭载在产品中，走向消费市场，这对ROS2的稳定性、强壮性也提除了巨大挑战。 项目管理 ：机器人开发是一个复杂的系统工程，设计、开发、调试、测试、部署等全流程的项目管理工具和机制，也会在ROS2中体现，更方便我们去开发一款机器人。 要满足这些需求，ROS2的设计和开发工作并不简单，相对手机这样标准化的产品，Android系统也可以尽量做到标准化，但是机器人课时千差万别， 如何能够适合尽量多的机器人，这可能远比开发一个手机系统或者电脑系统更加复杂。 ROS开发者面对的选择有两个，第一个是在ROS1的架构之上，进行修改和优化，类似一个盖好的房子，我们把它打成毛坯房，重新装修翻新一下，但肯定会受制于原本建筑的格局，长远来看并不是最佳选择，他们最终选择了第二种方案，那就是 推倒重来 。 所以ROS2是一个全新的机器人操作系统，在借鉴ROS1成功经验的基础上，对系统架构和软件代码全部进行了重新设计和实现。与ROS1相比，体现在以下几点： 系统架构进行了颠覆性的变化 ，ROS1中所有节点都需要在节点管理器ROS Master的管理下进行工作，一旦Master出现问题，系统就面临宕机的风险，ROS2实现了真正的分布式，不再有Master这个角色，借助一种全新的通信框架DDS，为所有节点的通信提供可靠保障。 软件API进行了重新设计 ，ROS1原有的接口已经无法满足需求，ROS2结合C++最新标准和Python3语言特性，设计了更具通用性的API，虽然导致原有ROS1的代码无法直接在ROS2中运行，但是尽量保留了类似的使用方法，同时提供了大量移植的说明。 编译系统进行了升级 ，ROS1中使用的rosbuild和catkin问题诸多，尤其是针对代码较多的大项目以及Python编写的项目，编译、链接经常会出错，ROS2对这些问题也进行了优化，重新优化后的编译系统叫做ament和colcon，大家在后续的课程中就会体验到新版编译器的使用方法。 这几点只是框架层面，ROS1和ROS2的明显变化，具体细节如何呢？我们继续给大家分解。 ROS2 vs ROS1 系统架构 在这张图中，左侧是ROS1，右侧是ROS2，大家注意看两者最明显的变化，那就是 Master 。 在ROS1中，应用层里Master这个节点管理器的角色至关重要，所有节点都得听它指挥，类似是一个公司的CEO，有且只有一个，如果这个CEO突然消失，公司肯定会成一团乱麻。ROS2把这个最不稳定的角色请走了，节点可以通过另外一套discovery—— 自发现机制 ，找到彼此，从而建立稳定的通信连接。 中间层是ROS封装好的标准通信接口，我们写程序的时候，会频繁和这些通信接口打交道，比如发布一个图像的数据，接收一个雷达的信息，客户端库会再调用底层复杂的驱动和通信协议，让我们的开发变得更加简单明了。 在ROS1中，ROS通信依赖底层的TCP和UDP协议，而在ROS2中，通信协议更换成了更加复杂但也更加完善的 DDS系统 。 如果是在进程内需要进行大量数据的通信，ROS1和ROS2都提供了基于 共享内存 的通信方法，只不过名字不太一样而已。 最下边是系统层，也就是可以将ROS安装在哪些操作系统上，ROS1主要安装在Linux上，ROS2的可选项就很多了， Linux、windows、MacOS、RTOS 都可以。 通过这样对比的方式，我们了解了ROS2的整体架构，如果大家有接触过ROS1，这个框架应该并不难理解，如果大家是从ROS2开始学习，先大致有一个印象，通过后续的学习，就会有更加深入的理解。 DDS通信 ROS2相比ROS1最大的变化，除了省略了Master之外，应该就是通信系统的变化了。ROS1中基于TCP/UDP的通信系统，频繁诟病于延迟、丢数据、无法加密等问题，ROS2中的DDS在通信层面的功能就丰富多了。 DDS其实是物联网中广泛应用的一种通信协议 ，类似于我们常听说的5G通信一样，DDS是一个国际标准，能够实现该标准的软件系统并不是唯一的，所以我们可以选择多个厂家提供的DDS系统，比如这里的OpenSplice、FastRTPS，还有更多厂家提供的，每一家的性能不同，适用的场景也不同。 不过这就带来一个问题，每个DDS厂家的软件接口肯定是不一样的，如果我们按照某一家的接口写完了程序，想要切换其他厂家的DDS，不是要重新写代码么？这当然不符合ROS提高软件复用率的目标。 为了解决这个问题，ROS2设计了一个 ROS Middleware，简称RMW ，也就是指定一个标准的接口，比如如何发数据，如何收数据，数据的各种属性如何配置，都定义好了，如果厂家想要接入ROS社区，就得按照这个标准写一个适配的接口，把自家的DDS给移植过来，这样就把问题交给了最熟悉自家DDS的厂商。对于我们这些用户来讲，某一个DDS用的不爽，只要安装另一个，然后做一个简单的配置，程序一行的都不用改，轻松更换底层的通信系统。 举一个例子，比如我们在产品开发时，可以先用开源版本的DDS满足基本需求，部署交付的产品时，再更换为商业版本更稳定的DDS，这样可以减少开发成本。 总之，DDS的加入，让ROS2系统更加稳定，也更加灵活，当然复杂度也会高一些。这样，我们不用再纠结ROS的通信系统是否稳定、该如何优化等问题，更多精力都可以放在其他三个部分，专注优化我们的机器人应用功能。 核心概念 ROS1应用已经非常广泛，全球有几百万开发者，大家已经熟悉了ROS1的开发方式以及其中的很多概念。ROS2尽量保留了这些概念，便于开发者从ROS1迁移到ROS2。 如果各位熟悉ROS1，这里的概念应该并不陌生，在ROS2中，这些概念依然存在，意义也几乎一致，在本课程的第二个部分，我们就会一一讲解这些概念的含义和使用方法，没有学习过ROS的小伙伴也不用担心。 编码方式 再来看看编码，同样是一个发布者的程序，ROS1和ROS2的实现版本如两个图片所示。 总体而言，ROS2会用到更多面向对象的实现方法和语言特性，从编程语言的角度来讲，难度确实会提高一些，不过当我们迈过这道坎之后，就会发现我们写的程序会更具备可读性和可移植性，也会更接接近真实企业中机器人软件开发的过程。 具体如何编码，大家暂且稍安勿躁，切记不要搬来一本大部头的编程语言教程，一页一页学习，更好的方式是在项目开发的过程中一边用一边学，后续课程我们也会带领大家一步一步来操作。 命令行 最后我们再对比下ROS开发中最为常用的一种工具——命令行。 ROS1中的命令行相对分散，每一个功能都是一个独立的命令，比如rosrun启动某一个节点，rostopic控制话题相关的功能。 ROS2对命令行做了大幅度的集成，所有命令都集成在一个ros2的主命令中，比如ros2 run，表示启动某一个节点，ros2 topic表示话题相关的功能。 除此之外，ros2命令行也会有更多功能，我们在后续教程中陆续揭秘。 好啦，以上，我们把ROS2和ROS1做了对比，总结而言就是： 节点干掉了Master 通信换成了DDS 核心概念没变化 编程难度有上升 如果大家初次上手就选择了ROS2，现有一个大致印象即可，跟随教程，你就会慢慢理解这些特性。","text_tokens":["变化","到","编译系统","面对","局限性","其他","上手","受制","之后","但是","opensplice","—","更加","有","最大","同时","物","比如","python","宕机","总之","丰富","尽量","设计","基于","平台","消失","信号","/","实时","策略","通信","动力学","了解","小","why","符合","之初","能","，","第二","资源"," ","为了","地方","命令","topic","黑客","接口","可以","pr2","要","discovery","课程","另外","这些","大部分","批量","这里","家庭","进行","请","发","学术","开源","过程","给","一团乱","至关重要","rmw","保证","限性","有限","一边","都","未来","诸多","出现","层","不过","良好","大量","中间","接触","命令行","例子","而言","能够","5g","各种各样","一种","微控制器","定义","rtos","现有","局限","非常","天翻地覆","使命","各位","两者","后续","对系统","封装","联网","只有","研发","可选","大致","该","的","最终","推倒","方式","编程语言","主要","社区","等","fastrtps","会","带来","一本","翻地","ceo","也许","全部","或","意义","挑战","本","越来","标准化","用户","要求","性","体验","tcp","答案","流程","翻新","长远","原有","勿躁","三个","具备","同样","框架","减少","rostopic","更接","100ms","变得","不同","一致","进程","就是","灵活","项目","调用","与","之外","角色","更具","是因为","比","实时性","完善","每","？","处理","vs","二个","一个","管理","master","c++","中间层","稍安","调试","指定","后","可靠性","解决","过去","怀揣","控制器","首先","找到","不能","单兵","航天","做到","再","更好","支持","绝大","方便","建立","百万","课时","印象","跨平台","。","各种","暂且","软件开发","应用层","可移植","类似","突然","需求","学习","下边","历史","面临","启动","适配","计算","链接","省略","操作","提","来看","来讲","啦","其实","干掉","广泛应用","多个","之间","也","通信协议","搭载","驱动","开发","左侧","之前","；","成功经验","诟病","收","几乎","而已","当","和","基本保障","不太","服务","致使","右侧","小伙","上","）","工作","分布式","对比","功能","成本","版本","担心","似乎","客户","主","驾驶","时","迁移","完整性","重来","生产","方案","安全性","以及","控制","ros1","编写","自家","另","想要","大","学","不会","诞生","共享内存","层面","名称","带领","电脑","属性","角度","机器","存在","怎样","借助","通信接口","放在","通用","初次","其中","每个","广泛","阶段","可移植性","适用","移植","udp","语言","并","是否","甚至","稳定","细节","代码","分解","尽力","伙伴","话题","做成","1ms","理器","两个","移植性","继续","通过","级别","用于","已经","担忧","内存","里","信息","满足","分布","只能","性能","全球","catkin","轻松","实力","颠覆性","因为","安装","在","开始","揭秘","厂家","mcu","测试","结合","新一代","率","前方","网络","工作站","升级","接收","项目管理","上升","ros","可选项","慢慢","看看","可能","时代","一一","批量生产","特性","安全","随着","最早","虽然","教程","大幅","不用","总体而言","还会","自","更","节点","主角","力学","时候","借鉴","除了","只是","从而","编程","几点","没有","不是","不够","最","毛坯","至关","相关","用到","各样","linux","ament","系统","不仅","然后","一下","受制于","成功","稳定性","机器人","api","面向","走向市场","标准","用","run","动力","高昂","时间","由于","为","下","雷达","编码","ros2","简称","几百万","库会","毛坯房","一家","产品开发","中","：","间层","所有","彼此","最后","格局","写","应用","windows","迈过","下要","图片","做","有且","涌现","去","除此","对象","款","考虑","手机","指挥","所以","道坎","某","乱麻","数据","国际","还有","周期","复杂","相对","具体","把","不难理解","企业","全","更换","经常","唯一","深入","提供","强","部头","汽车","全新","任何","不爽","单兵作战","只要","完","切换","rosbuild","举","确实","以下几点","开发者","管理器","布式","颠覆","dds","原本","第二种","很多","你","变革","而","幅度","一旦","名字","难度","编译","新版","便于","基础","装修","发布者","提高","它","打成","理解","差异","强壮","越来越","说明","房子","之上","只不过","部署","发展","那","陌生","、","程序","独立","系统工程","历史使命","较","客户端","走","这样","不再","完成","导致","真正","纠结","得","先进","通用性","会成","大家","软件","几百","经验","重要","macos","所示","核心","架构","了","不要","专注","除此之外","操作系统","有线","一代","加入","么","智能","可靠","注意","选择","作战","千差万别","第一","二代","体现","修改","最佳","二种","频繁","rosrun","自动","走向","产品","研究","多","盖","解算","入侵","第二代","如","开发成本","普及","过","改","到底","电脑系统","发送","实现","很大","直接","常","成","编译器","android","总结","开发方式","干扰","发现","哪些","（","接近","切记","什么","使用","一步","远比","公司","第二个","小伙伴","是从","定性","如果","大部","明显","风险","不好","底层","简单","自己","设备","推倒重来","消费","延迟","厂商","打交道","将","含义","wifi","交付","python3","问题","精力","一团","总体","完整","高","还","是","无法","当然","这","对于","配置","出错","最为","售价","这个","amr","一些","相比","应该","目标","工程","一团乱麻","集成","机制","过来","一页","不难","一套","复杂度","不","这台","协议","巨大","对","建筑","以上","运动学","运动","整体","依赖","保障","来","呢","类型","陆续","他","共享","适合","发成","需要","简单明了","搬","概念","多功能","发布","足够","工具","解密","运算","表示","软件系统","讲解","张图","网络连接","行为","重新","面向对象","复用","交给","优化","一行","内","常用","或者","可读","选项","交道","环境","以下","基本","我们","为什么","国际标准","充足","真实","学术研究","部分","最新","即可","没","针对","行人","但","大幅度","丢","依然","嵌入","一定","跟随","就","熟悉","连接","看","市场","换成","无论","保留","一款","加密","不断","听","大部头","尤其","从","商业","听说","编码方式","一样","肯定","生活","场景","条件","协作","消费市场","绝大部分","算力","colcon","先","能力","按照","叫做","如何","个体","接入","嵌入式","好","于","middleware","第一个","内部","可读性","运行","分散","让","方法","图像","他们","产品化","不断涌现"],"title":"ROS2对比ROS1","title_tokens":["ros1","对比","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#ros2ros1","text":"在学习ROS2之前，你也许听说或使用过ROS1，ROS2从名称上来看，不就是在第二代ROS么，变化能有多大？ 我们就ROS1和ROS2做一个对比，看看这其中的变化到底有多大。","text_tokens":["之前","变化","就","其中","在","和","过","这","上","到底","对比","你","有","做","就是","ros","从","看看","的","。","听说","使用","不","学习","？","我们","么","一个","ros1","大","ros2","也许","名称","或","来看","二代","能","，","第二","多"," ","第二代"],"title":"ROS2对比ROS1","title_tokens":["ros1","对比","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#ros1","text":"首先来看第一个问题： 为什么会有ROS2？Why ROS2？ 当然是因为ROS1有一些问题了，具体是什么问题呢？从ROS发展的历史中，我们似乎可以找到答案。 ROS最早的设计目标就是开发这样一款PR2家庭服务机器人，这款机器人绝大部分时间都是独立工作，为了让他具备充足的能力： 它搭载了 工作站级别的计算平台 和各种先进的通信设备，不用担忧算力不够，有足够的实力支持各种复杂的实时运算和处理； 由于是单兵作战，通信绝大部分都自己内部完成，那就可以用有线连接， 保证了良好的网络连接 ，没有丢数据或者黑客入侵的风险； 这台机器人最终虽然小批量生产，但是由于 高昂的成本和售价 ，也只能用于学术研究。 随着ROS的普及，应用ROS的机器人类型已经和PR2机器人有了天翻地覆的问题，也并不具备PR2这样的条件，那原本针对PR2设计的软件框架，就会出现一些问题，比如： 要在资源有限的 嵌入式系统 中运行； 要在 有干扰的地方 保证通信的可靠性； 要做成 产品走向市场 ，甚至用在自动驾驶汽车和航天机器人上。 类似的问题不断涌现，致使更加适合各种机器人应用的新一代ROS诞生了，也就是我们课程的主角——ROS2。","text_tokens":["首先","普及","找到","单兵","系统","航天","但是","机器人","更加","支持","—","绝大","有","走向市场","用","干扰","比如","什么","。","时间","各种","高昂","由于","设计","类似","平台","大部","风险","历史","实时","设备","通信","自己","计算","ros2","小","why","来看","，","资源"," ","为了","问题","地方","中","：","黑客","搭载","可以","pr2","开发","也","；","要","课程","大部分","批量","和","家庭","是","服务","当然","致使","这","上","学术","售价","应用","工作","一些","成本","目标","涌现","似乎","款","保证","驾驶","有限","不","都","这台","生产","数据","复杂","ros1","出现","具体","良好","诞生","呢","类型","他","适合","机器","汽车","足够","单兵作战","运算","网络连接","原本","天翻地覆","并","甚至","或者","的","最终","做成","它","我们","为什么","充足","会","级别","学术研究","部分","用于","已经","翻地","担忧","针对","发展","那","丢","只能","嵌入","独立","答案","实力","因为","就","连接","在","具备","市场","框架","这样","完成","先进","新一代","一款","网络","工作站","软件","就是","不断","ros","从","批量生产","是因为","了","条件","随着","？","最早","绝大部分","算力","一个","处理","有线","虽然","不用","一代","可靠","能力","主角","嵌入式","作战","第一个","第一","内部","运行","没有","让","可靠性","自动","走向","产品","研究","不够","入侵","不断涌现"],"title":"ROS1的局限性","title_tokens":["局限性","局限","ros1","的","限性"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#ros2","text":"ROS2怀揣变革智能机器人时代的历史使命，在设计之初，就考虑到要满足各种各样机器人应用的需求。 多机器人系统 ：未来机器人一定不会是独立的个体，机器人和机器人之间也需要通信和协作，ROS2为多机器人系统的应用提供了标准方法和通信机制。 跨平台 ：机器人应用场景不同，使用的控制平台也会有很大差异，比如自动驾驶汽车中的算力性能肯定比AMR机器人强很多，为了让所有机器人都可以运行ROS2，ROS2可以跨平台运行于Linux、Windows、MacOS、RTOS，甚至是没有任何系统的微控制器（MCU）上，这样我们就不用纠结自己的控制器能不能用ROS了。 实时性 ：机器人运动控制和很多行为策略要求机器人具备实时性，比如机器人要可靠得在100ms内发现前方的行人，或者稳定的在1ms周期内完成运动学、动力学的解算，ROS2为类似这样的实时性需求提供了基本保障。 网络连接 ：无论在怎样的网络环境下，ROS2都可以尽量保障机器人大量数据的完整性和安全性，比如在wifi信号不好的时候数据也要尽力发送过去，在有黑客入侵风险的场景下要对数据进行加密解密。 产品化 ：，大量机器人已经走向我们的生活，未来还会越来越多，ROS2不仅可以用于机器人研发阶段，还可以直接搭载在产品中，走向消费市场，这对ROS2的稳定性、强壮性也提除了巨大挑战。 项目管理 ：机器人开发是一个复杂的系统工程，设计、开发、调试、测试、部署等全流程的项目管理工具和机制，也会在ROS2中体现，更方便我们去开发一款机器人。 要满足这些需求，ROS2的设计和开发工作并不简单，相对手机这样标准化的产品，Android系统也可以尽量做到标准化，但是机器人课时千差万别， 如何能够适合尽量多的机器人，这可能远比开发一个手机系统或者电脑系统更加复杂。 ROS开发者面对的选择有两个，第一个是在ROS1的架构之上，进行修改和优化，类似一个盖好的房子，我们把它打成毛坯房，重新装修翻新一下，但肯定会受制于原本建筑的格局，长远来看并不是最佳选择，他们最终选择了第二种方案，那就是 推倒重来 。 所以ROS2是一个全新的机器人操作系统，在借鉴ROS1成功经验的基础上，对系统架构和软件代码全部进行了重新设计和实现。与ROS1相比，体现在以下几点： 系统架构进行了颠覆性的变化 ，ROS1中所有节点都需要在节点管理器ROS Master的管理下进行工作，一旦Master出现问题，系统就面临宕机的风险，ROS2实现了真正的分布式，不再有Master这个角色，借助一种全新的通信框架DDS，为所有节点的通信提供可靠保障。 软件API进行了重新设计 ，ROS1原有的接口已经无法满足需求，ROS2结合C++最新标准和Python3语言特性，设计了更具通用性的API，虽然导致原有ROS1的代码无法直接在ROS2中运行，但是尽量保留了类似的使用方法，同时提供了大量移植的说明。 编译系统进行了升级 ，ROS1中使用的rosbuild和catkin问题诸多，尤其是针对代码较多的大项目以及Python编写的项目，编译、链接经常会出错，ROS2对这些问题也进行了优化，重新优化后的编译系统叫做ament和colcon，大家在后续的课程中就会体验到新版编译器的使用方法。 这几点只是框架层面，ROS1和ROS2的明显变化，具体细节如何呢？我们继续给大家分解。","text_tokens":["变化","到","编译系统","面对","受制","但是","更加","有","同时","比如","python","宕机","尽量","设计","平台","信号","实时","策略","通信","动力学","之初","能","，","第二","为了"," ","黑客","接口","可以","要","课程","这些","进行","给","都","未来","诸多","出现","大量","能够","各种各样","一种","微控制器","rtos","使命","后续","对系统","研发","的","最终","推倒","等","会","全部","挑战","越来","标准化","要求","性","体验","流程","翻新","长远","原有","具备","框架","100ms","不同","就是","项目","与","角色","更具","比","实时性","？","一个","管理","master","c++","调试","后","过去","怀揣","控制器","不能","做到","方便","课时","跨平台","。","各种","类似","需求","历史","面临","链接","操作","提","来看","之间","也","搭载","开发","成功经验","和","基本保障","上","）","工作","分布式","驾驶","完整性","重来","方案","安全性","以及","控制","ros1","编写","大","不会","层面","电脑","机器","怎样","借助","通用","阶段","移植","语言","并","甚至","稳定","细节","代码","分解","尽力","1ms","理器","两个","继续","已经","用于","满足","分布","性能","catkin","颠覆性","在","mcu","测试","结合","前方","网络","升级","项目管理","ros","可能","时代","特性","安全","虽然","不用","还会","更","节点","力学","借鉴","时候","除了","只是","几点","没有","不是","毛坯","各样","linux","ament","系统","不仅","一下","受制于","成功","稳定性","机器人","api","标准","用","动力","为","下","ros2","毛坯房","中","：","所有","格局","应用","windows","下要","去","考虑","手机","所以","数据","周期","复杂","相对","把","具体","全","经常","提供","强","汽车","全新","任何","rosbuild","以下几点","开发者","管理器","布式","颠覆","dds","原本","第二种","很多","变革","一旦","编译","新版","基础","装修","它","打成","差异","强壮","越来越","说明","房子","之上","部署","那","、","独立","系统工程","历史使命","较","这样","不再","完成","导致","真正","纠结","得","通用性","大家","软件","经验","macos","架构","了","操作系统","智能","可靠","选择","千差万别","第一","体现","二种","最佳","修改","自动","走向","产品","盖","多","解算","入侵","电脑系统","发送","实现","很大","直接","编译器","android","发现","（","使用","远比","定性","明显","风险","不好","简单","自己","推倒重来","消费","wifi","python3","问题","完整","还","是","无法","这","出错","这个","amr","相比","工程","机制","不","巨大","对","建筑","运动学","运动","保障","呢","适合","需要","工具","解密","网络连接","行为","重新","优化","内","或者","环境","以下","基本","我们","最新","针对","行人","但","一定","就","连接","市场","无论","保留","一款","加密","尤其","肯定","生活","场景","协作","消费市场","算力","colcon","叫做","如何","个体","好","于","第一个","运行","让","方法","他们","产品化"],"title":"全新的ROS2","title_tokens":["全新","的","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#ros2-vs-ros1","text":"","text_tokens":[],"title":"ROS2 vs ROS1","title_tokens":["ros1"," ","vs","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#_1","text":"在这张图中，左侧是ROS1，右侧是ROS2，大家注意看两者最明显的变化，那就是 Master 。 在ROS1中，应用层里Master这个节点管理器的角色至关重要，所有节点都得听它指挥，类似是一个公司的CEO，有且只有一个，如果这个CEO突然消失，公司肯定会成一团乱麻。ROS2把这个最不稳定的角色请走了，节点可以通过另外一套discovery—— 自发现机制 ，找到彼此，从而建立稳定的通信连接。 中间层是ROS封装好的标准通信接口，我们写程序的时候，会频繁和这些通信接口打交道，比如发布一个图像的数据，接收一个雷达的信息，客户端库会再调用底层复杂的驱动和通信协议，让我们的开发变得更加简单明了。 在ROS1中，ROS通信依赖底层的TCP和UDP协议，而在ROS2中，通信协议更换成了更加复杂但也更加完善的 DDS系统 。 如果是在进程内需要进行大量数据的通信，ROS1和ROS2都提供了基于 共享内存 的通信方法，只不过名字不太一样而已。 最下边是系统层，也就是可以将ROS安装在哪些操作系统上，ROS1主要安装在Linux上，ROS2的可选项就很多了， Linux、windows、MacOS、RTOS 都可以。 通过这样对比的方式，我们了解了ROS2的整体架构，如果大家有接触过ROS1，这个框架应该并不难理解，如果大家是从ROS2开始学习，先大致有一个印象，通过后续的学习，就会有更加深入的理解。","text_tokens":["变化","找到","linux","系统","过","再","—","更加","有","成","建立","标准","印象","发现","哪些","比如","。","应用层","公司","类似","突然","基于","是从","学习","如果","明显","消失","下边","底层","简单","雷达","通信","ros2","打交道","将","库会","操作","了解","，"," ","一团","中","也","接口","discovery","可以","左侧","驱动","间层","另外","通信协议","所有","这些","开发","而已","彼此","和","不太","是","写","进行","右侧","这","请","上","应用","windows","这个","对比","一团乱","应该","有且","至关重要","一团乱麻","客户","最","机制","不难","一套","指挥","不","都","协议","乱麻","数据","复杂","ros1","层","整体","把","依赖","不难理解","不过","共享内存","大量","中间","更换","共享","接触","深入","需要","提供","简单明了","通信接口","发布","rtos","管理器","udp","张图","dds","并","而","两者","很多","后续","稳定","封装","内","名字","只有","大致","可选","的","选项","方式","交道","理器","主要","它","我们","理解","会","通过","ceo","只不过","但","内存","那","里","信息","、","程序","tcp","安装","就","在","看","连接","客户端","开始","框架","走","这样","得","变得","会成","大家","接收","进程","就是","听","ros","可选项","调用","角色","重要","一样","肯定","macos","架构","了","完善","操作系统","一个","master","管理","注意","先","自","节点","中间层","好","时候","从而","频繁","让","方法","图像","至关"],"title":"系统架构","title_tokens":["系统","架构"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#dds","text":"ROS2相比ROS1最大的变化，除了省略了Master之外，应该就是通信系统的变化了。ROS1中基于TCP/UDP的通信系统，频繁诟病于延迟、丢数据、无法加密等问题，ROS2中的DDS在通信层面的功能就丰富多了。 DDS其实是物联网中广泛应用的一种通信协议 ，类似于我们常听说的5G通信一样，DDS是一个国际标准，能够实现该标准的软件系统并不是唯一的，所以我们可以选择多个厂家提供的DDS系统，比如这里的OpenSplice、FastRTPS，还有更多厂家提供的，每一家的性能不同，适用的场景也不同。 不过这就带来一个问题，每个DDS厂家的软件接口肯定是不一样的，如果我们按照某一家的接口写完了程序，想要切换其他厂家的DDS，不是要重新写代码么？这当然不符合ROS提高软件复用率的目标。 为了解决这个问题，ROS2设计了一个 ROS Middleware，简称RMW ，也就是指定一个标准的接口，比如如何发数据，如何收数据，数据的各种属性如何配置，都定义好了，如果厂家想要接入ROS社区，就得按照这个标准写一个适配的接口，把自家的DDS给移植过来，这样就把问题交给了最熟悉自家DDS的厂商。对于我们这些用户来讲，某一个DDS用的不爽，只要安装另一个，然后做一个简单的配置，程序一行的都不用改，轻松更换底层的通信系统。 举一个例子，比如我们在产品开发时，可以先用开源版本的DDS满足基本需求，部署交付的产品时，再更换为商业版本更稳定的DDS，这样可以减少开发成本。 总之，DDS的加入，让ROS2系统更加稳定，也更加灵活，当然复杂度也会高一些。这样，我们不用再纠结ROS的通信系统是否稳定、该如何优化等问题，更多精力都可以放在其他三个部分，专注优化我们的机器人应用功能。","text_tokens":["变化","系统","其他","改","再","然后","实现","opensplice","机器人","更加","常","最大","标准","用","物","比如","。","各种","总之","丰富","类似","基于","设计","需求","如果","为","底层","简单","/","通信","适配","厂商","延迟","ros2","简称","省略","符合","来讲","一家","其实","，","广泛应用","交付","多个"," ","为了","问题","产品开发","精力","中","也","通信协议","可以","接口","诟病","要","收","开发","这些","高","这里","是","无法","写","当然","这","发","对于","配置","应用","开源","这个","功能","给","一些","相比","应该","成本","目标","做","版本","rmw","过来","时","复杂度","不","所以","都","协议","某","数据","国际","还有","自家","复杂","ros1","另","把","想要","不过","层面","更换","属性","例子","发成","5g","能够","唯一","机器","提供","放在","一种","广泛","每个","不爽","只要","完","切换","定义","举","软件系统","适用","udp","移植","dds","重新","并","复用","交给","是否","稳定","优化","代码","一行","联网","该","的","基本","提高","社区","我们","等","fastrtps","国际标准","会","带来","部分","部署","丢","满足","性能","、","用户","程序","轻松","tcp","就","熟悉","在","安装","三个","这样","减少","厂家","纠结","得","不同","率","加密","软件","就是","灵活","ros","之外","商业","听说","一样","肯定","场景","了","专注","每","加入","？","一个","么","master","不用","按照","先","更","如何","接入","好","选择","于","除了","middleware","指定","频繁","让","解决","产品","多","不是","最","开发成本"],"title":"DDS通信","title_tokens":["通信","dds"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#_2","text":"ROS1应用已经非常广泛，全球有几百万开发者，大家已经熟悉了ROS1的开发方式以及其中的很多概念。ROS2尽量保留了这些概念，便于开发者从ROS1迁移到ROS2。 如果各位熟悉ROS1，这里的概念应该并不陌生，在ROS2中，这些概念依然存在，意义也几乎一致，在本课程的第二个部分，我们就会一一讲解这些概念的含义和使用方法，没有学习过ROS的小伙伴也不用担心。","text_tokens":["其中","几乎","熟悉","广泛","这些","到","这里","在","课程","就","和","过","开发者","讲解","非常","保留","小伙","应用","一致","并","各位","很多","有","大家","应该","几百","百万","伙伴","ros","开发方式","担心","从","也","的","。","方式","一一","便于","使用","迁移","不","尽量","了","第二个","小伙伴","我们","如果","二个","学习","会","不用","以及","ros1","部分","已经","几百万","ros2","含义","意义","没有","，","陌生","依然","存在","本","第二"," ","方法","全球","中","概念","开发"],"title":"核心概念","title_tokens":["概念","核心"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#_3","text":"再来看看编码，同样是一个发布者的程序，ROS1和ROS2的实现版本如两个图片所示。 总体而言，ROS2会用到更多面向对象的实现方法和语言特性，从编程语言的角度来讲，难度确实会提高一些，不过当我们迈过这道坎之后，就会发现我们写的程序会更具备可读性和可移植性，也会更接接近真实企业中机器人软件开发的过程。 具体如何编码，大家暂且稍安勿躁，切记不要搬来一本大部头的编程语言教程，一页一页学习，更好的方式是在项目开发的过程中一边用一边学，后续课程我们也会带领大家一步一步来操作。","text_tokens":["再","更好","之后","实现","机器人","面向","用","发现","接近","切记","。","一步","暂且","软件开发","可移植","学习","大部","编码","ros2","操作","来讲","，"," ","中","也","总体","如","开发","课程","当","和","是","写","这","迈过","过程","一些","图片","版本","对象","一页","一边","道坎","ros1","具体","企业","不过","来","学","带领","角度","而言","机器","部头","搬","发布","可移植性","确实","移植","语言","面向对象","后续","难度","可读","的","方式","发布者","两个","编程语言","提高","移植性","我们","会","一本","真实","程序","就","在","勿躁","同样","具备","更接","大家","软件","大部头","项目","从","看看","所示","特性","不要","一个","教程","总体而言","更","如何","稍安","可读性","编程","方法","多","用到"],"title":"编码方式","title_tokens":["方式","编码","编码方式"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/#_4","text":"最后我们再对比下ROS开发中最为常用的一种工具——命令行。 ROS1中的命令行相对分散，每一个功能都是一个独立的命令，比如rosrun启动某一个节点，rostopic控制话题相关的功能。 ROS2对命令行做了大幅度的集成，所有命令都集成在一个ros2的主命令中，比如ros2 run，表示启动某一个节点，ros2 topic表示话题相关的功能。 除此之外，ros2命令行也会有更多功能，我们在后续教程中陆续揭秘。 好啦，以上，我们把ROS2和ROS1做了对比，总结而言就是： 节点干掉了Master 通信换成了DDS 核心概念没变化 编程难度有上升 如果大家初次上手就选择了ROS2，现有一个大致印象即可，跟随教程，你就会慢慢理解这些特性。","text_tokens":["变化","上手","再","—","有","总结","印象","run","比如","。","如果","下","启动","通信","ros2","啦","干掉","，"," ","命令","：","topic","中","也","开发","所有","这些","和","最后","是","最为","对比","功能","做","除此","主","集成","都","某","对","以上","控制","ros1","相对","把","命令行","陆续","而言","多功能","概念","初次","一种","工具","现有","表示","dds","你","后续","幅度","难度","常用","大致","话题","的","我们","理解","会","即可","没","大幅度","独立","跟随","就","在","揭秘","换成","rostopic","大家","上升","慢慢","就是","ros","之外","核心","特性","除此之外","了","每","一个","教程","master","大幅","更","节点","好","选择","分散","编程","rosrun","相关"],"title":"命令行","title_tokens":["命令","命令行"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/","text":"ROS2安装方法 本节，我们一起安装ROS2，安装前先要了解一下ROS2底层最重要的一种操作系统——Linux。 Linux系统简介 时间回到1991年，一位热爱计算机的芬兰大学生 林纳斯 ，在熟悉了操作系统原理和unix系统后，决定自己动手做一个，实践是检验真理的唯一标准，说干就干，他参考已有的一些通用标准，重新设计了一套操作系统内核，不仅可以实现多用户、多任务的管理，还可以兼容unix原有的应用程序。最重要的是，他把这套尚不成熟的操作系统分享到了互联网上，并用自己的名字命名了这套系统，也就是 Linux 。 原本出于个人爱好的Linux系统通过互联网快速传播，更多爱好者看到Linux之后，也激发了乐于分享的热情，就把使用过程中的问题和修复方法做了反馈。 一石激起千层浪，越来越多人加入到了Linux维护的行列当中，一个原本功能有限、bug很多的操作系统，快速强大起来， 伴随其中发扬光大的是开源精神 。 与Windows系统收费，或MacOS硬件绑定的模式不同， Linux是一套免费并且开放源代码的操作系统 ，任何人都可以使用或者提交反馈，这就吸引了大量的开发者、爱好者，甚至很多企业，现在，每年对Linux系统提交的代码量已经成为衡量一个大公司技术实力的重要指标之一。 Linux发展迅猛，已经成为了性能稳定的多用户操作系统，也是ROS2依赖的重要底层系统。虽然ROS2目前也支持Windows、MacOS，但对Linux系统的支持最好，在本教程中，我们主要讲解Linux之上的ROS2使用方法，其他系统原理也基本相同。 所以在使用ROS2之前，我们需要先安装Linux，此时会出现另外一个概念—— 发行版 。 什么叫发行版呢？准确来讲，我们提到的 Linux应该叫做操作系统内核 ，并没有可视化界面，发行版就是给这个内核加上华丽的外衣，把操作界面和各种应用软件放到一起，打包成我们安装系统的镜像。 所以一般情况下，我们常用到的Linux系统，都是各种各样的发行版，比如Ubuntu、Fedora、RedHat等等，每一个发行版都有其适用的场景，比如RedHat适合商业应用、CentOS适合服务器、Ubuntu、Fedora适合个人使用等，每一个版本的界面不太一样，但核心都是Linux，操作方法基本相同。 Ubuntu系统简介 我们后续课程使用到的Linux发行版就是 ubuntu系统 。 Ubuntu诞生于2004年10月份， 每六个月发布一个新版本 ，用户可以一直免费升级使用，我们常用的浏览器、文件编辑器、通讯软件等一应俱全。在软件开发领域，无论是互联网开发，还是人工智能开发，还是大家关注的机器人开发，Ubuntu都占据绝对重要的位置。 Ubuntu的版本变动比较快，如何选择合适自己使用的版本很重要，因为其中各种软件版本不同会直接影响我们上层应用的移植效果。在选择版本的时候，大家可以关注一下紧随其后的编号，比如Ubuntu22.04。22代表2022年，04表示2022年的4月份发布，除了04还可能会出现的是10，就是10月份发布，所以从数字编号上就可以看出各个版本发布的顺序。 但是这样依然会有很多版本，为了让更多开发者有一个稳定的系统环境，Ubuntu每隔两年的4月份会发布一个长期支持版，后缀会加LTS，保证5年之内持续维护更新，比如Ubuntu20.04 LTS，Ubuntu22.04 LTS，除此之外的版本都是普通版，只维护18个月，所以大家在选择时， 优先考虑长期支持版 。 在本教程中，我们以 Ubuntu22.04 为例进行讲解，大家也可以选择其他长期支持版本。 好了，大家一定已经摩拳擦掌想要试一试Ubuntu了，安装方法很多，如果你之前已经熟悉Linux，建议在电脑上硬盘安装Ubuntu，这样可以发挥出硬件最大的性能，如果你是第一次接触Linux，建议在已有的windows上通过虚拟机安装，未来熟悉之后再考虑硬盘安装。 这里我们主要介绍虚拟机中的安装方法，大家也可以参考课程资料或网络资料，自行考虑硬盘安装。 Ubuntu虚拟机安装 虚拟机是一个软件，可以在已有系统之上，构建另外一个虚拟的系统，让多个操作环境同时运行。 这里我们采用的虚拟机软件叫做vmware，下载地址如下，安装步骤和其他软件相同，请大家自行下载并安装： https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html 准备工作完成后，就可以开始系统安装啦，安装步骤如下： 1. 下载系统镜像 下载链接： https://ubuntu.com/download/desktop 2. 在虚拟机中创建系统 3. 设置虚拟机硬盘大小 4. 设置Ubuntu镜像路径 5. 启动虚拟机 6. 设置用户名和密码 7. 等待系统安装 8. 完成安装 Ubuntu系统安装好后，大家可以先随意使用熟悉一下。 ROS2系统安装 接下来，我们就可以把ROS2安装到Ubuntu系统中了。安装步骤如下： 1. 设置编码 $ sudo apt update && sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL = en_US.UTF-8 LANG = en_US.UTF-8 $ export LANG = en_US.UTF-8 2. 添加源 $ sudo apt update && sudo apt install curl gnupg lsb-release $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg $ echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( source /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 如遇报错“ Failed to connect to raw.githubusercontent.com ”，可参考 https://www.guyuehome.com/37844 3. 安装ROS2 $ sudo apt update $ sudo apt upgrade $ sudo apt install ros-humble-desktop 4. 设置环境变量 $ source /opt/ros/humble/setup.bash $ echo \" source /opt/ros/humble/setup.bash\" >> ~/.bashrc 至此，ROS2就已经在系统中安装好了。 ROS2示例测试 为了验证ROS2安装成功，我们可以通过以下示例进行测试。 示例一：命令行示例 先来试试ROS2最为重要的底层通信系统DDS是否正常吧。 启动第一个终端，通过以下命令启动一个数据的发布者节点： $ ros2 run demo_nodes_cpp talker 启动第二个终端，通过以下命令启动一个数据的订阅者节点： $ ros2 run demo_nodes_py listener 如果“Hello World”字符串在两个终端中正常传输，说明通信系统没有问题。 示例二：小海龟仿真示例 再来试一试ROS中的经典示例——小海龟仿真器。 启动两个终端，分别运行如下指令： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key 第一句指令将启动一个蓝色背景的海龟仿真器，第二句指令将启动一个键盘控制节点，在该终端中点击键盘上的“上下左右”按键，就可以控制小海龟运动啦。 关于小海龟中蕴藏的ROS奥义，我们在后续教程中将持续探索。 至此，ROS2安装成功。","text_tokens":["”","到","任务","其他","算机","com","千层浪","二","之后","一起","但是","—","摩拳擦掌","有","最大","节","同时","多人","试试","比如","环境变","设计","]","紧随其后","情况","激发","/","setup","通信","之一","了解","，","第二"," ","为了","更新","workstation","org","命令","订阅","可以","ubuntu","课程","另外","这里","一直","两年","进行","一应俱全","蕴藏","请","us","开源","过程","给","出","保证","有限","简介","都","好后","未来","--","出现","第一次","大量","命令行","接触","并且","构建","world","各种各样","基本相同","一种","小海龟","热爱","步骤","仿真","版","当中","6","ssl","raw","后续","行列","背景","tee","联网","该","opt","的","操作方法","人工","~","应用软件","分享","主要","关于","等","etc","18","githubusercontent","吧","会","现在","内核","字符串","何人","或","大学","本","越来","用户","接下","多用","redhat",")","此时","usr","可视","千层","原有","1","命名","准备","不同","lsb","林纳斯","准确","已有","就是","之外","与","左右","大小","evaluation","每","？","二个","一个","管理","master","界面","指令","并用","打包","“","后","上层","地址","最好","密码","变动","优先","sources","顺序","再","领域","随意","支持","正常","技术实力","放到","长期","|","。","各种","路径","软件开发","node","一次","apt","3","反馈","all","启动","计算","2004","链接","操作","to","来讲","啦","多个","决定","下载","也","真器","开发","快","之前","turtle","和","目前","介绍","不太","keyring","服务","lc","上","工作","功能","乐于","bug","by","吸引","guyuehome","版本","时","终端","_","print","share","packages","控制",":","尚","想要","大","诞生","经典","unix","操作界面","电脑","[","机器","可","通用","其中","-","关注","用户名","原理","适用","移植","7","外衣","并","ubuntu22.04","是否","接下来","甚至","稳定","代码","其","en","source","两个","发挥","通过",".","发扬光大","已经","os","编号",">","文件","兼容","性能","看到","环境变量","teleop","实力","安装","一位","在","模式","因为","发行版","开始","仿真器","export","占据","建议","任何人","测试","如下","个","参考","源","网络","先要","升级","至此","desktop","ros","可能","强大","快速","connect","伴随","pro","虽然","2022","教程","listener","rosdistro","更","节点","提交","arch","locales","时候","install","除了","蓝色","没有","最","dev","个人爱好","开放","各样","后缀","linux","系统","不仅","10","看出","一下","成功","迅猛","机器人","创建","回到","计算机","月份","deb","标准","持续","centos","run","时间","多任务","下","硬盘","会加","数字","编码","null","ros2","nodes","奥义","虚拟","中","：","每隔","相同","http","www","激起","hello","动手做","可视化","技术","修复","应用","windows","分别","做","硬件","收费","5","编辑器","除此","出于","考虑","字符","update","所以","数据","bashrc","把","企业","普通","上下左右","codename","唯一","比较","实践","爱好","任何","免费","开发者","新","镜像","上下","多用户","o","dds","原本","22","采用","一句","很多","你","2","名字","&&","效果","发布者","如遇","utf","key","越来越","curl","之内","archive","说明","html","之上","bash","https","合适","发展","fedora","量","、","等待","程序","起来","位置","main","这样","完成","户名","互联网","俱全","一般","以","小海","发行","大家","软件","products","architecture","第一句","芬兰","爱好者","重要","试一试","macos","核心","除此之外","了","操作系统","加入","变量","其他软件","智能","传播","一","选择","gnupg","第一","代表","多","keyrings","(","1991","ubuntu20.04","很","衡量","示例","光大","实现","提到","直接","成","4","py","什么","影响","报错","学生","使用","demo","公司","第二个","按键","绑定","如果","lang","talker","底层","自己","download","资料","将","精神","问题","\"","键盘","8","自行","检验","list","还","dpkg","是","华丽","这","最为","第二句","这个","一些","动手","应该","lts","二句","紧随","验证","一套","真理","不","通讯","成为","年","对","服务器","humble","运动","vmware","依赖","来","指标","呢","37844","他","适合","维护","需要","浏览器","其后","唯一标准","概念","发布","locale","每年","upgrade","表示","还是","讲解","浏览","signed","务器","failed","绝对","sudo","互联","叫","点击","重新","编辑","turtlesim","大学生","gen","个人","常用","说干就干","或者","$","各个","环境","只","以下","基本","下来","我们","源代码","添加","六个月","好者","但","等等","依然","无论是","月","本相","一定","应用程序","熟悉","就","无论","者","六个","传输","d","为例","擦掌","release","=","商业","从","虚拟机","中将","成熟","gpg","一样","一石激起千层浪","场景","设置","这套","发扬","先","echo","叫做","如何","cpp","好","于","加上","第一个","运行","一应","前先要","方法","热情","人工智能","让","04","探索","海龟"],"title":"ROS2安装方法","title_tokens":["安装","方法","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ros2","text":"本节，我们一起安装ROS2，安装前先要了解一下ROS2底层最重要的一种操作系统——Linux。","text_tokens":["安装","一种","linux","系统","一下","一起","—","先要","节","的","。","重要","我们","操作系统","底层","ros2","操作","了解","前先要","，","本","最"],"title":"ROS2安装方法","title_tokens":["安装","方法","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#linux","text":"时间回到1991年，一位热爱计算机的芬兰大学生 林纳斯 ，在熟悉了操作系统原理和unix系统后，决定自己动手做一个，实践是检验真理的唯一标准，说干就干，他参考已有的一些通用标准，重新设计了一套操作系统内核，不仅可以实现多用户、多任务的管理，还可以兼容unix原有的应用程序。最重要的是，他把这套尚不成熟的操作系统分享到了互联网上，并用自己的名字命名了这套系统，也就是 Linux 。 原本出于个人爱好的Linux系统通过互联网快速传播，更多爱好者看到Linux之后，也激发了乐于分享的热情，就把使用过程中的问题和修复方法做了反馈。 一石激起千层浪，越来越多人加入到了Linux维护的行列当中，一个原本功能有限、bug很多的操作系统，快速强大起来， 伴随其中发扬光大的是开源精神 。 与Windows系统收费，或MacOS硬件绑定的模式不同， Linux是一套免费并且开放源代码的操作系统 ，任何人都可以使用或者提交反馈，这就吸引了大量的开发者、爱好者，甚至很多企业，现在，每年对Linux系统提交的代码量已经成为衡量一个大公司技术实力的重要指标之一。 Linux发展迅猛，已经成为了性能稳定的多用户操作系统，也是ROS2依赖的重要底层系统。虽然ROS2目前也支持Windows、MacOS，但对Linux系统的支持最好，在本教程中，我们主要讲解Linux之上的ROS2使用方法，其他系统原理也基本相同。 所以在使用ROS2之前，我们需要先安装Linux，此时会出现另外一个概念—— 发行版 。 什么叫发行版呢？准确来讲，我们提到的 Linux应该叫做操作系统内核 ，并没有可视化界面，发行版就是给这个内核加上华丽的外衣，把操作界面和各种应用软件放到一起，打包成我们安装系统的镜像。 所以一般情况下，我们常用到的Linux系统，都是各种各样的发行版，比如Ubuntu、Fedora、RedHat等等，每一个发行版都有其适用的场景，比如RedHat适合商业应用、CentOS适合服务器、Ubuntu、Fedora适合个人使用等，每一个版本的界面不太一样，但核心都是Linux，操作方法基本相同。","text_tokens":["到","开放","各样","linux","系统","任务","不仅","其他","算机","可视","千层浪","衡量","之后","一起","光大","实现","迅猛","—","支持","回到","计算机","提到","有","成","技术实力","放到","标准","centos","多人","比如","什么","。","时间","各种","学生","使用","公司","设计","绑定","多任务","下","底层","情况","反馈","激发","自己","之一","计算","ros2","操作","来讲","，"," ","精神","决定","问题","中","也","可以","开发","相同","之前","另外","ubuntu","激起","动手做","可视化","和","检验","目前","还","不太","是","技术","服务","华丽","这","上","修复","应用","开源","windows","这个","过程","乐于","一些","功能","动手","bug","应该","给","做","硬件","收费","吸引","版本","出于","一套","有限","真理","不","成为","都","年","所以","对","服务器","出现","把","尚","企业","大","依赖","大量","指标","呢","unix","操作界面","他","适合","并且","维护","唯一","需要","唯一标准","基本相同","各种各样","概念","实践","爱好","通用","其中","每年","任何","热爱","免费","开发者","镜像","原理","讲解","适用","务器","当中","多用户","互联","叫","外衣","重新","原本","并","很多","大学生","行列","甚至","稳定","代码","个人","联网","名字","常用","其","说干就干","或者","的","操作方法","应用软件","基本","分享","主要","我们","等","源代码","会","通过","越来越","发扬光大","已经","现在","内核","好者","之上","何人","但","等等","或","发展","fedora","大学","兼容","量","本","越来","用户","、","多用","程序","起来","看到","性能","本相","此时","redhat","实力","应用程序","熟悉","一位","在","就","千层","原有","模式","安装","发行版","任何人","互联网","命名","一般","不同","林纳斯","参考","发行","准确","已有","软件","就是","芬兰","爱好者","与","商业","成熟","重要","强大","macos","快速","一样","核心","一石激起千层浪","了","伴随","场景","每","操作系统","加入","？","虽然","一个","这套","管理","发扬","教程","先","界面","传播","叫做","更","提交","并用","打包","加上","后","没有","方法","热情","多","最好","最","1991","个人爱好"],"title":"Linux系统简介","title_tokens":["linux","系统","简介"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ubuntu","text":"我们后续课程使用到的Linux发行版就是 ubuntu系统 。 Ubuntu诞生于2004年10月份， 每六个月发布一个新版本 ，用户可以一直免费升级使用，我们常用的浏览器、文件编辑器、通讯软件等一应俱全。在软件开发领域，无论是互联网开发，还是人工智能开发，还是大家关注的机器人开发，Ubuntu都占据绝对重要的位置。 Ubuntu的版本变动比较快，如何选择合适自己使用的版本很重要，因为其中各种软件版本不同会直接影响我们上层应用的移植效果。在选择版本的时候，大家可以关注一下紧随其后的编号，比如Ubuntu22.04。22代表2022年，04表示2022年的4月份发布，除了04还可能会出现的是10，就是10月份发布，所以从数字编号上就可以看出各个版本发布的顺序。 但是这样依然会有很多版本，为了让更多开发者有一个稳定的系统环境，Ubuntu每隔两年的4月份会发布一个长期支持版，后缀会加LTS，保证5年之内持续维护更新，比如Ubuntu20.04 LTS，Ubuntu22.04 LTS，除此之外的版本都是普通版，只维护18个月，所以大家在选择时， 优先考虑长期支持版 。 在本教程中，我们以 Ubuntu22.04 为例进行讲解，大家也可以选择其他长期支持版本。 好了，大家一定已经摩拳擦掌想要试一试Ubuntu了，安装方法很多，如果你之前已经熟悉Linux，建议在电脑上硬盘安装Ubuntu，这样可以发挥出硬件最大的性能，如果你是第一次接触Linux，建议在已有的windows上通过虚拟机安装，未来熟悉之后再考虑硬盘安装。 这里我们主要介绍虚拟机中的安装方法，大家也可以参考课程资料或网络资料，自行考虑硬盘安装。","text_tokens":["到","后缀","ubuntu20.04","linux","系统","其他","很","顺序","10","再","领域","看出","之后","一下","但是","机器人","支持","直接","摩拳擦掌","月份","有","最大","4","长期","持续","比如","。","影响","各种","使用","软件开发","一次","如果","紧随其后","硬盘","自己","会加","数字","2004","资料","虚拟","，"," ","为了","更新","中","也","每隔","可以","开发","快","课程","ubuntu","之前","这里","自行","介绍","一直","还","是","两年","进行","一应俱全","上","应用","windows","lts","硬件","5","版本","紧随","编辑器","除此","出","保证","考虑","时","通讯","所以","都","年","未来","出现","想要","普通","第一次","诞生","接触","电脑","机器","维护","浏览器","比较","其后","发布","其中","免费","表示","版","新","还是","关注","开发者","浏览","讲解","移植","绝对","互联","编辑","22","ubuntu22.04","很多","你","后续","稳定","联网","常用","的","人工","各个","环境","效果","只","主要","我们","等","18","发挥","会","通过","六个月","之内","已经","编号","或","合适","依然","文件","无论是","本","性能","用户","、","月","一定","因为","就","在","安装","熟悉","发行版","位置","无论","这样","占据","建议","俱全","六个","互联网","以","个","不同","参考","发行","大家","软件","升级","为例","就是","擦掌","已有","网络","之外","从","虚拟机","可能","重要","试一试","除此之外","了","每","2022","一个","教程","智能","如何","更","好","选择","于","时候","除了","第一","代表","一应","让","方法","上层","人工智能","多","04","变动","优先"],"title":"Ubuntu系统简介","title_tokens":["系统","ubuntu","简介"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ubuntu_1","text":"虚拟机是一个软件，可以在已有系统之上，构建另外一个虚拟的系统，让多个操作环境同时运行。 这里我们采用的虚拟机软件叫做vmware，下载地址如下，安装步骤和其他软件相同，请大家自行下载并安装： https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html 准备工作完成后，就可以开始系统安装啦，安装步骤如下：","text_tokens":["另外","安装","：","在","www","这里","自行","和","就","系统","开始","步骤","是","其他","-","完成","com","请","如下","准备","工作","采用","并","已有","软件","大家","products","同时","的","虚拟机","。","evaluation","环境","我们","pro","一个","其他软件",".","/","叫做","vmware",":","html","之上","https","操作","虚拟","运行","后","啦","让","，","构建","多个","地址"," ","workstation","下载","可以","相同"],"title":"Ubuntu虚拟机安装","title_tokens":["安装","虚拟机","ubuntu","虚拟"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#1","text":"下载链接： https://ubuntu.com/download/desktop","text_tokens":["链接","：","https","desktop"," ","com",".","/","下载",":","download","ubuntu"],"title":"1. 下载系统镜像","title_tokens":["1","系统"," ","镜像",".","下载"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#2","text":"","text_tokens":[],"title":"2. 在虚拟机中创建系统","title_tokens":["在","创建","虚拟","系统","2"," ",".","中","虚拟机"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#3","text":"","text_tokens":[],"title":"3. 设置虚拟机硬盘大小","title_tokens":["虚拟","设置","3"," ",".","硬盘","虚拟机","大小"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#4-ubuntu","text":"","text_tokens":[],"title":"4. 设置Ubuntu镜像路径","title_tokens":["路径","设置","4"," ","镜像",".","ubuntu"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#5","text":"","text_tokens":[],"title":"5. 启动虚拟机","title_tokens":["虚拟","5"," ",".","虚拟机","启动"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#6","text":"","text_tokens":[],"title":"6. 设置用户名和密码","title_tokens":["6","和","设置","用户名"," ","用户",".","户名","密码"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#7","text":"","text_tokens":[],"title":"7. 等待系统安装","title_tokens":["安装","系统"," ","等待",".","7"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#8","text":"Ubuntu系统安装好后，大家可以先随意使用熟悉一下。","text_tokens":["安装","熟悉","一下","好后","系统","大家","，","先","随意","。","可以","ubuntu","使用"],"title":"8. 完成安装","title_tokens":["安装","完成"," ",".","8"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ros2_1","text":"接下来，我们就可以把ROS2安装到Ubuntu系统中了。安装步骤如下：","text_tokens":["就","安装","到","系统","步骤","如下","接下来","。","中","下来","了","我们","把","ros2","，","接下","：","可以","ubuntu"],"title":"ROS2系统安装","title_tokens":["安装","系统","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#1_1","text":"$ sudo apt update && sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL = en_US.UTF-8 LANG = en_US.UTF-8 $ export LANG = en_US.UTF-8","text_tokens":["export","-","lc","us","sudo","gen","=","en","&&","$","update","_","apt","utf","lang",".","all","locales","install"," ","locale","8"],"title":"1. 设置编码","title_tokens":["1","设置"," ",".","编码"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#2_1","text":"$ sudo apt update && sudo apt install curl gnupg lsb-release $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg $ echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( source /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 如遇报错“ Failed to connect to raw.githubusercontent.com ”，可参考 https://www.guyuehome.com/37844","text_tokens":["”","sources","com","deb","|","报错","apt","]","/","null","ros2","to","，"," ","\"","org","ubuntu","http","www","list","dpkg","keyring","by","guyuehome","update","_","print","share","packages","--",":","37844","[","codename","可","-","signed","failed","sudo","o","ssl","raw","tee","&&","source","$","如遇","etc","githubusercontent",".","key","curl","archive","os","https",">",")","usr","main","lsb","d","参考","release","=","ros","architecture","gpg","connect","master","rosdistro","echo","arch","install","gnupg","“","keyrings","(","dev"],"title":"2. 添加源","title_tokens":["源","2","添加"," ","."]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#3-ros2","text":"$ sudo apt update $ sudo apt upgrade $ sudo apt install ros-humble-desktop","text_tokens":["install","upgrade","apt","-","desktop","ros"," ","humble","$","sudo","update"],"title":"3. 安装ROS2","title_tokens":["安装","3"," ",".","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#4","text":"$ source /opt/ros/humble/setup.bash $ echo \" source /opt/ros/humble/setup.bash\" >> ~/.bashrc 至此，ROS2就已经在系统中安装好了。","text_tokens":["就","安装","在","系统","至此","ros","source","$","opt","~","。","了","bashrc","humble",".","echo","setup","/","已经","ros2","bash","好",">","，"," ","\"","中"],"title":"4. 设置环境变量","title_tokens":["设置","变量","4"," ",".","环境变","环境变量","环境"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#ros2_2","text":"为了验证ROS2安装成功，我们可以通过以下示例进行测试。","text_tokens":["安装","以下","我们","，","可以","进行","验证","为了","通过","测试","示例","。","成功","ros2"],"title":"ROS2示例测试","title_tokens":["测试","示例","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#_1","text":"先来试试ROS2最为重要的底层通信系统DDS是否正常吧。 启动第一个终端，通过以下命令启动一个数据的发布者节点： $ ros2 run demo_nodes_cpp talker 启动第二个终端，通过以下命令启动一个数据的订阅者节点： $ ros2 run demo_nodes_py listener 如果“Hello World”字符串在两个终端中正常传输，说明通信系统没有问题。","text_tokens":["”","hello","在","系统","者","传输","最为","dds","是否","正常","run","py","试试","$","的","。","终端","demo","重要","字符","中","以下","发布者","_","第二个","两个","二个","如果","吧","一个","数据","talker","listener","底层","通过","先","启动","通信","节点","cpp","来","ros2","nodes","订阅","字符串","说明","第一","第一个","“","没有","，","第二"," ","world","问题","命令","：","发布"],"title":"示例一：命令行示例","title_tokens":["命令行","示例","一","：","命令"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.3_ROS2%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/#_2","text":"再来试一试ROS中的经典示例——小海龟仿真器。 启动两个终端，分别运行如下指令： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key 第一句指令将启动一个蓝色背景的海龟仿真器，第二句指令将启动一个键盘控制节点，在该终端中点击键盘上的“上下左右”按键，就可以控制小海龟运动啦。 关于小海龟中蕴藏的ROS奥义，我们在后续教程中将持续探索。 至此，ROS2安装成功。","text_tokens":["：","小海龟","”","仿真器","turtle","在","就","安装","仿真","再","蕴藏","键盘","示例","上下","上","如下","第二句","小海","海龟","点击","成功","—","一句","分别","turtlesim","背景","后续","至此","二句","ros","持续","第一句","run","左右","$","该","的","。","终端","中将","试一试","两个","_","node","按键","关于","我们","一个","教程","key","控制","运动","启动","指令","节点","奥义","来","ros2","将","经典","上下左右","第一","“","啦","运行","蓝色","，","第二"," ","探索","中","真器","可以","teleop"],"title":"示例二：小海龟仿真示例","title_tokens":["小海龟","仿真","二","示例","：","小海","海龟"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/","text":"ROS2命令行操作 在之前运行小海龟案例的时候，我们接触到了ROS2中一种重要的调试工具—— 命令行 ，大家如果第一次使用，可能会有点不太适应，本节将带领大家进一步使用ROS2中的更多命令，随着学习的深入，大家一定可以感受到命令行的魅力。 Linux中的命令行 类似于科幻电影中的片段，命令行操作异常炫酷，但是其上手并不容易。为什么这样一种操作看似并不便捷的方式会被一直保留至今呢？无论对于Linux还是ROS来讲，都是必不可少的，大家先来想象一种场景。 比如我们去商场买衣服，商场里边的衣服虽然多，但并不是每次都可以满足我们的需求，总有一些时候我们逛来逛去就是哪一件都没有看中，此时你看到某一个商家推出服装定制服务，可以根据现有的所有款式，结合我们自己的需求，自主定制，虽然操作起来麻烦一点，但是灵活度高呀，你想要什么样的就可以设计成什么样的，完全不受既定规则的约束。 在这种场景中，其他商家为我们呈现出已经做好的衣服，就类似于可视化软件一样，都是被精心设计的，但是并不一定能够完全解决我们的问题，这里定制服务中的各种布料、工具等就类似命令行，我们可以使用这些材料和工具灵活定制各种功能，约束就小很多了。 启动方式 回到命令行来，一系列的命令都是通过字符的方式输入的，怎么输入呢，并不是使用写字本，而是使用专门的软件，叫做 Terminal，终端 。 启动终端的方式有很多种： 在应用列表中打开 快捷键Ctrl+Alt+T打开 鼠标右键选择打开终端 打开后这个深色背景的窗口就是终端，因为都是命令的输入，所以我们很少会用到鼠标，这也是为什么科幻电影中看到的黑客，笔记本电脑随身带，但是从来看不到鼠标的原因。 初次上手，大家一定会觉得命令行既枯燥，又难以记忆，这很正常，随着我们对这项工具的熟悉，大家一定可以慢慢体会到命令行操作的魅力所在。 至于命令行指令及功能参数的数量，确实多到令人发指，不过不用死机硬背，我们常用的命令也就一二十个，其他命令在需要用的时候搜索一下即可。 常用命令操作 我们先来体验一下Linux的常用命令，找找感觉。 cd 语法：cd <目录路径> 功能：改变工作目录。若没有指定“目录路径”，则回到用户的主目录 pwd 语法：pwd 功能：此命令显示出当前工作目录的绝对路径 mkdir 语法：mkdir [选项] <目录名称> 功能：创建一个目录/文件夹 ls 语法：ls [选项] [目录名称…] 功能：列出目录/文件夹中的文件列表 gedit 语法：gedit <文件名称> 功能：打开gedit编辑器编辑文件，若没有此文件则会新建 mv 语法：mv [选项] <源文件或目录> <目地文件或目录> 功能：为文件或目录改名或将文件由一个目录移入另一个目录中 cp 语法：cp [选项] <源文件名称或目录名称> <目的文件名称或目录名称> 功能：把一个文件或目录拷贝到另一文件或目录中，或者把多个源文件复制到目标目录中 rm 语法：rm [选项] <文件名称或目录名称…> 功能：该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变 sudo 语法：sudo [选项] [指令] 功能：以系统管理员权限来执行指令 这些命令大家不需要死记硬背，未来一边用一边查，用的多了，就会熟悉。 ROS2中的命令行 ROS2命令行的操作机制与Linux相同，不过所有操作都集成在一个ros2的总命令中，后边第一个参数表示不同的操作目的，比如node表示对节点的操作，topic表示对话题的操作，具体操作干什么，还可以在后边继续跟一系列参数内容。 接下来我们就以小海龟仿真为例，一起感受下ROS2命令行的主要功能，也对ROS2中的核心概念有一个大致了解。 运行节点程序 想要运行ROS2中某个节点，我们可以使用ros2 run命令进行操作，例如我们要运行海龟仿真节点和键盘控制节点： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key 查看节点信息 当前运行的ROS系统中都有哪些节点呢？可以这样来查看： $ ros2 node list 如果对某一个节点感兴趣，加上一个info子命令，就可以知道它的详细信息啦： $ ros2 node info /turtlesim 查看话题信息 当前系统中都有话题呢，使用如下命令即可查看： $ ros2 topic list 还想看到某一个话题中的消息数据，加上echo子命令试一试： $ ros2 topic echo /turtle1/pose 发布话题消息 想要控制海龟动起来，我们还可以直接通过命令行发布话题指令： $ ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 发送服务请求 一只海龟太孤单，仿真器还提供改了一个服务——产生海龟，我们试一试服务调用，再来一只海龟： $ ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: ''}\" 发送动作目标 想要让海龟完成一个具体动作，比如转到指定角度，仿真器中提供的这个action可以帮上忙，通过命令行这样发送动作目标： $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"theta: 3\" 录制控制命令 系统运行中的数据有很多，如果想要把某段数据录制下来，回到实验室再复现这段数据如何？ROS2中的rosbag功能还是很好用的，轻松实现数据的录制与播放： $ ros2 bag record /turtle1/cmd_vel $ ros2 bag play rosbag2_2022_04_11-17_35_40/rosbag2_2022_04_11-17_35_40_0.db3 以上就是ROS2中我们常用的命令啦，每一个命令的子命令还有很多，大家可以自己尝试看看。","text_tokens":["”","拷贝到","到","常用命令","<","其他","精心","gedit","rotate","一起","但是","消息","srv","—","有","其上","一二","统管","比如","笔记本电脑","源文件","设计","]","兴趣","/","不变","忙","了解","小","当前工作","死记硬背","太","，"," ","命令","topic","黑客","可以","要","这些","这里","一直","进行","十个","terminal","受","当前","出","请求","显示","改了","均","精心设计","一边","rate","都","z","进一步","未来","主目录","此","ls","--","度高","第一次","不过","record","命令行","接触","能够","msgs","小海龟","一种","鼠标","现有","仿真","快捷","背景","详细","大致","该","的","方式","数量","主要","一只","等","由","会","移入","t","容易","执行","或","语法","本","用户","接下","此时","体验","可视","专门","原有","体会","1","不一","2.0","感觉","目","不同","动","rm","就是","商家","灵活","调用","与","根据","想","每","？","查看","一个","二十","管理","异常","指令","调试","指定","发指","多到","“","后","解决","+","spawn","再","参数","name","正常","播放","。","各种","路径","类似","node","一次","需求","学习","3","复制","启动","链接","后边","操作","来讲","啦","多个","cd","也","真器","之前","turtle","x","和","记忆","不太","魅力","服务","逛来","现出","二十个","上","工作","功能","逛去","呈现出","麻烦","随身带","每次","服装","终端","搜索","具体操作","_","}","40","控制","另",":","想要","cp","右键","带领","名称","电脑","角度","[","款式","cmd","并不一定","感兴","文件名称","定制","初次","文件名","一系列","1.8","twist","-","turtle1","一系","并","接下来","本节","angular","geometry","话题","完全","想象","知道","继续","通过",".","已经","令人发指","send","mkdir",">","信息","文件","满足","死机","看到","轻松","teleop","因为","权限","在","手",",","仿真器","改名","alt","系列","改变","结合","如下","段","慢慢","随身","ros","案例","体操","管理员","及其","看看","可能","…","孤单","随着","absolute","虽然","2022","不用","子","更","节点","及","时候","既","只是","没有","不是","逛来逛去","用到","linux","怎么","系统","多种","action","一下","call","play","创建","回到","目录","用","run","很少","子目录","一点","产生","复制到","为","硬","下","系统管理员","ros2","这种","这项","衣服","中","：","保持","相同","必不可少","所有","可视化","总","跟","若","一二十个","应用","去","编辑器","字符","令人","所以","某","数据","还有","把","具体","35","片段","深入","新建","提供","一二十","列出","vel","炫酷","自主","确实","0","不可","死记","很多","你","而是","linear","2","呀","呈现","删除","被","它","service","便捷","key","y","目的","mv","复现","找","、","程序","起来","查","实验室","做好","写字","这样","完成","以","小海","pub","有点","觉得","msg","大家","软件","db3","rosbag2","转","例如","重要","试一试","核心","pwd","了","帮上","深色","什么样","一","选择","笔记","难以","第一","多","列表","文件夹","bag","很","件夹","科幻","pose","发送","实现","某段","直接","约束","成","哪些","适应","什么","info","使用","一步","11","如果","窗口","内容","自己","看中","将","打开","背","详细信息","哪","快捷键","所在","看不到","问题","\"","17","{","键盘","ctrl","list","还","是","rotateabsolute","感受","这","推出","对于","买","这个","看似","一些","枯燥","目标","里边","一件","集成","机制","干什么","从来","不","尝试","对","总有","以上","theta","0.2","来","呢","需要","概念","发布","工具","感兴趣","0.0","表示","还是","rosbag","绝对","sudo","某个","goal","编辑","规则","输入","turtlesim","常用","实验","或者","电影","$","选项","下来","材料","我们","'","为什么","则","即可","录制","但","至今","一定","就","熟悉","原因","绝对路径","无论","保留","拷贝","为例","子目","又","动作","一样","场景","标目","至于","既定","笔记本","先","echo","科幻电影","叫做","如何","布料","好","于","商场","加上","第一个","运行","让","地","不到","04","目标目录","海龟"],"title":"ROS2命令行操作","title_tokens":["命令","操作","命令行","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#ros2","text":"在之前运行小海龟案例的时候，我们接触到了ROS2中一种重要的调试工具—— 命令行 ，大家如果第一次使用，可能会有点不太适应，本节将带领大家进一步使用ROS2中的更多命令，随着学习的深入，大家一定可以感受到命令行的魅力。","text_tokens":["之前","小海龟","一种","在","到","工具","不太","魅力","感受","小海","海龟","有点","—","大家","本节","案例","适应","的","。","可能","重要","使用","一步","了","一次","随着","我们","如果","进一步","学习","会","一定","更","第一次","调试","ros2","时候","将","第一","命令行","接触","运行","带领","，","深入","多"," ","命令","中","可以"],"title":"ROS2命令行操作","title_tokens":["命令","操作","命令行","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#linux","text":"类似于科幻电影中的片段，命令行操作异常炫酷，但是其上手并不容易。为什么这样一种操作看似并不便捷的方式会被一直保留至今呢？无论对于Linux还是ROS来讲，都是必不可少的，大家先来想象一种场景。 比如我们去商场买衣服，商场里边的衣服虽然多，但并不是每次都可以满足我们的需求，总有一些时候我们逛来逛去就是哪一件都没有看中，此时你看到某一个商家推出服装定制服务，可以根据现有的所有款式，结合我们自己的需求，自主定制，虽然操作起来麻烦一点，但是灵活度高呀，你想要什么样的就可以设计成什么样的，完全不受既定规则的约束。 在这种场景中，其他商家为我们呈现出已经做好的衣服，就类似于可视化软件一样，都是被精心设计的，但是并不一定能够完全解决我们的问题，这里定制服务中的各种布料、工具等就类似命令行，我们可以使用这些材料和工具灵活定制各种功能，约束就小很多了。","text_tokens":["linux","其他","科幻","精心","但是","约束","成","其上","比如","什么","。","各种","使用","一点","类似","设计","需求","为","自己","看中","操作","这种","小","哪","来讲","，","衣服"," ","问题","命令","中","可以","必不可少","所有","这些","可视化","这里","和","一直","是","服务","逛来","推出","现出","对于","买","功能","看似","一些","逛去","呈现出","麻烦","受","里边","去","一件","每次","服装","精心设计","不","都","某","总有","度高","想要","来","呢","命令行","片段","能够","款式","并不一定","炫酷","定制","自主","一种","工具","现有","还是","不可","并","规则","很多","你","呀","呈现","电影","的","方式","完全","想象","材料","被","我们","等","便捷","为什么","会","已经","容易","但","至今","满足","、","起来","此时","看到","一定","可视","就","手","在","做好","无论","这样","保留","不一","结合","大家","软件","就是","商家","灵活","ros","根据","一样","场景","了","？","虽然","一个","异常","什么样","既定","先","科幻电影","布料","于","商场","时候","没有","解决","多","不是","逛来逛去"],"title":"Linux中的命令行","title_tokens":["命令行","linux","命令","中","的"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_1","text":"回到命令行来，一系列的命令都是通过字符的方式输入的，怎么输入呢，并不是使用写字本，而是使用专门的软件，叫做 Terminal，终端 。 启动终端的方式有很多种： 在应用列表中打开 快捷键Ctrl+Alt+T打开 鼠标右键选择打开终端 打开后这个深色背景的窗口就是终端，因为都是命令的输入，所以我们很少会用到鼠标，这也是为什么科幻电影中看到的黑客，笔记本电脑随身带，但是从来看不到鼠标的原因。 初次上手，大家一定会觉得命令行既枯燥，又难以记忆，这很正常，随着我们对这项工具的熟悉，大家一定可以慢慢体会到命令行操作的魅力所在。 至于命令行指令及功能参数的数量，确实多到令人发指，不过不用死机硬背，我们常用的命令也就一二十个，其他命令在需要用的时候搜索一下即可。","text_tokens":["列表","+","到","怎么","其他","很","科幻","多种","一下","参数","但是","回到","有","正常","一二","用","很少","什么","。","笔记本电脑","使用","窗口","硬","启动","打开","操作","背","快捷键","所在","这项","，"," ","看不到","命令","中","黑客","：","也","可以","ctrl","记忆","是","魅力","这","十个","terminal","上","二十个","一二十个","应用","这个","功能","枯燥","随身带","从来","字符","终端","令人","搜索","所以","都","对","不过","来","呢","右键","命令行","电脑","需要","一二十","初次","一系列","工具","鼠标","确实","一系","快捷","并","输入","而是","背景","常用","电影","的","方式","数量","我们","为什么","会","通过","t","即可","令人发指","本","死机","一定","看到","因为","熟悉","在","手","专门","就","原因","体会","写字","alt","系列","觉得","大家","软件","慢慢","就是","随身","又","随着","至于","深色","二十","不用","笔记本","叫做","科幻电影","指令","及","选择","笔记","既","难以","时候","发指","多到","后","不到","不是","用到"],"title":"启动方式","title_tokens":["启动","方式"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_2","text":"我们先来体验一下Linux的常用命令，找找感觉。 cd 语法：cd <目录路径> 功能：改变工作目录。若没有指定“目录路径”，则回到用户的主目录 pwd 语法：pwd 功能：此命令显示出当前工作目录的绝对路径 mkdir 语法：mkdir [选项] <目录名称> 功能：创建一个目录/文件夹 ls 语法：ls [选项] [目录名称…] 功能：列出目录/文件夹中的文件列表 gedit 语法：gedit <文件名称> 功能：打开gedit编辑器编辑文件，若没有此文件则会新建 mv 语法：mv [选项] <源文件或目录> <目地文件或目录> 功能：为文件或目录改名或将文件由一个目录移入另一个目录中 cp 语法：cp [选项] <源文件名称或目录名称> <目的文件名称或目录名称> 功能：把一个文件或目录拷贝到另一文件或目录中，或者把多个源文件复制到目标目录中 rm 语法：rm [选项] <文件名称或目录名称…> 功能：该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变 sudo 语法：sudo [选项] [指令] 功能：以系统管理员权限来执行指令 这些命令大家不需要死记硬背，未来一边用一边查，用的多了，就会熟悉。","text_tokens":["列表","”","拷贝到","linux","常用命令","文件夹","系统","<","件夹","gedit","一下","创建","回到","目录","统管","用","。","子目录","路径","源文件","复制到","]","为","下","系统管理员","/","不变","复制","将","链接","打开","当前工作","死记硬背","，","多个"," ","命令","cd","中","：","也","可以","保持","所有","这些","若","对于","工作","功能","目标","当前","出","编辑器","显示","均","不","一边","未来","主目录","此","ls","另","把","cp","来","名称","[","新建","需要","列出","文件名称","文件名","绝对","sudo","某个","编辑","死记","常用","或者","该","的","选项","删除","它","我们","由","会","移入","则","mkdir","执行","或",">","目的","语法","文件","找","mv","用户","查","体验","就","权限","熟悉","原有","绝对路径","改名","改变","拷贝","以","感觉","目","rm","大家","子目","管理员","及其","…","pwd","了","标目","一个","管理","先","一","指令","及","指定","只是","“","没有","地","多","目标目录"],"title":"常用命令操作","title_tokens":["常用","常用命令","操作","命令"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#ros2_1","text":"ROS2命令行的操作机制与Linux相同，不过所有操作都集成在一个ros2的总命令中，后边第一个参数表示不同的操作目的，比如node表示对节点的操作，topic表示对话题的操作，具体操作干什么，还可以在后边继续跟一系列参数内容。 接下来我们就以小海龟仿真为例，一起感受下ROS2命令行的主要功能，也对ROS2中的核心概念有一个大致了解。","text_tokens":["一系列","就","所有","在","小海龟","linux","还","表示","总","跟","仿真","系列","感受","一系","概念","以","参数","小海","海龟","一起","不同","功能","接下来","有","为例","与","体操","话题","大致","集成","机制","的","比如","什么","干什么","。","具体操作","核心","下来","都","node","主要","我们","对","一个","内容","下","继续","具体","节点","不过","ros2","topic","后边","操作","了解","第一","命令行","第一个","，","目的"," ","接下","命令","中","也","可以","相同"],"title":"ROS2中的命令行","title_tokens":["命令行","命令","中","的","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_3","text":"想要运行ROS2中某个节点，我们可以使用ros2 run命令进行操作，例如我们要运行海龟仿真节点和键盘控制节点： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key","text_tokens":["：","turtle","和","仿真","进行","某个","海龟","turtlesim","run","$","例如","使用","_","node","我们","key","控制","节点","想要","ros2","操作","运行","，","要"," ","命令","中","键盘","可以","teleop"],"title":"运行节点程序","title_tokens":["运行","节点","程序"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_4","text":"当前运行的ROS系统中都有哪些节点呢？可以这样来查看： $ ros2 node list 如果对某一个节点感兴趣，加上一个info子命令，就可以知道它的详细信息啦： $ ros2 node info /turtlesim","text_tokens":["就","感兴趣","list","系统","这样","turtlesim","有","ros","详细","当前","哪些","$","的","info","中","都","node","它","知道","？","查看","如果","对","某","一个","兴趣","子","/","节点","来","ros2","加上","呢","详细信息","啦","运行","，","信息"," ","感兴","命令","：","可以"],"title":"查看节点信息","title_tokens":["查看","节点","信息"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_5","text":"当前系统中都有话题呢，使用如下命令即可查看： $ ros2 topic list 还想看到某一个话题中的消息数据，加上echo子命令试一试： $ ros2 topic echo /turtle1/pose","text_tokens":["list","系统","还","turtle1","如下","消息","pose","有","当前","话题","$","看到","的","想","使用","试一试","中","都","查看","某","一个","数据","子","即可","echo","/","ros2","topic","加上","呢","，"," ","命令","："],"title":"查看话题信息","title_tokens":["查看","话题","信息"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_6","text":"想要控制海龟动起来，我们还可以直接通过命令行发布话题指令： $ ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\"","text_tokens":["1.8","起来","x",",","0.0","1","twist","还","turtle1","2.0","pub","海龟","动","直接","msg","linear","angular","geometry","话题","$","z","rate","_","}","我们","{","通过","--","控制","/",":","指令","想要","ros2","topic","y","命令行","，"," ","cmd","vel","msgs","\"","命令","：","可以","发布"],"title":"发布话题消息","title_tokens":["消息","话题","发布"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_7","text":"一只海龟太孤单，仿真器还提供改了一个服务——产生海龟，我们试一试服务调用，再来一只海龟： $ ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: ''}\"","text_tokens":["：","仿真器","x",",","还","仿真","服务","再","call","srv","—","name","turtlesim","2","调用","改了","$","试一试","孤单","产生","}","一只","我们","service","一个","'","theta","/",":","0.2","来","ros2","y","太","，","提供"," ","\"","{","海龟","真器","spawn"],"title":"发送服务请求","title_tokens":["服务","请求","发送"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_8","text":"想要让海龟完成一个具体动作，比如转到指定角度，仿真器中提供的这个action可以帮上忙，通过命令行这样发送动作目标： $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"theta: 3\"","text_tokens":["：","仿真器","到","仿真","这样","turtle1","完成","rotateabsolute","rotate","action","海龟","发送","goal","这个","turtlesim","目标","$","转","的","比如","动作","_","帮上","absolute","一个","3","通过","theta","/",":","具体","想要","send","ros2","忙","指定","命令行","角度","让","，","提供"," ","\"","命令","中","真器","可以"],"title":"发送动作目标","title_tokens":["目标","动作","发送"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.4_ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/#_9","text":"系统运行中的数据有很多，如果想要把某段数据录制下来，回到实验室再复现这段数据如何？ROS2中的rosbag功能还是很好用的，轻松实现数据的录制与播放： $ ros2 bag record /turtle1/cmd_vel $ ros2 bag play rosbag2_2022_04_11-17_35_40/rosbag2_2022_04_11-17_35_40_0.db3 以上就是ROS2中我们常用的命令啦，每一个命令的子命令还有很多，大家可以自己尝试看看。","text_tokens":["实验室","：","系统","bag","-","turtle1","很","还是","再","rosbag","这","0","段","实现","play","功能","很多","某段","回到","有","大家","db3","rosbag2","就是","常用","可以","播放","实验","用","与","$","看看","的","。","11","下来","_","每","我们","如果","？","尝试","2022","数据","一个","以上","还有","子","40",".","录制","/","如何","把","想要","record","自己","ros2","好","35","啦","运行","，","复现"," ","cmd","vel","04","17","命令","中","轻松"],"title":"录制控制命令","title_tokens":["录制","命令","控制"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","text":"ROS2开发环境配置 ROS机器人开发肯定离不开代码编写，我们课程中会给大家提供大量示例源码，这些代码如何查看、编写、编译呢？我们需要先做一些准备，完成开发环境的配置，给大家推荐两款重要的开发工具——vscode和git。 Git git是一个 版本管理软件 ，也是因Linux而生。 Linux发展迅速，成千上万人都会贡献代码，这些代码有些是修复bug的，有些是贡献新硬件驱动的，有些是增加系统新特性的，几千万行的代码人工一行一行审核合并肯定是不可能的，这就需要有一款软件，可以高效管理所有提交的代码，让开发者看到每次提交变更的代码具体是哪里，自动判断会不会有已有代码冲突，以及在多个不同版本之间切换等等功能，所以Linux之父Linus就设计并开发了这款版本管理工具——git，之后也被广泛应用，比如我们常听到的开源项目网站Github，和国内的码云Gitee，都在使用git工具进行众多开源项目的内容管理。 Linux中安装git的方法非常简单，大家直接在终端中使用这一行命令就可以完成安装。 $ sudo apt install git 下载教程源码 《ROS2入门21讲》课程源码的下载方式： $ git clone https://gitee.com/guyuehome/ros2_21_tutorials.git 下载好的课程代码是这样的，里边有很多文件夹，文件夹中还会有更多文件夹和代码文件，如果用系统自带的文件浏览器和记事本查看，就略显复杂，这里推荐另外一个集成开发环境——VSCode。 VSCode Visual Studio Code，简称VSCode，是微软在2015年推出的一个轻量但功能强大的源代码编辑器，支持 Windows、Linux和 macOS操作系统，扩展组件非常丰富，可以快速搭建成为项目开发的神兵利器。 官方网站： https://code.visualstudio.com/ 下载链接： https://code.visualstudio.com/Download VSCode插件配置 为了便于后续ROS2的开发与调试，我们还可以安装一系列插件，无限扩展VSCode的功能。 中文语言包 Python插件 C++插件 CMake插件 vscode-icons ROS插件 Msg Language Support Visual Studio IntelliCode URDF Markdown All in One VSCode支持的插件众多，以上只作为个人推荐，大家也可以在网上搜索，配置出自己最喜欢的开发环境。","text_tokens":["人","linux","系统","文件夹","利器","源码","件夹","自带","com","插件","cmake","示例","组件","之后","离不开","机器人","—","支持","直接","有","urdf","用","迅速","比如","。","两款","使用","python","丰富","git","设计","apt","如果","2015","内容","之父","上万","简单","all","/","搭建","自己","download","ros2","简称","链接","操作","one","，","广泛应用","code","in","多个"," ","哪里","为了","language","命令","之间","也","中","驱动","vscode","开发","可以","课程","下载","：","这些","所有","入门","这里","另外","和","icons","官方网站","官方","还","是","进行","略显","这","推出","常听到","配置","修复","应用","开源","windows","神兵","功能","bug","给","一些","做","硬件","guyuehome","无限","里边","版本","编辑器","出","成千上万","集成","每次","轻量","终端","中文","studio","搜索","不","所以","都","贡献","_","年","成为","以上","以及","复杂","编写","微软",":","具体","clone","官方网","不会","大量","呢","机器","tutorials","扩展","需要","提供","浏览器","千上万","一系列","工具","广泛","增加","切换","-","新","开发者","浏览","非常","一系","visual","sudo","语言","21","编辑","语言包","并","很多","后续","代码","一行","推荐","个人","网站","行","几千","合并","而生","非常简单","的","人工","$","编译","方式","环境","便于","markdown","高效","变更","只","不开","被","intellicode","我们","成千","github","记事本","会","源代码",".","https","但","等等","发展","审核","文件","记事","、","几千万","下载方式","support","因","看到","千万","就","开发工具","在","码云","安装","国内","这样","完成","visualstudio","系列","准备","一款","不同","《","msg","大家","软件","已有","有些","ros","项目","与","判断","讲","理工","冲突","可能","强大","重要","喜欢","macos","肯定","特性","管理软件","快速","了","管理工具","功能强大","网上","操作系统","？","查看","gitee","一个","教程","管理","》","听到","先","这款","如何","更","c++","提交","好","调试","众多","install","linus","作为","让","方法","自动","中会","多","最"],"title":"ROS2开发环境配置","title_tokens":["配置","环境","开发","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#ros2","text":"ROS机器人开发肯定离不开代码编写，我们课程中会给大家提供大量示例源码，这些代码如何查看、编写、编译呢？我们需要先做一些准备，完成开发环境的配置，给大家推荐两款重要的开发工具——vscode和git。","text_tokens":["课程","工具","这些","开发工具","和","源码","完成","示例","准备","配置","离不开","机器人","—","给","一些","大家","代码","做","推荐","ros","的","。","编译","重要","环境","两款","肯定","git","不开","我们","？","查看","编写","先","如何","大量","呢","机器","，","需要","中会","提供","、","vscode","开发"],"title":"ROS2开发环境配置","title_tokens":["配置","环境","开发","ros2"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#git","text":"git是一个 版本管理软件 ，也是因Linux而生。 Linux发展迅速，成千上万人都会贡献代码，这些代码有些是修复bug的，有些是贡献新硬件驱动的，有些是增加系统新特性的，几千万行的代码人工一行一行审核合并肯定是不可能的，这就需要有一款软件，可以高效管理所有提交的代码，让开发者看到每次提交变更的代码具体是哪里，自动判断会不会有已有代码冲突，以及在多个不同版本之间切换等等功能，所以Linux之父Linus就设计并开发了这款版本管理工具——git，之后也被广泛应用，比如我们常听到的开源项目网站Github，和国内的码云Gitee，都在使用git工具进行众多开源项目的内容管理。 Linux中安装git的方法非常简单，大家直接在终端中使用这一行命令就可以完成安装。 $ sudo apt install git","text_tokens":["人","linux","系统","之后","—","直接","有","迅速","比如","。","使用","git","设计","apt","内容","之父","上万","简单","，","广泛应用","多个"," ","哪里","命令","之间","也","中","可以","驱动","开发","这些","所有","和","是","进行","这","常听到","修复","应用","开源","功能","bug","硬件","版本","成千上万","每次","终端","不","所以","都","贡献","以及","具体","不会","需要","千上万","工具","广泛","增加","切换","新","开发者","非常","sudo","并","代码","一行","网站","行","几千","合并","而生","非常简单","的","人工","$","高效","变更","被","我们","成千","github","会","等等","发展","审核","几千万","看到","因","千万","就","码云","在","安装","国内","完成","一款","不同","已有","软件","大家","有些","项目","判断","理工","冲突","可能","肯定","特性","管理软件","了","管理工具","gitee","一个","管理","听到","这款","提交","众多","install","linus","让","方法","自动"],"title":"Git","title_tokens":["git"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#_1","text":"《ROS2入门21讲》课程源码的下载方式： $ git clone https://gitee.com/guyuehome/ros2_21_tutorials.git 下载好的课程代码是这样的，里边有很多文件夹，文件夹中还会有更多文件夹和代码文件，如果用系统自带的文件浏览器和记事本查看，就略显复杂，这里推荐另外一个集成开发环境——VSCode。","text_tokens":["课程","另外","就","入门","这里","和","系统","文件夹","还","是","源码","这样","件夹","自带","com","浏览","略显","21","—","《","很多","有","代码","guyuehome","推荐","下载","里边","用","$","讲","的","集成","方式","。","环境","中","git","_","如果","查看","gitee","一个","》","记事本","会","复杂",".","/",":","clone","更","ros2","好","https","，","tutorials","文件","多"," ","下载方式","浏览器","记事","：","vscode","开发"],"title":"下载教程源码","title_tokens":["下载","源码","教程"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#vscode","text":"Visual Studio Code，简称VSCode，是微软在2015年推出的一个轻量但功能强大的源代码编辑器，支持 Windows、Linux和 macOS操作系统，扩展组件非常丰富，可以快速搭建成为项目开发的神兵利器。 官方网站： https://code.visualstudio.com/ 下载链接： https://code.visualstudio.com/Download","text_tokens":["在","linux","和","系统","利器","官方网站","是","visualstudio","com","非常","推出","visual","组件","编辑","windows","神兵","支持","功能","代码","可以","项目","网站","下载","编辑器","的","轻量","。","强大","studio","macos","快速","丰富","成为","功能强大","年","操作系统","2015","一个","源代码",".","微软","/","搭建",":","download","官方网","简称","链接","https","操作","但","，","扩展","code"," ","、","：","官方","vscode","开发"],"title":"VSCode","title_tokens":["vscode"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#vscode_1","text":"为了便于后续ROS2的开发与调试，我们还可以安装一系列插件，无限扩展VSCode的功能。","text_tokens":["一系列","安装","还","系列","插件","一系","功能","后续","无限","与","的","。","便于","vscode","我们","调试","ros2","，","扩展","为了","可以","开发"],"title":"VSCode插件配置","title_tokens":["配置","vscode","插件"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#_2","text":"","text_tokens":[],"title":"中文语言包","title_tokens":["语言","中文","语言包"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#python","text":"","text_tokens":[],"title":"Python插件","title_tokens":["插件","python"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#c","text":"","text_tokens":[],"title":"C++插件","title_tokens":["c++","插件"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#cmake","text":"","text_tokens":[],"title":"CMake插件","title_tokens":["cmake","插件"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#vscode-icons","text":"","text_tokens":[],"title":"vscode-icons","title_tokens":["icons","vscode","-"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#ros","text":"","text_tokens":[],"title":"ROS插件","title_tokens":["ros","插件"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#msg-language-support","text":"","text_tokens":[],"title":"Msg Language Support","title_tokens":["msg"," ","support","language"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#visual-studio-intellicode","text":"","text_tokens":[],"title":"Visual Studio IntelliCode","title_tokens":["intellicode","studio"," ","visual"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#urdf","text":"","text_tokens":[],"title":"URDF","title_tokens":["urdf"]},{"location":"ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.5_ROS2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#markdown-all-in-one","text":"VSCode支持的插件众多，以上只作为个人推荐，大家也可以在网上搜索，配置出自己最喜欢的开发环境。","text_tokens":["在","插件","配置","支持","大家","个人","推荐","出","的","喜欢","。","环境","网上","搜索","只","vscode","以上","自己","众多","作为","，","最","也","可以","开发"],"title":"Markdown All in One","title_tokens":["one","in"," ","all","markdown"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/","text":"DDS Hello，大家好，欢迎来到《ROS2入门21讲》，我是主讲人古月。 终于讲到ROS2中最为重大的变化—— DDS ，我们在前边课程中学习的话题、服务、动作，他们底层通信的具体实现过程，都是靠DDS来完成的，它相当于是 ROS机器人系统中的神经网络 。 通信模型 DDS的核心是通信，能够实现通信的模型和软件框架非常多，这里我们列出常用的四种模型。 第一种， 点对点模型 ，许多客户端连接到一个服务端，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响。 第二种， Broker模型 ，针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构。 第三种， 广播模型 ，所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的。 第四种，就是 以数据为中心的DDS模型 了，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息，有点像是一个旋转火锅，各种好吃的都在这个DataBus传送，我们只需要拿自己想吃的就行，其他的和我们没有关系。 可见，在这几种通信模型中，DDS的优势更加明显。 DDS DDS并不是一个新的通信方式，在ROS2之前，DDS已经广泛应用在很多领域，比如航空，国防，交通，医疗，能源等。 比如在自动驾驶领域，通常会存在感知，预测，决策和定位等模块，这些模块都需要非常高速和频繁地交换数据。借助DDS，可以很好地满足它们的通信需求。 什么是DDS 好啦，说了半天DDS，到底啥意思呢？我们来做一个完整的介绍 DDS的全称是 Data Distribution Service ，也就是 数据分发服务 ，2004年由 对象管理组织OMG 发布和维护，是一套专门为 实时系统 设计的 数据分发/订阅标准 ，最早应用于美国海军， 解决舰船复杂网络环境中大量软件升级的兼容性问题，现在已经成为强制标准。 DDS强调 以数据为中心 ，可以提供丰富的 服务质量策略 ，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。 这里也提一下对象管理组织OMG，成立于1989年，它的使命是开发技术标准，为数以千计的垂直行业提供真实的价值，比如大家课可能听说过的统一建模语言SYSML和UML，还有中间件标准CORBA等，当然还有DDS。 DDS在ROS2中的应用 DDS在ROS2系统中的位置至关重要，所有上层建设都建立在DDS之上。在这个ROS2的架构图中，蓝色和红色部分就是DDS。 刚才我们也提到，DDS是一种通信的标准，就像4G、5G一样，既然是标准，那大家都可以按照这个标准来实现对应的功能，所以华为、高通都有很多5G的技术专利，DDS也是一样， 能够按照DDS标准实现的通信系统很多 ，这里每一个红色模块，就是某一企业或组织实现的一种DDS系统。 既然可选用的DDS这么多，那我们该用哪一个呢？具体而言，他们肯定都符合基本标准，但还是会有性能上的差别，ROS2的原则就是尽量兼容，让用户根据使用场景选择，比如个人开发，我们选择一个开源版本的DDS就行，如果是工业应用，那可能得选择一个商业授权的版本了。 为了实现对多个DDS的兼容，ROS设计了一个 Middleware中间件 ，也就是一个统一的标准，不管我们用那个DDS，保证上层编程使用的函数接口都是一样的。此时兼容性的问题就转移给了DDS厂商，如果他们想让自己的DDS系统进入ROS生态，就得按照ROS的接口标准，开发一个驱动，也就是这个部分。 无论如何，ROS的宗旨不变，要提高软件代码的复用性，下边DDS任你边，上边的软件没影响。 在ROS的四大组成部分中，由于DDS的加入，大大提高了分布式通信系统的综合能力，这样我们在开发机器人的过程中，就不需要纠结通信的问题，可以把更多时间放在其他部分的应用开发上。 质量服务策略QoS DDS为ROS的通信系统提供提供了哪些特性呢？我们通过这个通信模型图来看下。 DDS中的基本结构是 Domain ，Domain将各个应用程序绑定在一起进行通信，回忆下之前我们配置树莓派和电脑通信的时候，配置的那个DOMAIN ID，就是对全局数据空间的分组定义，只有处于同一个DOMAIN小组中的节点才能互相通信。这样可以避免无用数据占用的资源。 DDS中另外一个重要特性就是 质量服务策略，QoS 。 QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，可以理解为 数据提供者和接收者之间的合约 。 具体会有哪些策略？比如： DEADLINE 策略，表示通信数据必须要在每次截止时间内完成一次通信； HISTORY 策略，表示针对历史数据的一个缓存大小； RELIABILITY 策略，表示数据通信的模式，配置成BEST_EFFORT，就是尽力传输模式，网络情况不好的时候，也要保证数据流畅，此时可能会导致数据丢失，配置成RELIABLE，就是可信赖模式，可以在通信中尽量保证图像的完整性，我们可以根据应用功能场景选择合适的通信模式； DURABILITY 策略，可以配置针对晚加入的节点，也保证有一定的历史数据发送过去，可以让新节点快速适应系统。 所有这些策略在ROS系统中都可以通过类似这样的结构体配置，如果不配置的话，系统也会使用默认的参数。 举一个机器人的例子便于大家理解。 比如我们遥控一个无人机航拍，如果网络情况不好的话，遥控器向无人机发送运动指令的过程，可以用reliable通信模式，保证每一个命令都可以顺利发送给无人机，但是可能会有一些延时，无人机传输图像的过程可以用best effort模式，保证视频的流畅性，但是可能会有掉帧。 如果此时出现一个黑客黑入我们的网络，也没有关系，我们可以给ROS2的通信数据进行加密，黑客也没有办法直接控制无人机。 DDS的加入，让ROS2的通信系统焕然一新，多众多样的通信配置，可以更好的满足不同场景下的机器人应用。 好啦，DDS这么好，那该如何配置和使用呢？我们先带大家入个门。 案例一：在命令行中配置DDS 我们先来试一试在命令行中配置DDS的参数。 启动第一个终端，我们使用best_effort创建一个发布者节点，循环发布任意数据，在另外一个终端中，如果我们使用reliable模型订阅同一话题，无法实现数据通信，如果修改为同样的best_effort，才能实现数据传输。 $ ros2 topic pub /chatter std_msgs/msg/Int32 \"data: 42\" --qos-reliability best_effort $ ros2 topic echo /chatter --qos-reliability reliable $ ros2 topic echo /chatter --qos-reliability best_effort 如何去查看ROS2系统中每一个发布者或者订阅者的QoS策略呢，在topic命令后边跟一个\"--verbose\"参数就行了。 $ ros2 topic info /chatter --verbose 案例二：DDS编程示例 接下来，我们尝试在代码中配置DDS，以之前Hello World话题通信为例。 运行效果 启动两个终端，分别运行发布者和订阅者节点： $ ros2 run learning_qos qos_helloworld_pub $ ros2 run learning_qos qos_helloworld_sub 可以看到两个终端中的通信效果如下，和之前貌似并没有太大区别。 看效果确实差不多，不过底层通信机理上可是有所不同的。 发布者代码解析 我们看下在代码中，如果加入QoS的配置。 learning_qos/qos_helloworld_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2 QoS示例-发布“Hello World”话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 from rclpy.qos import QoSProfile , QoSReliabilityPolicy , QoSHistoryPolicy # ROS2 QoS类 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 qos_profile = QoSProfile ( # 创建一个QoS原则 # reliability=QoSReliabilityPolicy.BEST_EFFORT, reliability = QoSReliabilityPolicy . RELIABLE , history = QoSHistoryPolicy . KEEP_LAST , depth = 1 ) self . pub = self . create_publisher ( String , \"chatter\" , qos_profile ) # 创建发布者对象（消息类型、话题名、QoS原则） self . timer = self . create_timer ( 0.5 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） def timer_callback ( self ): # 创建定时器周期执行的回调函数 msg = String () # 创建一个String类型的消息对象 msg . data = 'Hello World' # 填充消息对象中的消息数据 self . pub . publish ( msg ) # 发布话题消息 self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) # 输出日志信息，提示已经完成话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = PublisherNode ( \"qos_helloworld_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'qos_helloworld_pub = learning_qos.qos_helloworld_pub:main' , }, 订阅者代码解析 订阅者中的QoS配置和发布者类似。 learning_qos/qos_helloworld_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2 QoS示例-订阅“Hello World”话题消息 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 from rclpy.qos import QoSProfile , QoSReliabilityPolicy , QoSHistoryPolicy # ROS2 QoS类 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 qos_profile = QoSProfile ( # 创建一个QoS原则 # reliability=QoSReliabilityPolicy.BEST_EFFORT, reliability = QoSReliabilityPolicy . RELIABLE , history = QoSHistoryPolicy . KEEP_LAST , depth = 1 ) self . sub = self . create_subscription ( \\ String , \"chatter\" , self . listener_callback , qos_profile ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、QoS原则） def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'I heard: \" %s \"' % msg . data ) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"qos_helloworld_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'qos_helloworld_pub = learning_qos.qos_helloworld_pub:main' , 'qos_helloworld_sub = learning_qos.qos_helloworld_sub:main' , ], }, DDS本身是一个非常复杂的系统，ROS2使用的也只是冰山一角，我们主要带领大家认识DDS，更多使用方法和相关内容，大家也可以参考下边的链接进行学习。 参考链接 https://design.ros2.org/articles/ros_on_dds.html https://docs.ros.org/en/humble/Concepts/About-Different-Middleware-Vendors.html https://docs.ros.org/en/humble/How-To-Guides/Working-with-multiple-RMW-implementations.html https://www.bilibili.com/video/BV12z4y167w2","text_tokens":["变化","”","到","coding","历史数据","填充","其他","4g","体","供者","com","传送","二","一起","callback","消息","但是","domain","—","更加","有","broker","差不多","当于","subscription","比如","而且","learning","转移","python","丰富","尽量","设计","服务质量","交换","]","全称","兴趣","情况","/","实时","策略","通信","不变","能源","setup","冰山一角","符合","太","，","第二","国防","id","资源","库"," ","为了","bv12z4y167w2","订阅","命令","黑客","接口","可以","要","topic","貌似","课程","另外","import","这些","best","冰山","这里","about","回忆","可是","spin","对应","感知","进行","publishernode","verbose","开源","过程","给","通常","处","至关重要","大大提高","回调","请求","rmw","保证","像","都","神经网络","进一步","数据通信","入口","--","点","出现","不过","omg","大量","单独","中间","命令行","int32","并且","而言","能够","5g","例子","world","办法","msgs","reliability","\\","一种","定时器","定义","非常","美国","占用","21","使命","行","只有","容性","的","某一","方式","effort","解析","舰船","主要","由","等","秒","避免","会","现在","字符串","样","或","执行","第四","忽略","几种",")","用户","接下","要求","此时","usr","性","专门","名","整个","同样","1","框架","截止","working","sysml","bilibili","旋转","不同","可见","航拍","就是","灵活","父类","与","根据","讲","timer","想","大小","角色","distribution","每","处理","？","分发","查看","一个","管理","异常","publish","分组","指令","靠","指定","“","授权","后","上层","解决","地址","遥控","docs","过去","延时","华为","qosreliabilitypolicy","data","找到","才能","how","技术标准","design","领域","更好","优势","处于","四种","参数","name","数以千计","建设","正常","建立","许多","。","各种","subscribernode","类似","node","需求","一次","学习","所有人","下边","程度","历史","启动","org","2004","链接","后边","to","四大","啦","提","来看","multiple","其实","向","掉","广泛应用","多个","主讲人","组成","一新","发生变化","视频","之间","也","get","驱动","开发","之前","；","无人机","implementations","入门","当","输出","和","介绍","的话","qos","服务","guides","广播","模型","上","qosprofile","）","分布式","功能","任意","通信模型","麻烦","guyuehome","版本","客户","主","on","每次","一条","时","驾驶","终端","有所不同","神经网","完整性","_","}","顺利","双方","控制","ros1","就行","编写",":","大","#","缓存","带领","电脑","[","机器","受到","存在","借助","感兴","放在","可","课","每个","广泛","讲到","全局","-","半天","集中处理","包含","强调","语言","瓶颈","并","入个","相当于","接下来","代码","尽力","en","神经","话题","同一","拿","两个","知道","通过","video",".","uml","增多","已经","init","可信赖","大大","关系","定时","信息","兼容","满足","分布","性能","中间件","文件","看到","不感兴趣","模式","在","机理",",","强制","建模语言","如下","像是","%","参考","晚","网络","升级","接收","刚才","有些","ros","小组","类","案例","publishing","articles","可能","快速","特性","一角","成立","生变","销毁","最早","派","》","listener","不用","第四种","class","更","keep","节点","0.5","时候","众多","只是","编程","蓝色","没有","具体地址","不是","至关","相关","发生","行业","env","系统","非常复杂","架构图","一下","chatter","机器人","创建","三种","标准","用","run","时间","由于","heard","为","下","std","差别","本身","预测","说了半天","ros2","这种","destroy","构图","互相","corba","中","第三","：","并行","所有","hello","www","黑入","技术","跟","应用","流畅","分别","高速","既然","做","它们","去","退出","对象","树莓","字符","边","函数","有所","所以","建模","航空","数据","终于","信赖","还有","空间","复杂","决策","周期","这么","发送给","焕然","具体","把","企业","关心","1989","super","提供","列出","来到","合约","__","durability","那该","焕然一新","举","确实","新","console","布式","dds","第二种","很多","你","*","工业","一旦","原则","啥意思","无用","集中","编译","scripts","便于","效果","高效","发布者","提高","它","service","专利","utf","理解","!","速度","说明","html","医疗","之上","https","合适","那","任","、","等待","程序","上边","客户端","规模","位置","main","流畅性","这样","完成","profile","导致","真正","组成部分","纠结","得","以","先进","pub","有点","带","《","所","msg","大家","软件","不多","重要","接口标准","试一试","核心","区别","架构","了","图","加入","不管","deadline","points","可信","一","意思","尽可能","服务端","选择","@","depth","第一","修改","二种","频繁","保证数据","自动","有人","相当","前边","多","价值","红色","默认","(","中心","同一个","接收者","shutdown","火锅","进入","create","过","很","s","太多","示例","初始","到底","实现","发送","提到","直接","成","py","哪些","适应","（","什么","info","影响","vendors","一步","使用","无人","reliable","绑定","如果","高通","遥控器","明显","内容","不好","底层","送给","自己","厂商","将","帧","打开","哪","综合","结构","就行了","居","python3","def","选用","\"","问题","rclpy","{","完整","databus","8","history","初始化","是","无法","当然","none","这","兼容性问题","收到","最为","配置","尽可","循环","这个","一些","应该","门","提示","i","bin","增长","一套","不","主讲","成为","交通","年","尝试","self","different","helloworld","对","服务器","提供者","日志","humble","string","运动","垂直","publisher","保障","来","呢","类型","维护","模块","需要","海军","发布","from","感兴趣","每条","表示","吃","还是","第一种","务器","last","好吃","行为","认识","复用","作者","数据通","该用","优化","个人","常用","内","或者","$","选项","之","环境","各个","只","那个","重大","基本","下来","质量","我们","关闭","'","concepts","真实","部分","没","针对","包","但","在于","单位","我","通路","一定","古月","欢迎","丢失","sub","兼容性","应用程序","就","连接","看","数据传输","无论","者","传输","entry","连接数","运转","加密","为例","看下","宗旨","=","第三种","商业","据传","42","通道","动作","效率","听说","一样","肯定","统一","场景","处理速度","设置","qoshistorypolicy","args","组织","按照","能力","先","echo","如何","生态","好","于","with","middleware","第一个","运行","作为","人机","让","方法","图像","地","点对点","能响","无论如何","定位","他们","必须","logger"],"title":"DDS","title_tokens":["dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#dds","text":"Hello，大家好，欢迎来到《ROS2入门21讲》，我是主讲人古月。 终于讲到ROS2中最为重大的变化—— DDS ，我们在前边课程中学习的话题、服务、动作，他们底层通信的具体实现过程，都是靠DDS来完成的，它相当于是 ROS机器人系统中的神经网络 。","text_tokens":["课程","来到","变化","hello","入门","在","讲到","系统","是","服务","完成","最为","21","dds","—","实现","机器人","《","过程","相当于","大家","网络","ros","神经","当于","话题","讲","的","。","动作","中","神经网","主讲","重大","都","它","我们","学习","神经网络","》","终于","底层","通信","具体","ros2","好","靠","来","，","我","机器","相当","主讲人"," ","前边","、","他们","古月","欢迎"],"title":"DDS","title_tokens":["dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#_1","text":"DDS的核心是通信，能够实现通信的模型和软件框架非常多，这里我们列出常用的四种模型。 第一种， 点对点模型 ，许多客户端连接到一个服务端，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响。 第二种， Broker模型 ，针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构。 第三种， 广播模型 ，所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的。 第四种，就是 以数据为中心的DDS模型 了，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息，有点像是一个旋转火锅，各种好吃的都在这个DataBus传送，我们只需要拿自己想吃的就行，其他的和我们没有关系。 可见，在这几种通信模型中，DDS的优势更加明显。","text_tokens":["变化","找到","发生","到","火锅","系统","其他","很","太多","传送","优势","四种","消息","实现","但是","更加","三种","正常","broker","建立","许多","而且","。","影响","各种","一步","使用","类似","如果","所有人","为","明显","兴趣","程度","自己","通信","这种","其实","，","第二"," ","问题","发生变化","订阅","中","也","第三","可以","并行","databus","之前","所有","这里","当","和","是","无法","服务","进行","这","广播","模型","上","收到","这个","通信模型","应该","麻烦","处","客户","请求","增长","每次","一条","时","成为","都","进一步","数据","服务器","双方","ros1","具体","不过","关心","单独","并且","受到","能够","需要","提供","列出","感兴","发布","一种","每个","感兴趣","每条","吃","集中处理","非常","第一种","务器","包含","好吃","dds","瓶颈","并","第二种","很多","优化","一旦","常用","行","集中","的","拿","之","只","它","我们","知道","由","会","速度","增多","针对","但","在于","关系","第四","忽略","几种","性能","通路","一定","不感兴趣","就","客户端","连接","在","规模","整个","框架","这样","导致","真正","旋转","以","先进","有点","像是","可见","所","连接数","软件","运转","就是","有些","第三种","与","通道","可能","效率","角色","想","核心","架构","了","生变","处理","处理速度","一个","不用","异常","第四种","更","节点","服务端","第一","二种","作为","没有","有人","解决","点对点","多","地址","具体地址","能响","中心","必须"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#dds_1","text":"DDS并不是一个新的通信方式，在ROS2之前，DDS已经广泛应用在很多领域，比如航空，国防，交通，医疗，能源等。 比如在自动驾驶领域，通常会存在感知，预测，决策和定位等模块，这些模块都需要非常高速和频繁地交换数据。借助DDS，可以很好地满足它们的通信需求。","text_tokens":["之前","广泛","在","这些","和","很","新","感知","领域","非常","应用","dds","并","高速","很多","通常","它们","比如","的","。","方式","驾驶","交通","都","需求","等","航空","交换","一个","数据","会","决策","已经","通信","医疗","能源","ros2","预测","好","频繁","，","广泛应用","国防","自动","存在","不是"," ","模块","需要","地","定位","借助","满足","可以"],"title":"DDS","title_tokens":["dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#dds_2","text":"好啦，说了半天DDS，到底啥意思呢？我们来做一个完整的介绍 DDS的全称是 Data Distribution Service ，也就是 数据分发服务 ，2004年由 对象管理组织OMG 发布和维护，是一套专门为 实时系统 设计的 数据分发/订阅标准 ，最早应用于美国海军， 解决舰船复杂网络环境中大量软件升级的兼容性问题，现在已经成为强制标准。 DDS强调 以数据为中心 ，可以提供丰富的 服务质量策略 ，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。 这里也提一下对象管理组织OMG，成立于1989年，它的使命是开发技术标准，为数以千计的垂直行业提供真实的价值，比如大家课可能听说过的统一建模语言SYSML和UML，还有中间件标准CORBA等，当然还有DDS。","text_tokens":["data","行业","系统","过","技术标准","到底","一下","数以千计","标准","比如","。","各种","丰富","设计","需求","服务质量","为","全称","/","实时","策略","通信","说了半天","2004","啦","提","，"," ","问题","订阅","中","也","corba","可以","完整","开发","这里","和","介绍","是","技术","服务","进行","当然","兼容性问题","应用","分布式","做","对象","一套","成为","年","建模","数据","还有","复杂","垂直","保障","来","omg","大量","呢","1989","中间","维护","提供","海军","可","发布","课","半天","美国","强调","布式","语言","dds","使命","啥意思","容性","的","环境","高效","舰船","质量","它","我们","由","service","等","uml","真实","已经","现在","兼容","满足","分布","中间件","、","兼容性","专门","强制","建模语言","sysml","以","大家","网络","软件","升级","就是","灵活","可能","听说","统一","distribution","成立","最早","？","分发","一个","管理","组织","意思","好","于","解决","地","价值","中心"],"title":"什么是DDS","title_tokens":["什么","是","dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#ddsros2","text":"DDS在ROS2系统中的位置至关重要，所有上层建设都建立在DDS之上。在这个ROS2的架构图中，蓝色和红色部分就是DDS。 刚才我们也提到，DDS是一种通信的标准，就像4G、5G一样，既然是标准，那大家都可以按照这个标准来实现对应的功能，所以华为、高通都有很多5G的技术专利，DDS也是一样， 能够按照DDS标准实现的通信系统很多 ，这里每一个红色模块，就是某一企业或组织实现的一种DDS系统。 既然可选用的DDS这么多，那我们该用哪一个呢？具体而言，他们肯定都符合基本标准，但还是会有性能上的差别，ROS2的原则就是尽量兼容，让用户根据使用场景选择，比如个人开发，我们选择一个开源版本的DDS就行，如果是工业应用，那可能得选择一个商业授权的版本了。 为了实现对多个DDS的兼容，ROS设计了一个 Middleware中间件 ，也就是一个统一的标准，不管我们用那个DDS，保证上层编程使用的函数接口都是一样的。此时兼容性的问题就转移给了DDS厂商，如果他们想让自己的DDS系统进入ROS生态，就得按照ROS的接口标准，开发一个驱动，也就是这个部分。 无论如何，ROS的宗旨不变，要提高软件代码的复用性，下边DDS任你边，上边的软件没影响。 在ROS的四大组成部分中，由于DDS的加入，大大提高了分布式通信系统的综合能力，这样我们在开发机器人的过程中，就不需要纠结通信的问题，可以把更多时间放在其他部分的应用开发上。","text_tokens":["进入","系统","其他","4g","架构图","实现","机器人","提到","建设","有","建立","标准","用","比如","。","影响","时间","转移","使用","由于","尽量","设计","如果","高通","下边","差别","自己","不变","通信","厂商","ros2","四大","哪","符合","综合","，","构图","多个"," ","选用","为了","问题","组成","中","也","接口","可以","驱动","开发","要","所有","这里","和","是","对应","技术","上","应用","分布式","开源","这个","功能","过程","给","既然","至关重要","版本","大大提高","保证","边","函数","像","不","所以","都","对","就行","这么","具体","把","企业","来","呢","中间","而言","机器","5g","能够","模块","需要","放在","可","一种","还是","他们","布式","dds","复用","很多","你","该用","代码","个人","原则","工业","容性","的","某一","那个","基本","提高","我们","专利","会","部分","之上","没","大大","但","或","那","任","兼容","中间件","分布","性能","、","用户","此时","性","兼容性","上边","就","在","位置","无论","这样","组成部分","纠结","得","大家","软件","就是","刚才","宗旨","ros","根据","商业","可能","想","重要","接口标准","一样","肯定","统一","架构","场景","了","每","加入","？","一个","不管","组织","按照","能力","如何","更","生态","选择","middleware","授权","蓝色","编程","让","上层","红色","多","无论如何","至关","华为"],"title":"DDS在ROS2中的应用","title_tokens":["在","dds","中","的","应用","ros2"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#qos","text":"DDS为ROS的通信系统提供提供了哪些特性呢？我们通过这个通信模型图来看下。 DDS中的基本结构是 Domain ，Domain将各个应用程序绑定在一起进行通信，回忆下之前我们配置树莓派和电脑通信的时候，配置的那个DOMAIN ID，就是对全局数据空间的分组定义，只有处于同一个DOMAIN小组中的节点才能互相通信。这样可以避免无用数据占用的资源。 DDS中另外一个重要特性就是 质量服务策略，QoS 。 QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，可以理解为 数据提供者和接收者之间的合约 。 具体会有哪些策略？比如： DEADLINE 策略，表示通信数据必须要在每次截止时间内完成一次通信； HISTORY 策略，表示针对历史数据的一个缓存大小； RELIABILITY 策略，表示数据通信的模式，配置成BEST_EFFORT，就是尽力传输模式，网络情况不好的时候，也要保证数据流畅，此时可能会导致数据丢失，配置成RELIABLE，就是可信赖模式，可以在通信中尽量保证图像的完整性，我们可以根据应用功能场景选择合适的通信模式； DURABILITY 策略，可以配置针对晚加入的节点，也保证有一定的历史数据发送过去，可以让新节点快速适应系统。 所有这些策略在ROS系统中都可以通过类似这样的结构体配置，如果不配置的话，系统也会使用默认的参数。 举一个机器人的例子便于大家理解。 比如我们遥控一个无人机航拍，如果网络情况不好的话，遥控器向无人机发送运动指令的过程，可以用reliable通信模式，保证每一个命令都可以顺利发送给无人机，但是可能会有一些延时，无人机传输图像的过程可以用best effort模式，保证视频的流畅性，但是可能会有掉帧。 如果此时出现一个黑客黑入我们的网络，也没有关系，我们可以给ROS2的通信数据进行加密，黑客也没有办法直接控制无人机。 DDS的加入，让ROS2的通信系统焕然一新，多众多样的通信配置，可以更好的满足不同场景下的机器人应用。 好啦，DDS这么好，那该如何配置和使用呢？我们先带大家入个门。","text_tokens":["接收者","才能","系统","历史数据","体","供者","更好","处于","一起","参数","但是","domain","实现","发送","机器人","直接","有","成","用","哪些","适应","比如","。","时间","使用","尽量","类似","无人","需求","一次","绑定","为","reliable","如果","遥控器","下","不好","情况","历史","送给","策略","通信","ros2","将","帧","这种","啦","来看","结构","向","掉","，","id","互相","资源"," ","一新","视频","命令","中","之间","：","可以","要","也","完整","之前","另外","；","所有","best","这些","history","无人机","和","黑入","回忆","的话","是","qos","进行","服务","模型","尽可","配置","应用","流畅","这个","功能","过程","一些","给","通信模型","门","客户","保证","每次","树莓","完整性","不","_","都","数据通信","对","数据","信赖","提供者","空间","顺利","控制","出现","运动","发送给","焕然","具体","这么","呢","缓存","电脑","例子","机器","需要","提供","办法","reliability","一种","合约","durability","定义","全局","那该","焕然一新","举","表示","新","占用","dds","行为","入个","数据通","尽力","内","无用","只有","同一","的","各个","便于","effort","那个","基本","质量","我们","避免","理解","通过","会","可信赖","针对","样","合适","关系","满足","程序","要求","丢失","此时","一定","应用程序","模式","在","流畅性","这样","截止","完成","导致","传输","不同","带","晚","所","大家","网络","接收","航拍","就是","加密","ros","小组","根据","可能","大小","重要","快速","特性","场景","了","图","加入","？","每","派","一个","deadline","可信","先","如何","尽可能","分组","节点","指令","好","选择","时候","众多","指定","黑客","人机","没有","保证数据","让","图像","地","遥控","多","过去","默认","延时","同一个","必须"],"title":"质量服务策略QoS","title_tokens":["策略","服务","qos","质量"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#dds_3","text":"我们先来试一试在命令行中配置DDS的参数。 启动第一个终端，我们使用best_effort创建一个发布者节点，循环发布任意数据，在另外一个终端中，如果我们使用reliable模型订阅同一话题，无法实现数据通信，如果修改为同样的best_effort，才能实现数据传输。 $ ros2 topic pub /chatter std_msgs/msg/Int32 \"data: 42\" --qos-reliability best_effort $ ros2 topic echo /chatter --qos-reliability reliable $ ros2 topic echo /chatter --qos-reliability best_effort 如何去查看ROS2系统中每一个发布者或者订阅者的QoS策略呢，在topic命令后边跟一个\"--verbose\"参数就行了。 $ ros2 topic info /chatter --verbose","text_tokens":["data","才能","系统","chatter","参数","实现","创建","info","。","使用","reliable","如果","为","std","/","策略","启动","通信","ros2","后边","就行了","，"," ","\"","订阅","topic","命令","中","另外","best","无法","qos","跟","模型","verbose","配置","循环","任意","去","终端","_","数据通信","数据","--",":","来","呢","命令行","int32","msgs","reliability","发布","-","dds","数据通","话题","或者","$","同一","的","effort","发布者","我们","在","同样","数据传输","者","传输","pub","msg","据传","42","试一试","每","查看","一个","先","echo","如何","节点","第一","第一个","修改"],"title":"案例一：在命令行中配置DDS","title_tokens":["中","在","命令行","案例","一","：","配置","命令","dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#dds_4","text":"接下来，我们尝试在代码中配置DDS，以之前Hello World话题通信为例。","text_tokens":["之前","在","hello","配置","以","dds","接下来","为例","代码","话题","。","下来","尝试","我们","通信","，"," ","接下","world","中"],"title":"案例二：DDS编程示例","title_tokens":["编程","案例","二","示例","：","dds"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#_2","text":"启动两个终端，分别运行发布者和订阅者节点： $ ros2 run learning_qos qos_helloworld_pub $ ros2 run learning_qos qos_helloworld_sub 可以看到两个终端中的通信效果如下，和之前貌似并没有太大区别。 看效果确实差不多，不过底层通信机理上可是有所不同的。","text_tokens":["之前","看","机理","和","可是","确实","qos","者","上","如下","pub","不同","并","分别","差不多","run","不多","$","learning","看到","的","终端","。","中","效果","区别","发布者","两个","_","有所","有所不同","helloworld","底层","启动","节点","通信","大","ros2","不过","运行","没有","太","，"," ","订阅","：","可以","sub","貌似","发布"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#_3","text":"我们看下在代码中，如果加入QoS的配置。 learning_qos/qos_helloworld_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2 QoS示例-发布“Hello World”话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 from rclpy.qos import QoSProfile , QoSReliabilityPolicy , QoSHistoryPolicy # ROS2 QoS类 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 qos_profile = QoSProfile ( # 创建一个QoS原则 # reliability=QoSReliabilityPolicy.BEST_EFFORT, reliability = QoSReliabilityPolicy . RELIABLE , history = QoSHistoryPolicy . KEEP_LAST , depth = 1 ) self . pub = self . create_publisher ( String , \"chatter\" , qos_profile ) # 创建发布者对象（消息类型、话题名、QoS原则） self . timer = self . create_timer ( 0.5 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） def timer_callback ( self ): # 创建定时器周期执行的回调函数 msg = String () # 创建一个String类型的消息对象 msg . data = 'Hello World' # 填充消息对象中的消息数据 self . pub . publish ( msg ) # 发布话题消息 self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) # 输出日志信息，提示已经完成话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = PublisherNode ( \"qos_helloworld_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'qos_helloworld_pub = learning_qos.qos_helloworld_pub:main' , },","text_tokens":["data","”","shutdown","coding","env","系统","create","填充","com","s","示例","初始","chatter","callback","消息","name","创建","py","（","learning","info","。","python","node","reliable","如果","为","std","/","setup","ros2","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","中","get","接口","：","{","8","import","www","hello","best","初始化","history","输出","spin","qos","进行","none","publishernode","配置","qosprofile","）","循环","功能","提示","bin","guyuehome","回调","退出","对象","主","字符","函数","_","}","self","helloworld","数据","入口","周期","日志","编写","string","点",":","publisher","#","类型","[","super","需要","world","msgs","reliability","发布","from","__","定时器","-","console","last","并","作者","*","代码","原则","话题","的","选项","编译","scripts","effort","发布者","我们","关闭","utf","秒","知道","'",".","!","已经","说明","init","字符串","包","执行","单位","定时","信息","文件",")","、","等待","程序","古月","usr","在",",","名","main","1","完成","profile","如下","pub","%","entry","msg","看下","=","类","父类","publishing","timer","销毁","加入","设置","一个","qoshistorypolicy","args","points","publish","class","keep","节点","0.5","@","depth","“","后","让","(","qosreliabilitypolicy","logger"],"title":"发布者代码解析","title_tokens":["发布者","代码","解析","发布"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#_4","text":"订阅者中的QoS配置和发布者类似。 learning_qos/qos_helloworld_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2 QoS示例-订阅“Hello World”话题消息 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 from rclpy.qos import QoSProfile , QoSReliabilityPolicy , QoSHistoryPolicy # ROS2 QoS类 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 qos_profile = QoSProfile ( # 创建一个QoS原则 # reliability=QoSReliabilityPolicy.BEST_EFFORT, reliability = QoSReliabilityPolicy . RELIABLE , history = QoSHistoryPolicy . KEEP_LAST , depth = 1 ) self . sub = self . create_subscription ( \\ String , \"chatter\" , self . listener_callback , qos_profile ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、QoS原则） def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'I heard: \" %s \"' % msg . data ) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"qos_helloworld_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'qos_helloworld_pub = learning_qos.qos_helloworld_pub:main' , 'qos_helloworld_sub = learning_qos.qos_helloworld_sub:main' , ], }, DDS本身是一个非常复杂的系统，ROS2使用的也只是冰山一角，我们主要带领大家认识DDS，更多使用方法和相关内容，大家也可以参考下边的链接进行学习。","text_tokens":["data","”","shutdown","coding","env","系统","create","com","s","示例","初始","chatter","非常复杂","callback","消息","name","创建","标准","py","subscription","（","learning","info","。","python","subscribernode","使用","heard","类似","node","reliable","]","学习","内容","下边","std","/","setup","冰山一角","本身","ros2","链接","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","订阅","中","接口","get","：","{","8","也","冰山","import","www","hello","best","初始化","history","和","输出","spin","是","qos","进行","none","收到","配置","qosprofile","）","循环","功能","提示","i","bin","guyuehome","回调","退出","对象","主","函数","_","}","self","helloworld","对","数据","入口","复杂","日志","编写","string","点",":","#","类型","带领","[","super","需要","world","msgs","reliability","\\","发布","from","__","定义","-","console","非常","last","dds","认识","并","作者","*","代码","原则","可以","话题","的","选项","编译","scripts","effort","发布者","主要","关闭","知道","utf","我们","'",".","!","说明","init","包","执行","信息","文件",")","、","等待","程序","古月","usr","sub",",","名","main","1","完成","profile","者","如下","pub","%","entry","参考","msg","大家","=","类","父类","一角","销毁","加入","处理","设置","一个","qoshistorypolicy","listener","args","points","class","更","keep","节点","@","只是","depth","“","后","让","方法","多","(","相关","qosreliabilitypolicy","logger"],"title":"订阅者代码解析","title_tokens":["订阅","者","代码","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.10_DDS/#_5","text":"https://design.ros2.org/articles/ros_on_dds.html https://docs.ros.org/en/humble/Concepts/About-Different-Middleware-Vendors.html https://docs.ros.org/en/humble/How-To-Guides/Working-with-multiple-RMW-implementations.html https://www.bilibili.com/video/BV12z4y167w2","text_tokens":["www","implementations","about","-","how","guides","design","working","com","bilibili","dds","en","ros","rmw","on","articles","vendors","_","different","video",".","humble","concepts","/",":","html","ros2","https","with","middleware","to","multiple","bv12z4y167w2","docs"," ","org"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/","text":"工作空间：开发过程的大本营 大家在之前的学习和开发中，应该有接触过某些集成开发环境，比如Visual Studio、Eclipse、Qt Creator等，当我们想要编写程序之前，都会在这些开发环境的工具栏中，点击一个“创建新工程”的选项，此时就产生一个文件夹，后续所有工作产生的文件，都会放置在这个文件夹中，这个文件夹以及里边的内容，就叫做是 工程 。 工作空间是什么 类似的，在ROS机器人开发中，我们针对机器人某些功能进行代码开始时，各种编写的代码、参数、脚本等文件，也需要放置在某一个文件夹里进行管理，这个文件夹在ROS系统中就叫做 工作空间 。 所以工作空间是一个存放项目开发相关文件的文件夹，也是 开发过程中存放所有资料的大本营 。 ROS系统中一个典型的工作空间结构如图所示，这个dev_ws就是工作空间的根目录，里边会有四个子目录，或者叫做四个子空间。 src，代码空间 ，未来编写的代码、脚本，都需要人为的放置到这里； build，编译空间 ，保存编译过程中产生的中间文件； install，安装空间 ，放置编译得到的可执行文件和脚本； log，日志空间 ，编译和运行过程中，保存各种警告、错误、信息等日志。 总体来讲，这四个空间的文件夹，我们绝大部分操作都是在src中进行的，编译成功后，就会执行install里边的结果，build和log两个文件夹用的很少。 这里也要强调一点， 工作空间的名称我们可以自己定义 ，数量也并不是唯一的，比如： 工作空间1：dev_w_a，用于A机器人的开发； 工作空间2：dev_ws_b，用于B机器人的一部分功能； 工作空间3：dev_ws_b2，用于开发B机器人另外一些功能。 以上情况是完全允许的，就像是我们在集成开发环境中创建了多个新工程一样，都是并列存在的关系。 创建工作空间 了解了工作空间的概念和结果，接下来我们可以使用如下命令创建一个工作空间，并且下载教程的代码： $ mkdir -p ~/dev_ws/src $ cd ~/dev_ws/src $ git clone https://gitee.com/guyuehome/ros2_21_tutorials.git 自动安装依赖 我们从社区中下载的各种代码，多少都会有一些依赖，我们可以手动一个一个安装，也可以使用rosdep工具自动安装： $ sudo apt install -y python3-pip $ sudo pip3 install rosdepc $ sudo rosdepc init $ rosdepc update $ cd .. $ rosdepc install -i --from-path src --rosdistro humble -y 编译工作空间 依赖安装完成后，就可以使用如下命令编译工作空间啦，如果有缺少的依赖，或者代码有错误，编译过程中会有报错，否则编译过程应该不会出现任何错误： $ sudo apt install python3-colcon-ros $ cd ~/dev_ws/ $ colcon build 编译成功后，就可以在工作空间中看到自动生产的build、log、install文件夹了。 设置环境变量 编译成功后，为了让系统能够找到我们的功能包和可执行文件，还需要设置环境变量： $ source install/local_setup.sh # 仅在当前终端生效 $ echo \" source ~/dev_ws/install/local_setup.sh\" >> ~/.bashrc # 所有终端均生效 至此，我们就完成了工作空间的创建、编译和配置。 参考链接 https://docs.ros.org/en/ humble /Tutorials/Workspace/Creating-A-Workspace.html","text_tokens":["”","找到","到","系统","文件夹","过","件夹","b2","com","错误","行文","缺少","参数","成功","机器人","创建","绝大","有","目录","下载","人为","用","sh","比如","什么","。","子目录","各种","很少","使用","rosdep","报错","环境变","产生","一点","类似","git","学习","apt","如果","大部","内容","3","四个","workspace","rosdepc","情况","某些","/","自己","setup","org","ros2","资料","p","链接","操作","了解","来讲","啦","build","结构","放置","，","python3","多个"," ","为了","\"","命令","：","中","也","总体","要","开发","可以","之前","；","a","这些","所有","大部分","当","这里","和","另外","仅","还","是","自动生产","进行","w","这","配置","工作","这个","b","过程","功能","一些","应该","i","工程","guyuehome","里边","当前","creating","集成","时","终端","存放","studio","update","均","所以","都","_","某","未来","生产","以上","bashrc","空间","以及","日志","编写","--","humble","出现",":","clone","想要","依赖","空间结构","不会","#","中间","接触","名称","local","并且","机器","唯一","脚本","存在","需要","tutorials","能够","eclipse","概念","path","根目录","工具","from","任何","定义","保存","-","新","visual","并列","强调","sudo","点击","一部分","21","并","pip3","后续","接下来","2","代码","en","cd","source","一部","或者","$","的","选项","~","编译","完全","环境","可执行文件","两个","数量","下来","社区","我们","等","工具栏","..","会",".","部分","用于","多少","init","html","qt","针对","mkdir","https","执行","y","包","关系","pip","里",">","信息","文件","、","接下","程序","此时","看到","得到","环境变量","就","安装","在","开始","编写程序","典型","1","手动","完成","生效","src","如下","ws","警告","像是","参考","大家","至此","就是","ros","项目","否则","子目","从","如图所示","creator","所示","一样","了","大本营","绝大部分","gitee","设置","一个","教程","管理","rosdistro","colcon","子","log","变量","echo","允许","叫做","结果","install","“","运行","后","让","自动","docs","不是","中会","大本","相关","dev"],"title":"工作空间","title_tokens":["空间","工作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_1","text":"大家在之前的学习和开发中，应该有接触过某些集成开发环境，比如Visual Studio、Eclipse、Qt Creator等，当我们想要编写程序之前，都会在这些开发环境的工具栏中，点击一个“创建新工程”的选项，此时就产生一个文件夹，后续所有工作产生的文件，都会放置在这个文件夹中，这个文件夹以及里边的内容，就叫做是 工程 。","text_tokens":["之前","工具","这些","在","”","当","编写程序","和","就","所有","文件夹","过","是","新","件夹","visual","点击","工作","这个","创建","后续","应该","大家","有","此时","工程","里边","集成","比如","的","选项","。","creator","环境","studio","产生","都","学习","等","我们","工具栏","一个","内容","会","以及","编写","某些","叫做","想要","qt","“","接触","放置","，","文件"," ","、","eclipse","程序","中","开发"],"title":"工作空间：开发过程的大本营","title_tokens":["过程","大本营","空间","大本","：","的","开发","工作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_2","text":"类似的，在ROS机器人开发中，我们针对机器人某些功能进行代码开始时，各种编写的代码、参数、脚本等文件，也需要放置在某一个文件夹里进行管理，这个文件夹在ROS系统中就叫做 工作空间 。 所以工作空间是一个存放项目开发相关文件的文件夹，也是 开发过程中存放所有资料的大本营 。 ROS系统中一个典型的工作空间结构如图所示，这个dev_ws就是工作空间的根目录，里边会有四个子目录，或者叫做四个子空间。 src，代码空间 ，未来编写的代码、脚本，都需要人为的放置到这里； build，编译空间 ，保存编译过程中产生的中间文件； install，安装空间 ，放置编译得到的可执行文件和脚本； log，日志空间 ，编译和运行过程中，保存各种警告、错误、信息等日志。 总体来讲，这四个空间的文件夹，我们绝大部分操作都是在src中进行的，编译成功后，就会执行install里边的结果，build和log两个文件夹用的很少。 这里也要强调一点， 工作空间的名称我们可以自己定义 ，数量也并不是唯一的，比如： 工作空间1：dev_w_a，用于A机器人的开发； 工作空间2：dev_ws_b，用于B机器人的一部分功能； 工作空间3：dev_ws_b2，用于开发B机器人另外一些功能。 以上情况是完全允许的，就像是我们在集成开发环境中创建了多个新工程一样，都是并列存在的关系。","text_tokens":["到","系统","文件夹","件夹","b2","错误","行文","参数","成功","机器人","创建","绝大","有","目录","人为","用","很少","比如","。","子目录","各种","产生","一点","类似","大部","3","四个","情况","某些","自己","资料","操作","来讲","build","结构","放置","，","多个"," ","中","也","总体","要","可以","开发","：","a","；","一部","所有","另外","大部分","这里","和","是","进行","w","这","工作","这个","b","功能","过程","一些","工程","里边","集成","时","存放","所以","_","都","某","未来","以上","空间","日志","编写","空间结构","中间","名称","机器","唯一","脚本","存在","需要","根目录","定义","保存","新","并列","强调","一部分","并","2","代码","或者","的","编译","完全","环境","可执行文件","两个","数量","我们","等","会","部分","用于","针对","执行","关系","里","信息","文件","、","得到","就","安装","在","开始","典型","1","src","ws","警告","像是","就是","ros","项目","子目","如图所示","所示","一样","了","大本营","绝大部分","一个","管理","子","log","允许","叫做","结果","install","运行","后","不是","大本","相关","dev"],"title":"工作空间是什么","title_tokens":["什么","空间","是","工作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_3","text":"了解了工作空间的概念和结果，接下来我们可以使用如下命令创建一个工作空间，并且下载教程的代码： $ mkdir -p ~/dev_ws/src $ cd ~/dev_ws/src $ git clone https://gitee.com/guyuehome/ros2_21_tutorials.git","text_tokens":["：","和","-","com","如下","src","ws","工作","21","创建","接下来","代码","guyuehome","cd","$","的","~","使用","git","了","下来","_","我们","gitee","一个","教程","空间",".","/","结果",":","clone","ros2","p","https","了解","mkdir","并且","，","tutorials"," ","接下","命令","下载","概念","dev","可以"],"title":"创建工作空间","title_tokens":["空间","创建","工作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_4","text":"我们从社区中下载的各种代码，多少都会有一些依赖，我们可以手动一个一个安装，也可以使用rosdep工具自动安装： $ sudo apt install -y python3-pip $ sudo pip3 install rosdepc $ sudo rosdepc init $ rosdepc update $ cd .. $ rosdepc install -i --from-path src --rosdistro humble -y","text_tokens":["：","安装","工具","from","-","手动","path","sudo","src","pip3","一些","有","i","代码","cd","从","$","rosdep","的","各种","update","使用","中","都","社区","我们","apt","一个","..","rosdistro","会","rosdepc","--","humble","多少","init","依赖","install","y","pip","，","自动","python3"," ","下载","也","可以"],"title":"自动安装依赖","title_tokens":["安装","依赖","自动"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_5","text":"依赖安装完成后，就可以使用如下命令编译工作空间啦，如果有缺少的依赖，或者代码有错误，编译过程中会有报错，否则编译过程应该不会出现任何错误： $ sudo apt install python3-colcon-ros $ cd ~/dev_ws/ $ colcon build 编译成功后，就可以在工作空间中看到自动生产的build、log、install文件夹了。","text_tokens":["安装","就","任何","在","文件夹","-","自动生产","完成","件夹","错误","缺少","如下","sudo","成功","ws","工作","过程","有","应该","代码","ros","cd","否则","或者","$","看到","的","~","报错","编译","。","使用","中","_","了","apt","如果","生产","colcon","空间","log","出现","/","依赖","不会","install","啦","后","build","，","自动","python3","文件","中会"," ","、","命令","：","dev","可以"],"title":"编译工作空间","title_tokens":["空间","编译","工作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_6","text":"编译成功后，为了让系统能够找到我们的功能包和可执行文件，还需要设置环境变量： $ source install/local_setup.sh # 仅在当前终端生效 $ echo \" source ~/dev_ws/install/local_setup.sh\" >> ~/.bashrc # 所有终端均生效 至此，我们就完成了工作空间的创建、编译和配置。","text_tokens":["就","找到","在","所有","dev","和","仅","系统","还","完成","行文","配置","成功","ws","工作","功能","创建","至此","source","sh","当前","$","的","环境变","终端","编译","~","环境","均","。","可执行文件","_","了","我们","设置","变量","bashrc","空间",".","echo","/","setup","#","install","包","执行","后","local",">","让","，","能够","文件","需要","为了"," ","\"","、","：","生效","环境变量"],"title":"设置环境变量","title_tokens":["变量","设置","环境变","环境变量","环境"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/#_7","text":"https://docs.ros.org/en/ humble /Tutorials/Workspace/Creating-A-Workspace.html","text_tokens":["https","-","tutorials","workspace","en","docs","ros"," ","html",".","humble","creating","/",":","org","a"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/","text":"功能包：开发过程的大本营 在下载的教程代码中，大家可以看到有很多不同名称的文件夹，这些在ROS2并不是普通的文件夹，而是叫做 功能包 。 每个机器人可能有很多功能，比如移动控制、视觉感知、自主导航等，如果我们把这些功能的源码都放到一起当然也是可以的，但是当我们想把其中某些功能分享给别人时，就会发现代码都混合到了一起，很难拆分出来。 举个例子，我们手上有很多红豆、绿豆、黄豆，假设都放在一个袋子里，如果只想把黄豆都拿出来，是不是得在五颜六色的豆子里一颗一颗都找出来，数量越多，你就越头疼；如果我们把不同颜色的豆子放在不同的三个袋子里，需要拿出某种豆子的时候，不就立刻可以找出来了么。 功能包就是这个原理，我们把不同功能的代码划分到不同的功能包中，尽量降低他们之间的耦合关系，当需要在ROS社区中分享给别人的时候，只需要说明这个功能包该如何使用，别人很快就可以用起来了。 所以功能包的机制，是提高ROS中软件复用率的重要方法之一。 创建功能包 如何在ROS2中创建一个功能包呢？我们可以使用这个指令： $ ros2 pkg create --build-type <build-type> <package_name> ros2命令中： pkg ：表示功能包相关的功能； create ：表示创建功能包； build-type ：表示新创建的功能包是C++还是Python的，如果使用C++或者C，那这里就跟ament_cmake，如果使用Python，就跟ament_python； package_name ：新建功能包的名字。 比如在终端中分别创建C++和Python版本的功能包： $ cd ~/dev_ws/src $ ros2 pkg create --build-type ament_cmake learning_pkg_c # C++ $ ros2 pkg create --build-type ament_python learning_pkg_python # Python 编译功能包 在创建好的功能包中，我们可以继续完成代码的编写，之后需要编译和配置环境变量，才能正常运行： $ cd ~/dev_ws/src $ colcon build # 编译工作空间所有功能包 $ source install/local_setup.bash 功能包的结构 功能包并不是普通的文件夹，那如何判断一个文件夹是否是功能包呢？我们来分析下刚才新创建两个功能包的结构。 C++功能包 首先看下C++类型的功能包，其中必然存在两个文件： package.xml 和 CMakerLists.txt 。 package.xml文件的主要内容如下，包含功能包的版权描述，和各种依赖的声明。 CMakeLists.txt文件是编译规则，C++代码需要编译才能运行，所以必须要在该文件中设置如何编译，使用CMake语法。 Python功能包 C++功能包需要将源码编译成可执行文件，但是Python语言是解析型的，不需要编译，所以会有一些不同，但也会有这两个文件： package.xml 和 setup.py 。 package.xml文件的主要内容和C++版本功能包一样，包含功能包的版权描述，和各种依赖的声明。 setup.py文件里边也包含一些版权信息，除此之外，还有“entry_points”配置的程序入口，在后续编程讲解中，我们会给大家介绍如何使用。 参考链接 https://docs.ros.org/en/ humble /Tutorials/Workspace/Creating-A-Workspace.html https://docs.ros.org/en/ humble /Tutorials/Creating-Your-First-ROS2-Package.html","text_tokens":["首先","”","才能","到","ament","文件夹","create","<","源码","件夹","混合","first","cmake","之后","行文","一起","但是","name","机器人","创建","豆子","有","声明","正常","袋子","放到","用","发现","py","比如","learning","。","环境变","分析","各种","使用","python","编译成","尽量","越","视觉","如果","内容","workspace","下","某些","/","setup","型","org","之一","ros2","将","链接","某种","build","结构","，","举个","拿出","降低"," ","假设","移动","命令","：","下载","中","也","可以","导航","开发","之间","；","cd","这些","所有","要","当","很难","这里","和","描述","介绍","是","跟","感知","cmakelists","当然","这","配置","txt","工作","这个","分别","过程","功能","给","一些","新创","版本","里边","creating","除此","机制","必然","时","终端","package","不","所以","都","_","译成","入口","还有","空间","--","控制","编写","humble",":","把","依赖","普通","来","#","呢","类型","名称","新创建","local","出来","机器","例子","存在","tutorials","别人","需要","新建","放在","cmakerlists","一颗","其中","自主","每个","dev","-","表示","还是","原理","讲解","包含","语言","并","只想","颜色","很多","你","复用","而是","是否","规则","后续","代码","c","名字","en","source","或者","$","该","的","拿","~","编译","环境","只","可执行文件","数量","提高","分享","社区","我们","等","两个","主要","解析","立刻","红豆","包是","会","继续",".","包并","说明","html","bash","https","包","是否是","但","执行","耦合","关系","里",">","那","语法","文件","找","包中","pkg","、","信息","程序","起来","看到","环境变量","a","就","在","看","五颜六色","三个","完成","得","src","如下","ws","不同","率","包该","entry","参考","大家","软件","就是","刚才","ros","之外","判断","可能","想","重要","手上","版权","一样","是不是","除此之外","了","大本营","？","xml","变量","一个","教程","么","设置","colcon","points","头疼","叫做","如何","指令","c++","拆分","好","时候","install","your","很快","“","运行","编程","绿豆","黄豆","方法","type","不是","多","docs","大本","他们","相关","划分","必须"],"title":"功能包","title_tokens":["包","功能"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#_1","text":"在下载的教程代码中，大家可以看到有很多不同名称的文件夹，这些在ROS2并不是普通的文件夹，而是叫做 功能包 。 每个机器人可能有很多功能，比如移动控制、视觉感知、自主导航等，如果我们把这些功能的源码都放到一起当然也是可以的，但是当我们想把其中某些功能分享给别人时，就会发现代码都混合到了一起，很难拆分出来。 举个例子，我们手上有很多红豆、绿豆、黄豆，假设都放在一个袋子里，如果只想把黄豆都拿出来，是不是得在五颜六色的豆子里一颗一颗都找出来，数量越多，你就越头疼；如果我们把不同颜色的豆子放在不同的三个袋子里，需要拿出某种豆子的时候，不就立刻可以找出来了么。 功能包就是这个原理，我们把不同功能的代码划分到不同的功能包中，尽量降低他们之间的耦合关系，当需要在ROS社区中分享给别人的时候，只需要说明这个功能包该如何使用，别人很快就可以用起来了。 所以功能包的机制，是提高ROS中软件复用率的重要方法之一。","text_tokens":["到","文件夹","源码","件夹","混合","一起","但是","机器人","豆子","有","袋子","放到","用","发现","比如","。","使用","尽量","越","视觉","如果","某些","之一","ros2","某种","，","举个","拿出","降低"," ","假设","移动","下载","中","也","可以","之间","导航","；","这些","当","很难","是","感知","当然","这个","功能","给","机制","时","不","所以","都","控制","把","普通","名称","出来","机器","例子","别人","需要","放在","一颗","其中","自主","每个","原理","并","只想","颜色","很多","你","复用","而是","代码","的","拿","只","数量","提高","分享","社区","我们","等","立刻","红豆","会","说明","包","耦合","关系","里","文件","找","包中","、","起来","看到","就","在","五颜六色","三个","得","不同","率","包该","大家","软件","就是","ros","可能","想","重要","手上","是不是","了","一个","教程","么","头疼","叫做","如何","拆分","时候","很快","黄豆","绿豆","方法","不是","多","他们","划分"],"title":"功能包：开发过程的大本营","title_tokens":["包","过程","功能","大本营","大本","：","的","开发"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#_2","text":"如何在ROS2中创建一个功能包呢？我们可以使用这个指令： $ ros2 pkg create --build-type <build-type> <package_name> ros2命令中： pkg ：表示功能包相关的功能； create ：表示创建功能包； build-type ：表示新创建的功能包是C++还是Python的，如果使用C++或者C，那这里就跟ament_cmake，如果使用Python，就跟ament_python； package_name ：新建功能包的名字。 比如在终端中分别创建C++和Python版本的功能包： $ cd ~/dev_ws/src $ ros2 pkg create --build-type ament_cmake learning_pkg_c # C++ $ ros2 pkg create --build-type ament_python learning_pkg_python # Python","text_tokens":["；","就","在","这里","ament","和","create","-","<","表示","跟","还是","cmake","src","ws","name","这个","分别","创建","功能","c","名字","新创","版本","cd","或者","$","比如","的","。","终端","~","learning","使用","python","中","package","_","我们","？","如果","一个","包是","--","/","如何","指令","c++","ros2","#","包","呢","build","新创建",">","那","，","pkg","type"," ","新建","命令","：","dev","可以","相关"],"title":"创建功能包","title_tokens":["功能","包","创建"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#_3","text":"在创建好的功能包中，我们可以继续完成代码的编写，之后需要编译和配置环境变量，才能正常运行： $ cd ~/dev_ws/src $ colcon build # 编译工作空间所有功能包 $ source install/local_setup.bash","text_tokens":["所有","在","才能","和","完成","之后","配置","src","ws","工作","功能","创建","正常","代码","cd","source","$","的","环境变","~","编译","环境","_","我们","变量","继续","colcon","空间",".","编写","/","setup","好","#","bash","install","包","运行","build","local","，","需要","包中"," ","：","dev","可以","环境变量"],"title":"编译功能包","title_tokens":["包","功能","编译"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#_4","text":"功能包并不是普通的文件夹，那如何判断一个文件夹是否是功能包呢？我们来分析下刚才新创建两个功能包的结构。","text_tokens":["文件夹","件夹","功能","创建","是否","刚才","新创","判断","的","分析","。","两个","我们","？","一个","下","包并","如何","普通","来","是否是","包","呢","新创建","结构","那","，","文件","不是"],"title":"功能包的结构","title_tokens":["的","包","功能","结构"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#c","text":"首先看下C++类型的功能包，其中必然存在两个文件： package.xml 和 CMakerLists.txt 。 package.xml文件的主要内容如下，包含功能包的版权描述，和各种依赖的声明。 CMakeLists.txt文件是编译规则，C++代码需要编译才能运行，所以必须要在该文件中设置如何编译，使用CMake语法。","text_tokens":["首先","其中","看","cmakerlists","才能","在","和","描述","是","cmakelists","cmake","包含","txt","如下","规则","功能","声明","代码","该","的","必然","。","各种","编译","使用","版权","中","package","两个","所以","主要","xml","设置","内容","下",".","如何","c++","依赖","包","类型","运行","，","存在","语法","文件","需要","要"," ","：","必须"],"title":"C++功能包","title_tokens":["功能","包","c++"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#python","text":"C++功能包需要将源码编译成可执行文件，但是Python语言是解析型的，不需要编译，所以会有一些不同，但也会有这两个文件： package.xml 和 setup.py 。 package.xml文件的主要内容和C++版本功能包一样，包含功能包的版权描述，和各种依赖的声明。 setup.py文件里边也包含一些版权信息，除此之外，还有“entry_points”配置的程序入口，在后续编程讲解中，我们会给大家介绍如何使用。","text_tokens":["”","在","和","描述","介绍","是","源码","讲解","这","包含","行文","配置","语言","但是","不同","功能","entry","一些","给","后续","有","声明","大家","使用","里边","版本","之外","py","中","除此","的","。","编译","各种","python","编译成","一样","package","不","可执行文件","解析","所以","两个","主要","版权","译成","xml","除此之外","_","内容","入口","我们","还有","会","points",".","setup","如何","型","c++","依赖","将","包","但","执行","“","编程","，","信息","文件","需要"," ","程序","：","也"],"title":"Python功能包","title_tokens":["包","功能","python"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.2_%E5%8A%9F%E8%83%BD%E5%8C%85/#_5","text":"https://docs.ros.org/en/ humble /Tutorials/Workspace/Creating-A-Workspace.html https://docs.ros.org/en/ humble /Tutorials/Creating-Your-First-ROS2-Package.html","text_tokens":["-","first","en","ros","creating","package","workspace",".","humble","/",":","html","ros2","https","your","tutorials","docs"," ","org","a"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/","text":"节点 机器人是各种功能的综合体，每一项功能就像机器人的一个工作细胞，众多细胞通过一些机制连接到一起，成为了一个机器人整体。 在ROS中，我们给这些 “细胞”取了一个名字，那就是 节点 。 通信模型 完整的机器人系统可能并不是一个物理上的整体，比如这样一个的机器人： 在机器人身体里搭载了一台计算机A，它可以通过机器人的眼睛——摄像头，获取外界环境的信息，也可以控制机器人的腿——轮子，让机器人移动到想要去的地方。除此之外，可能还会有另外一台计算机B，放在你的桌子上，它可以远程监控机器人看到的信息，也可以远程配置机器人的速度和某些参数，还可以连接一个摇杆，人为控制机器人前后左右运动。 这些功能虽然位于不同的计算机中，但都是这款机器人的工作细胞，也就是节点，他们共同组成了一个完整的机器人系统。 节点在机器人系统中的职责就是 执行某些具体的任务 ，从计算机操作系统的角度来看，也叫做进程； 每个节点都是一个可以 独立运行的可执行文件 ，比如执行某一个python程序，或者执行C++编译生成的结果，都算是运行了一个节点； 既然每个节点都是独立的执行文件，那自然就可以想到，得到这个执行文件的 编程语言可以是不同的 ，比如C++、Python，乃至Java、Ruby等更多语言。 这些节点是功能各不相同的细胞，根据系统设计的不同，可能位于计算机A，也可能位于计算机B，还有可能运行在云端，这叫做 分布式 ，也就是可以分布在不同的硬件载体上； 每一个节点都需要有 唯一的命名 ，当我们想要去找到某一个节点的时候，或者想要查询某一个节点的状态时，可以通过节点的名称来做查询。 节点也可以比喻是一个一个的工人，分别完成不同的任务，他们有的在一线厂房工作，有的在后勤部门提供保障，他们互相可能并不认识，但却一起推动机器人这座“工厂”，完成更为复杂的任务。 接下来，我们就来看看， 节点这个工作细胞，到底该如何实现。 案例一：Hello World节点（面向过程） ROS2中节点的实现当然是需要编写程序了，我们从Hello World例程开始，先来实现一个最为简单的节点，功能并不复杂，就是循环打印一个“Hello World”字符串到终端中。 运行效果 大家先不要着急看代码，是骡子是马，先拉出来溜溜，我们通过ros2 run命令，运行编译好的课程代码，看下这个节点执行的效果如何，然后再来分析代码的实现过程，做到知其然也知其所以然。 $ ros2 run learning_node node_helloworld 运行成功后，可以在终端中看到循环打印“Hello World”字符串的效果。 代码解析 这个节点是如何实现的呢？我们来看下代码。 learning_node/node_helloworld.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向过程的实现方式 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import time def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_helloworld\" ) # 创建ROS2节点对象并进行初始化 while rclpy . ok (): # ROS2系统是否正常运行 node . get_logger () . info ( \"Hello World\" ) # ROS2日志输出 time . sleep ( 0.5 ) # 休眠控制循环时间 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , ], 创建节点流程 代码中出现的函数大家未来会经常用到，大家先不用纠结函数的具体使用方法，更重要的是理解节点的编码流程。 总结一下，想要实现一个节点，代码的实现流程是这样做： 编程接口初始化 创建节点并初始化 实现节点功能 销毁节点并关闭接口 大家如果有学习过C++或者Pyhton的话，应该可以发现这里我们使用的是面向过程的编程方法，这种方式虽然实现简单，但是对于稍微复杂一点的机器人系统，就很难做到模块化编码。 案例二：Hello World节点（面向对象） 所以在ROS2的开发中，我们更 推荐大家使用面向对象的编程方式 ，比如刚才的代码就可以改成这样，虽然看上去复杂了一些，但是代码会具备更好的可读性和可移植性，调试起来也会更加方便。 运行效果 接下来运行一下调整后的节点： $ ros2 run learning_node node_helloworld_class 运行成功后，可以还是可以在终端中看到循环打印“Hello World”字符串的效果。 代码解析 功能虽然一样，但是程序的结构发生了变化，我们具体看一下这份代码。 learning_node/node_helloworld_class.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向对象的实现方式 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import time \"\"\" 创建一个HelloWorld节点, 初始化时输出“hello world”日志 \"\"\" class HelloWorldNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 while rclpy . ok (): # ROS2系统是否正常运行 self . get_logger () . info ( \"Hello World\" ) # ROS2日志输出 time . sleep ( 0.5 ) # 休眠控制循环时间 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = HelloWorldNode ( \"node_helloworld_class\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , ], 创建节点流程 所以总体而言，节点的实现方式依然是这四个步骤，只不过编码方式做了一些改变而已。 编程接口初始化 创建节点并初始化 实现节点功能 销毁节点并关闭接口 到这里为止，大家是不是心里还有一个疑惑，机器人中的节点不能只是打印Hello World吧，是不是得完成一些具体的任务。 案例三：物体识别节点 没错，接下来我们就以机器视觉的任务为例，模拟实际机器人中节点的实现过程。 我们先从网上找到一张苹果的图片，通过编写一个节点来识别图片中的苹果。 运行效果 在这个例程中，我们将用到一个图像处理的库——OpenCV，运行前请使用如下指令安装： $ sudo apt install python3-opencv 然后就可以运行例程啦： $ ros2 run learning_node node_object #注意修改图片路径后重新编译 Attention 运行前需要将learning_node/node_object.py代码中的图片路径，修改为实际路径，修改后重新编译运行即可： image = cv2.imread(' /home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg ') 例程运行成功后，会弹出一个可视化窗口，可以看到苹果被成功识别啦，一个绿色框会把苹果的轮廓勾勒出来，中间的绿点表示中心点。 代码解析 在这个例程中，我们加入了图像识别的处理过程，模拟一个节点的功能，关于图像处理的具体实现，并不是此处的重点，大家更多要关注我们是如何通过节点的概念来实现一个具体的机器人功能。 learning_node/node_object.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-通过颜色识别检测图片中出现的苹果 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import cv2 # OpenCV图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 def object_detect ( image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 0 ) cv2 . destroyAllWindows () def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_object\" ) # 创建ROS2节点对象并进行初始化 node . get_logger () . info ( \"ROS2节点示例：检测图片中的苹果\" ) image = cv2 . imread ( '/home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg' ) # 读取图像 object_detect ( image ) # 苹果检测 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , 'node_object = learning_node.node_object:main' , ], 案例四：机器视觉识别节点 用图片进行识别好像还不太合理，机器人应该有眼睛呀，没问题，接下来我们就让节点读取摄像头的图像，动态识别其中的苹果，或者类似颜色的物体。 运行效果 启动一个终端，运行如下节点： $ ros2 run learning_node node_object_webcam #注意设置摄像头 Attention 如果是在虚拟机中操作，需要进行以下设置： 1. 把虚拟机设置为兼容USB3.1； 2. 在可移动设备中将摄像头连接至虚拟机。 运行成功后，该节点就可以驱动摄像头，并且实时识别摄像头中的红色物体啦。 代码解析 相比之前的程序，这里最大的变化是修改了图片的来源，使用OpenCV中的VideoCapture()来驱动相机，并且周期read摄像头的信息，并进行识别。 learning_node/node_object_webcam.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-通过摄像头识别检测图片中出现的苹果 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import cv2 # OpenCV图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 def object_detect ( image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_object_webcam\" ) # 创建ROS2节点对象并进行初始化 node . get_logger () . info ( \"ROS2节点示例：检测图片中的苹果\" ) cap = cv2 . VideoCapture ( 0 ) while rclpy . ok (): ret , image = cap . read () # 读取一帧图像 if ret == True : object_detect ( image ) # 苹果检测 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , 'node_object = learning_node.node_object:main' , 'node_object_webcam = learning_node.node_object_webcam:main' , ], 节点命令行操作 节点命令的常用操作如下： $ ros2 node list # 查看节点列表 $ ros2 node info <node_name> # 查看节点信息 思考题 现在，大家应该熟悉节点这个工作细胞的概念和实现方法了，回到这个机器人系统的框架图，我们还会发现另外一个问题。 电脑B中的摇杆，要控制机器人运动，这两个节点岂不是应该有某种连接，比如摇杆节点发送一个速度指令给运动节点，收到后机器人开始运动。 同理，如果我们想要改变机器人的速度，负责配置参数的节点就得发送一个指令给运动节点，如果电脑B想要显示机器人看到的图像，电脑A中的摄像头节点就得把图像发送过来。 没错，在一个ROS机器人的系统中， 节点并不是孤立的，他们之间会有很多种机制保持联系 ，下一节，我们将给大家介绍这些机制中最为常用的一种。 参考链接 https://docs.ros.org/en/humble/Tutorials/Understanding-ROS2-Nodes.html","text_tokens":["变化","”","到","coding","看上","任务","<","算机","com","二","一起","各不相同","重点","但是","destroyallwindows","approx","—","更加","retr","有","最大","比如","learning","python","设计","]","所以然","四个","/","setup","实时","通信","cv2","50","库","，","太","in","摇杆"," ","地方","命令","一张","org","接口","可以","要","a","课程","另外","import","这些","综合体","下限","这里","ret","spin","进行","请","考题","过程","给","更多要","出","显示","位于","像","都","未来","入口","点","出现","后勤部门","不过","drawcontours","中间","命令行","出来","而言","attention","并且","150","world","一种","范围","步骤","负责","理过","着急","mask","左上","helloworldnode","21","图像处理","绿色","该","的","方式","一节","编程语言","解析","关于","等","检测","吧","会","usb3.1","现在","字符串","坐标","执行",")","接下","waitkey","usr","稍微","流程","可视","具备","1","框架","一项","命名","java","不同","数值","载体","进程","就是","知其所以然","之外","父类","根据","左右","保持联系","xy","contours","是不是","每","？","处理","查看","一个","厂房","结果","pyhton","c++","指令","上角","调试","上去","“","后","docs","框会","思考题","监控","+","四","找到","不能","read","做到","再","更好","参数","骡子","name","看上去","方便","中心点","框架图","正常","。","各种","路径","可移植","类似","node","视觉","学习","apt","生成","此处","某些","启动","计算","状态","链接","却","操作","啦","来看","细胞","hcx","更多","组成","lower","get","也","findcontours","搭载","驱动","先拉","开发","之前","；","之间","输出","当","而已","和","x","的话","介绍","understanding","模型","上","）","工作","分布式","身体","color","工人","功能","宽","通信模型","guyuehome","主","时","终端","物理","_","云端","continue","控制","编写",":","想要","#","180","名称","电脑","角度","[","机器","tutorials","部门","int","放在","可","其中","每个","推动","这座","知其然","可移植性","sleep","-","关注","移植","桌子","语言","思考","并","是否","ruby","接下来","128","代码","推荐","en","as","两个","每一项","知道","移植性","通过",".","init","里",">","信息","文件","后勤部","分布","兼容","看到","一线","更为","得到","安装","在","开始",",","编写程序","255","一台","取","改变","如下","ws","图像识别","至","参考","太小","噪声","刚才","ros","类","疑惑","案例","看看","可能","销毁","就让","虽然","不用","摄像头","总体而言","还会","这款","class","更","节点","及","0.5","时候","众多","只是","install","编程","实际","想到","cap","home","不是","没错","dev","用到","发生","env","系统","例程","然后","多种","一下","circle","成功","h","机器人","创建","计算机","回到","object","摄像","面向","run","用","时间","一点","为","下","合体","编码","ros2","inrange","nodes","这种","休眠","虚拟","某种","destroy","互相","移动","：","中","保持","相同","www","hello","心里","可视化","远程","去除","w","cvtcolor","b","分别","像素","图片","既然","np","做","硬件","这份","apple","5","前后左右","去","除此","对象","退出","字符","函数","所以","某","同理","还有","物体","周期","复杂","具体","把","唯一","经常","super","提供","工厂","改成","__","眼睛","console","算是","布式","0","颜色","你","chain","岂","*","2","名字","呀","编译","scripts","效果","职责","被","它","好像","utf","合理","前后","理解","!","速度","说明","html","https","y","只不过","轮子","那","溜溜","、","等待","程序","jpg","独立","起来","for","main","hierarchy","查询","苹果","这样","完成","if","纠结","得","以","src","shape","detect","大家","自然","面积","乃至","重要","网上","numpy","boundingrect","除此之外","了","比喻","不要","操作系统","加入","像头","points","注意","一","转换","@","修改","外界","多","红色","(","中心","获取","列表","shutdown","绿点","模块化","过","很","示例","初始","行文","到底","实现","发送","总结","人为","py","发现","（","info","分析","bgr2hsv","使用","来源","如果","勾勒","窗口","imread","简单","三","设备","将","打开","轮廓","综合","所在","结构","居","python3","def","img","后勤","\"","问题","相机","rclpy","{","总体","完整","8","高","初始化","list","还","是","当然","none","这","对于","配置","最为","收到","循环","while","这个","一些","相比","应该","bin","打印","二值化","机制","过来","webcam","不","成为","self","会弹","helloworld","videocapture","日志","humble","运动","整体","array","保障","来","联系","呢","模拟","为止","动态","模块","需要","点画","red","概念","发布","90","调整","from","表示","hsv","还是","腿","sudo","面向对象","认识","马","作者","重新","imshow","常用","或者","$","可读","选项","环境","共同","前","上限","以下","可执行文件","下来","我们","关闭","'","time","难","处理过程","左上角","即可","没","包","但","孤立","依然","识别","upper","古月","就","image","连接","看","cnt","熟悉","阈值","entry","为例","=","从","一帧","虚拟机","中将","编码方式","一样","设置","args","ok","先","叫做","如何","opencv","好","可读性","读取","运行","让","方法","图像","他们","true","bgr","logger"],"title":"节点","title_tokens":["节点"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_1","text":"机器人是各种功能的综合体，每一项功能就像机器人的一个工作细胞，众多细胞通过一些机制连接到一起，成为了一个机器人整体。 在ROS中，我们给这些 “细胞”取了一个名字，那就是 节点 。","text_tokens":["就","这些","综合体","连接","到","在","”","取","是","一项","一起","工作","机器人","功能","一些","给","就是","名字","ros","机制","的","。","各种","像","成为","了","每一项","我们","一个","通过","整体","合体","节点","众多","“","综合","那","细胞","机器","，"," ","中"],"title":"节点","title_tokens":["节点"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_2","text":"完整的机器人系统可能并不是一个物理上的整体，比如这样一个的机器人： 在机器人身体里搭载了一台计算机A，它可以通过机器人的眼睛——摄像头，获取外界环境的信息，也可以控制机器人的腿——轮子，让机器人移动到想要去的地方。除此之外，可能还会有另外一台计算机B，放在你的桌子上，它可以远程监控机器人看到的信息，也可以远程配置机器人的速度和某些参数，还可以连接一个摇杆，人为控制机器人前后左右运动。 这些功能虽然位于不同的计算机中，但都是这款机器人的工作细胞，也就是节点，他们共同组成了一个完整的机器人系统。 节点在机器人系统中的职责就是 执行某些具体的任务 ，从计算机操作系统的角度来看，也叫做进程； 每个节点都是一个可以 独立运行的可执行文件 ，比如执行某一个python程序，或者执行C++编译生成的结果，都算是运行了一个节点； 既然每个节点都是独立的执行文件，那自然就可以想到，得到这个执行文件的 编程语言可以是不同的 ，比如C++、Python，乃至Java、Ruby等更多语言。 这些节点是功能各不相同的细胞，根据系统设计的不同，可能位于计算机A，也可能位于计算机B，还有可能运行在云端，这叫做 分布式 ，也就是可以分布在不同的硬件载体上； 每一个节点都需要有 唯一的命名 ，当我们想要去找到某一个节点的时候，或者想要查询某一个节点的状态时，可以通过节点的名称来做查询。 节点也可以比喻是一个一个的工人，分别完成不同的任务，他们有的在一线厂房工作，有的在后勤部门提供保障，他们互相可能并不认识，但却一起推动机器人这座“工厂”，完成更为复杂的任务。 接下来，我们就来看看， 节点这个工作细胞，到底该如何实现。","text_tokens":["找到","”","到","系统","任务","算机","行文","到底","一起","参数","各不相同","实现","机器人","—","计算机","有","摄像","人为","比如","。","python","设计","生成","某些","计算","状态","却","操作","来看","细胞","，","摇杆","互相"," ","地方","组成","移动","后勤","：","也","中","可以","搭载","完整","a","相同","另外","；","这些","当","和","远程","还","是","这","上","配置","工作","分布式","身体","b","这个","功能","工人","分别","既然","做","硬件","前后左右","去","除此","时","位于","物理","不","都","云端","某","还有","复杂","控制","运动","整体","具体","想要","后勤部门","保障","来","名称","角度","机器","唯一","需要","提供","部门","放在","工厂","每个","推动","这座","眼睛","腿","算是","布式","桌子","语言","认识","并","你","ruby","接下来","或者","该","的","编译","环境","共同","可执行文件","编程语言","职责","下来","它","我们","等","前后","通过","速度","但","执行","轮子","里","那","信息","文件","后勤部","分布","、","接下","程序","独立","看到","一线","更为","得到","就","在","连接","一台","查询","这样","完成","命名","java","不同","载体","进程","就是","自然","之外","从","左右","根据","看看","可能","乃至","除此之外","了","比喻","每","操作系统","虽然","一个","像头","厂房","摄像头","还会","这款","叫做","结果","更","节点","c++","如何","时候","“","运行","编程","外界","让","想到","不是","多","他们","获取","监控"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#hello-world","text":"ROS2中节点的实现当然是需要编写程序了，我们从Hello World例程开始，先来实现一个最为简单的节点，功能并不复杂，就是循环打印一个“Hello World”字符串到终端中。","text_tokens":["”","hello","开始","到","编写程序","是","当然","例程","最为","循环","实现","并","功能","就是","打印","从","的","。","字符","终端","不","了","我们","一个","复杂","简单","编写","先","节点","ros2","来","字符串","“","，","需要"," ","world","程序","中"],"title":"案例一：Hello World节点（面向过程）","title_tokens":["hello","过程","面向"," ","案例","world","（","一","：","）","节点"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_3","text":"大家先不要着急看代码，是骡子是马，先拉出来溜溜，我们通过ros2 run命令，运行编译好的课程代码，看下这个节点执行的效果如何，然后再来分析代码的实现过程，做到知其然也知其所以然。 $ ros2 run learning_node node_helloworld 运行成功后，可以在终端中看到循环打印“Hello World”字符串的效果。","text_tokens":["课程","”","看","知其然","在","hello","是","做到","再","着急","然后","成功","循环","骡子","实现","马","这个","过程","大家","代码","知其所以然","run","打印","$","learning","的","分析","。","编译","终端","看到","字符","效果","所以","不要","_","node","我们","helloworld","下","所以然","通过","先","如何","节点","ros2","好","来","字符串","执行","“","运行","后","出来","，","溜溜"," ","world","命令","中","也","可以","先拉"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_4","text":"这个节点是如何实现的呢？我们来看下代码。 learning_node/node_helloworld.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向过程的实现方式 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import time def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_helloworld\" ) # 创建ROS2节点对象并进行初始化 while rclpy . ok (): # ROS2系统是否正常运行 node . get_logger () . info ( \"Hello World\" ) # ROS2日志输出 time . sleep ( 0.5 ) # 休眠控制循环时间 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , ],","text_tokens":["”","shutdown","coding","env","系统","com","示例","初始","实现","创建","正常","面向","py","learning","info","。","时间","使用","python","node","]","下","/","setup","ros2","打开","休眠","来看","库","destroy","，","居","python3","def"," ","\"","rclpy","get","：","接口","{","8","import","www","hello","输出","初始化","是","进行","none","配置","循环","while","这个","过程","功能","bin","guyuehome","主","对象","函数","_","helloworld","入口","日志","控制","编写","点",":","#","呢","[","需要","world","发布","from","sleep","-","console","并","作者","是否","*","代码","的","选项","方式","编译","scripts","我们","关闭","utf","知道","'","time",".","!","说明","init","包","信息","文件",")","程序","古月","usr",",","main","完成","如下","entry","=","类","销毁","加入","？","设置","args","ok","points","如何","节点","0.5","@","“","运行","后","让","(","logger"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_5","text":"代码中出现的函数大家未来会经常用到，大家先不用纠结函数的具体使用方法，更重要的是理解节点的编码流程。 总结一下，想要实现一个节点，代码的实现流程是这样做： 编程接口初始化 创建节点并初始化 实现节点功能 销毁节点并关闭接口 大家如果有学习过C++或者Pyhton的话，应该可以发现这里我们使用的是面向过程的编程方法，这种方式虽然实现简单，但是对于稍微复杂一点的机器人系统，就很难做到模块化编码。","text_tokens":["：","就","初始化","这里","系统","的话","模块化","过","是","这样","很","做到","初始","纠结","一下","对于","但是","实现","机器人","并","创建","功能","过程","有","大家","应该","代码","做","总结","面向","稍微","发现","或者","的","。","方式","重要","使用","函数","一点","销毁","关闭","如果","学习","未来","我们","一个","虽然","理解","会","不用","复杂","简单","先","出现","难","更","具体","节点","编码","想要","c++","pyhton","这种","编程","，","经常","方法","机器","模块"," ","中","接口","可以","用到","流程"],"title":"创建节点流程","title_tokens":["节点","创建","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#hello-world_1","text":"所以在ROS2的开发中，我们更 推荐大家使用面向对象的编程方式 ，比如刚才的代码就可以改成这样，虽然看上去复杂了一些，但是代码会具备更好的可读性和可移植性，调试起来也会更加方便。","text_tokens":["就","在","看上","和","可移植性","具备","这样","更好","移植","但是","面向对象","更加","看上去","一些","方便","大家","代码","面向","推荐","刚才","对象","可读","比如","的","。","方式","使用","可移植","所以","了","移植性","我们","虽然","会","复杂","更","ros2","上去","调试","可读性","编程","，"," ","起来","中","也","可以","开发","改成"],"title":"案例二：Hello World节点（面向对象）","title_tokens":["面向对象","hello","面向","对象"," ","案例","world","二","（","：","）","节点"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_6","text":"接下来运行一下调整后的节点： $ ros2 run learning_node node_helloworld_class 运行成功后，可以还是可以在终端中看到循环打印“Hello World”字符串的效果。","text_tokens":["调整","”","在","hello","还是","一下","成功","循环","接下来","run","打印","$","learning","的","看到","终端","字符","。","中","效果","下来","_","node","helloworld","class","节点","ros2","字符串","“","运行","后","，"," ","接下","world","：","可以"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_7","text":"功能虽然一样，但是程序的结构发生了变化，我们具体看一下这份代码。 learning_node/node_helloworld_class.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-发布“Hello World”日志信息, 使用面向对象的实现方式 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import time \"\"\" 创建一个HelloWorld节点, 初始化时输出“hello world”日志 \"\"\" class HelloWorldNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 while rclpy . ok (): # ROS2系统是否正常运行 self . get_logger () . info ( \"Hello World\" ) # ROS2日志输出 time . sleep ( 0.5 ) # 休眠控制循环时间 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = HelloWorldNode ( \"node_helloworld_class\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , ],","text_tokens":["变化","”","发生","coding","shutdown","env","系统","com","示例","初始","一下","但是","实现","name","创建","正常","面向","py","learning","info","。","时间","使用","python","node","]","/","setup","ros2","打开","休眠","结构","库","，","destroy","居","python3","def"," ","\"","rclpy","get","：","接口","{","8","import","www","hello","输出","初始化","spin","进行","none","配置","循环","while","功能","bin","这份","guyuehome","退出","对象","主","时","函数","_","self","helloworld","入口","日志","控制","编写","点",":","具体","#","[","super","需要","world","发布","from","__","sleep","-","console","helloworldnode","面向对象","并","作者","是否","*","代码","的","选项","方式","编译","scripts","我们","关闭","utf","知道","'","time",".","!","说明","init","包","信息","文件",")","等待","程序","古月","usr","看",",","main","完成","如下","entry","=","类","父类","一样","了","销毁","加入","虽然","设置","一个","args","ok","points","class","节点","0.5","@","“","运行","后","让","(","logger"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_8","text":"所以总体而言，节点的实现方式依然是这四个步骤，只不过编码方式做了一些改变而已。 编程接口初始化 创建节点并初始化 实现节点功能 销毁节点并关闭接口 到这里为止，大家是不是心里还有一个疑惑，机器人中的节点不能只是打印Hello World吧，是不是得完成一些具体的任务。","text_tokens":["不能","hello","到","而已","初始化","这里","心里","任务","步骤","是","完成","这","改变","初始","得","实现","机器人","并","创建","功能","一些","大家","做","疑惑","打印","的","。","方式","编码方式","是不是","所以","了","销毁","关闭","一个","吧","四个","还有","总体而言","具体","节点","编码","不过","只是","只不过","编程","为止","而言","，","机器","依然","不是"," ","world","中","总体","接口"],"title":"创建节点流程","title_tokens":["节点","创建","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_9","text":"没错，接下来我们就以机器视觉的任务为例，模拟实际机器人中节点的实现过程。 我们先从网上找到一张苹果的图片，通过编写一个节点来识别图片中的苹果。","text_tokens":["就","找到","任务","苹果","以","实现","机器人","过程","接下来","图片","为例","从","的","。","网上","下来","视觉","我们","一个","通过","先","编写","节点","来","一张","模拟","实际","，","机器","识别"," ","没错","接下","中"],"title":"案例三：物体识别节点","title_tokens":["：","物体","识别","案例","三","节点"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_10","text":"在这个例程中，我们将用到一个图像处理的库——OpenCV，运行前请使用如下指令安装： $ sudo apt install python3-opencv 然后就可以运行例程啦： $ ros2 run learning_node node_object #注意修改图片路径后重新编译 Attention 运行前需要将learning_node/node_object.py代码中的图片路径，修改为实际路径，修改后重新编译运行即可： image = cv2.imread(' /home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg ') 例程运行成功后，会弹出一个可视化窗口，可以看到苹果被成功识别啦，一个绿色框会把苹果的轮廓勾勒出来，中间的绿点表示中心点。","text_tokens":["绿点","例程","然后","成功","—","object","中心点","run","py","learning","。","路径","使用","node","apt","为","勾勒","窗口","imread","/","ros2","将","cv2","啦","轮廓","库","，","hcx","python3"," ","：","中","可以","可视化","请","这个","图片","apple","出","_","会弹","中心","把","#","中间","出来","attention","tutorials","需要","-","表示","sudo","21","图像处理","重新","代码","绿色","$","的","编译","前","被","我们","'",".","即可","识别",")","jpg","看到","可视","安装","就","在","image","苹果","如下","src","ws","=","处理","一个","注意","opencv","指令","install","修改","运行","后","实际","图像","home","框会","(","dev","用到"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_11","text":"在这个例程中，我们加入了图像识别的处理过程，模拟一个节点的功能，关于图像处理的具体实现，并不是此处的重点，大家更多要关注我们是如何通过节点的概念来实现一个具体的机器人功能。 learning_node/node_object.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-通过颜色识别检测图片中出现的苹果 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import cv2 # OpenCV图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 def object_detect ( image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 0 ) cv2 . destroyAllWindows () def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_object\" ) # 创建ROS2节点对象并进行初始化 node . get_logger () . info ( \"ROS2节点示例：检测图片中的苹果\" ) image = cv2 . imread ( '/home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg' ) # 读取图像 object_detect ( image ) # 苹果检测 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , 'node_object = learning_node.node_object:main' , ],","text_tokens":["shutdown","coding","env","系统","<","例程","com","示例","初始","circle","重点","destroyallwindows","实现","approx","机器人","h","创建","retr","object","logger","py","learning","info","。","bgr2hsv","python","使用","node","]","为","勾勒","imread","此处","/","setup","计算","ros2","inrange","将","打开","cv2","轮廓","所在","库","，","hcx","居","python3","更多","def"," ","\"","lower","img","in","rclpy","中","findcontours","接口","get","：","{","8","import","www","下限","x","高","list","和","初始化","去除","spin","是","进行","none","w","cvtcolor","模型","配置","循环","color","宽","这个","过程","功能","一些","像素","图片","np","apple","bin","guyuehome","5","更多要","二值化","显示","主","对象","退出","函数","_","destroy","helloworld","入口","continue","编写","出现","点",":","具体","array","来","#","drawcontours","模拟","180","[","机器","出来","tutorials","150","需要","int","点画","red","概念","90","from","范围","dev","-","hsv","理过","关注","console","mask","左上","0","21","图像处理","并","作者","颜色","chain","128","*","2","代码","imshow","的","选项","编译","scripts","as","上限","效果","关于","我们","检测","utf","关闭","知道","'","通过","处理过程",".","!","左上角","说明","init","y","坐标","包","文件","识别",")","jpg","waitkey","等待","程序","upper","古月","usr","for","得到","cnt","image","在",",","255","main","hierarchy","1","苹果","阈值","完成","if","src","如下","ws","shape","图像识别","数值","detect","entry","太小","大家","噪声","=","类","从","面积","numpy","boundingrect","contours","xy","了","销毁","加入","处理","设置","一个","args","points","转换","class","如何","节点","opencv","上角","及","@","读取","后","让","图像","home","不是","红色","(","中心","bgr","+"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_12","text":"用图片进行识别好像还不太合理，机器人应该有眼睛呀，没问题，接下来我们就让节点读取摄像头的图像，动态识别其中的苹果，或者类似颜色的物体。","text_tokens":["其中","还","苹果","进行","眼睛","机器人","颜色","图片","应该","有","接下来","摄像","呀","用","或者","的","。","不","下来","类似","就让","好像","我们","合理","像头","物体","摄像头","节点","没","读取","太","，","机器","图像","动态","识别","问题","接下"],"title":"案例四：机器视觉识别节点","title_tokens":["视觉","机器","识别","案例","：","节点","四"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_13","text":"启动一个终端，运行如下节点： $ ros2 run learning_node node_object_webcam #注意设置摄像头 Attention 如果是在虚拟机中操作，需要进行以下设置： 1. 把虚拟机设置为兼容USB3.1； 2. 在可移动设备中将摄像头连接至虚拟机。 运行成功后，该节点就可以驱动摄像头，并且实时识别摄像头中的红色物体啦。","text_tokens":["；","就","在","连接","1","是","进行","如下","成功","至","object","摄像","2","run","$","learning","虚拟机","中将","webcam","终端","。","该","驱动","中","以下","的","_","node","如果","为","设置","一个","像头","物体","摄像头",".","注意","usb3.1","实时","设备","启动","节点","把","ros2","#","操作","虚拟","运行","后","啦","并且","，","attention","兼容","需要","识别"," ","红色","移动","：","可以","可"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_14","text":"相比之前的程序，这里最大的变化是修改了图片的来源，使用OpenCV中的VideoCapture()来驱动相机，并且周期read摄像头的信息，并进行识别。 learning_node/node_object_webcam.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2节点示例-通过摄像头识别检测图片中出现的苹果 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import cv2 # OpenCV图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 def object_detect ( image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = Node ( \"node_object_webcam\" ) # 创建ROS2节点对象并进行初始化 node . get_logger () . info ( \"ROS2节点示例：检测图片中的苹果\" ) cap = cv2 . VideoCapture ( 0 ) while rclpy . ok (): ret , image = cap . read () # 读取一帧图像 if ret == True : object_detect ( image ) # 苹果检测 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'node_helloworld = learning_node.node_helloworld:main' , 'node_helloworld_class = learning_node.node_helloworld_class:main' , 'node_object = learning_node.node_object:main' , 'node_object_webcam = learning_node.node_object_webcam:main' , ],","text_tokens":["变化","shutdown","coding","env","系统","<","read","com","示例","初始","circle","approx","h","创建","retr","最大","摄像","object","logger","py","learning","info","。","bgr2hsv","使用","python","node","来源","]","为","勾勒","{","/","setup","计算","ros2","inrange","将","打开","cv2","轮廓","所在","50","库","，","destroy","居","python3","def","img"," ","\"","相机","lower","in","rclpy","中","findcontours","接口","驱动","get","：","8","之前","ret","import","www","下限","x","这里","list","和","高","初始化","去除","是","进行","none","w","cvtcolor","模型","配置","color","while","宽","像素","功能","一些","相比","图片","np","bin","guyuehome","5","二值化","显示","主","对象","webcam","函数","_","helloworld","入口","continue","videocapture","周期","编写","出现","点",":","array","来","#","drawcontours","180","并且","[","出来","150","需要","int","点画","red","90","from","范围","-","hsv","console","mask","左上","0","图像处理","并","作者","颜色","chain","128","*","2","代码","imshow","的","选项","编译","scripts","as","上限","效果","关闭","检测","utf","知道","'","通过",".","!","左上角","说明","init","y","坐标","包","信息","文件","识别",")","waitkey","程序","upper","古月","usr","for","得到","cnt","image",",","255","main","hierarchy","1","苹果","阈值","完成","if","如下","shape","数值","detect","entry","太小","噪声","=","类","从","一帧","面积","numpy","boundingrect","contours","xy","了","销毁","加入","处理","设置","像头","args","摄像头","ok","points","转换","class","opencv","节点","上角","及","@","修改","读取","后","让","cap","图像","红色","(","true","中心","bgr","+"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_15","text":"节点命令的常用操作如下： $ ros2 node list # 查看节点列表 $ ros2 node info <node_name> # 查看节点信息","text_tokens":["列表","list","<","如下","name","常用","$","info","的","_","node","查看","节点","ros2","#","操作",">","信息"," ","命令","："],"title":"节点命令行操作","title_tokens":["命令","操作","节点","命令行"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_16","text":"现在，大家应该熟悉节点这个工作细胞的概念和实现方法了，回到这个机器人系统的框架图，我们还会发现另外一个问题。 电脑B中的摇杆，要控制机器人运动，这两个节点岂不是应该有某种连接，比如摇杆节点发送一个速度指令给运动节点，收到后机器人开始运动。 同理，如果我们想要改变机器人的速度，负责配置参数的节点就得发送一个指令给运动节点，如果电脑B想要显示机器人看到的图像，电脑A中的摄像头节点就得把图像发送过来。 没错，在一个ROS机器人的系统中， 节点并不是孤立的，他们之间会有很多种机制保持联系 ，下一节，我们将给大家介绍这些机制中最为常用的一种。","text_tokens":["系统","很","多种","参数","实现","发送","机器人","回到","框架图","有","摄像","发现","比如","。","如果","下","将","某种","细胞","，","摇杆"," ","问题","之间","中","要","保持","a","另外","这些","和","介绍","这","收到","配置","最为","工作","这个","b","给","应该","显示","过来","机制","同理","控制","运动","把","想要","联系","电脑","机器","概念","一种","负责","并","岂","常用","的","一节","两个","我们","会","速度","现在","孤立","看到","熟悉","就","连接","开始","在","框架","改变","得","大家","ros","保持联系","了","一个","像头","摄像头","还会","节点","指令","后","方法","图像","不是","没错","他们"],"title":"思考题","title_tokens":["思考","考题","思考题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.3_%E8%8A%82%E7%82%B9/#_17","text":"https://docs.ros.org/en/humble/Tutorials/Understanding-ROS2-Nodes.html","text_tokens":["https","-","tutorials","en","docs","ros","understanding",".","humble","html","/",":","org","nodes","ros2"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/","text":"话题 节点实现了机器人各种各样的功能，但这些功能并不是独立的，之间会有千丝万缕的联系，其中最重要的一种联系方式就是话题，它是 节点间传递数据的桥梁 。 通信模型 以两个机器人节点为例。A节点的功能是驱动相机这个硬件设备，获取得到相机拍摄的图像信息，B节点的功能是视频监控，将相机拍摄到的图像实时显示给用户查看。 大家可以想一下，这两个节点是不是必然存在某种关系？没错，节点A要将获取的图像数据传输给节点B，有了数据，节点B才能做这样可视化的渲染。 此时从节点A到节点B传递图像数据的方式，在ROS中，我们就称之为 话题 ，它作为一个桥梁，实现了节点之间某一个方向上的数据传输。 发布/订阅模型 从话题本身的实现角度来看，使用了基于DDS的 发布/订阅模型 ，什么叫发布和订阅呢？ 话题数据传输的特性是从一个节点到另外一个节点，发送数据的对象称之为 发布者 ，接收数据的对象称之为 订阅者 ，每一个话题都需要有一个名字，传输的数据也需要有固定的数据类型。 打一个比方，大家平时应该也会看微信公众号，比如有一个公众号，它的名字叫做“古月居”，这个古月居就是话题名称，公众号的发布者是古月居的小编，他会把组织好的机器人知识排版成要求格式的公众号文章，发布出去，这个文章格式，就是话题的数据类型。如果大家对这个话题感兴趣，就可以订阅“古月居”，成为订阅者之后自然就可以收到古月居的公众号文章，没有订阅的话，也就无法收到。 类似这样的发布/订阅模型在生活中随处可见，比如订阅报纸、订阅杂志等等。 多对多通信 大家再仔细想下这些可以订阅的东西，是不是并不是唯一的，我们每个人可以订阅很多公众号、报纸、杂志，这些公众号、报纸、杂志也可以被很多人订阅，没错，ROS里的话题也是一样，发布者和订阅者的数量并不是唯一的，可以称之为是多对多的通信模型。 因为话题是多对多的模型，发布控制指令的摇杆可以有一个，也可以有2个、3个，订阅控制指令的机器人可以有1个，也可以有2个、3个，大家可以想象一下这个画面，似乎还是挺魔性的，如果存在多个发送指令的节点，建议大家要 注意区分优先级 ，不然机器人可能不知道该听谁的了。 异步通信 话题通信还有一个特性，那就是异步，这个词可能有同学是第一次听说？所谓异步，只要是指发布者发出数据后，并不知道订阅者什么时候可以收到，类似古月居公众号发布一篇文章，你什么时候阅读的，古月居根本不知道，报社发出一份报纸，你什么时候收到，报社也是不知道的。这就叫做异步。 异步的特性也让话题更适合用于一些周期发布的数据，比如传感器的数据，运动控制的指令等等，如果某些逻辑性较强的指令，比如修改某一个参数，用话题传输就不太合适了。 消息接口 最后，既然是数据传输，发布者和订阅者就得统一数据的描述格式，不能一个说英文，一个理解成了中文。在ROS中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念。比如这里的一个图像数据，就会包含图像的长宽像素值、每个像素的RGB等等，在ROS中都有标准定义。 消息是ROS中的一种接口定义方式 ，与编程语言无关，我们也可以通过 .msg 后缀的文件自行定义，有了这样的接口，各种节点就像积木块一样，通过各种各样的接口进行拼接，组成复杂的机器人系统。 案例一：Hello World话题通信 了解了话题的基本原理，接下来我们就要开始编写代码啦。 还是从Hello World例程开始，我们来创建一个发布者，发布话题“chatter”，周期发送“Hello World”这个字符串，消息类型是ROS中标准定义的String，再创建一个订阅者，订阅“chatter”这个话题，从而接收到“Hello World”这个字符串。 运行效果 启动第一个终端，运行话题的发布者节点： $ ros2 run learning_topic topic_helloworld_pub 启动第二个终端，运行话题的订阅者节点： $ ros2 run learning_topic topic_helloworld_sub 可以看到发布者循环发布“Hello World”字符串消息，订阅者也以几乎同样的频率收到该话题的消息数据。 发布者代码解析 我们来看下发布者的实现方法。 程序实现 learning_topic/topic_helloworld_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-发布“Hello World”话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . pub = self . create_publisher ( String , \"chatter\" , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . timer = self . create_timer ( 0.5 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） def timer_callback ( self ): # 创建定时器周期执行的回调函数 msg = String () # 创建一个String类型的消息对象 msg . data = 'Hello World' # 填充消息对象中的消息数据 self . pub . publish ( msg ) # 发布话题消息 self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) # 输出日志信息，提示已经完成话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = PublisherNode ( \"topic_helloworld_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , ], }, 流程总结 对以上程序进行分析，如果我们想要实现一个发布者，流程如下： 编程接口初始化 创建节点并初始化 创建发布者对象 创建并填充话题消息 发布话题消息 销毁节点并关闭接口 订阅者代码解析 我们再来看下订阅者的实现方法。 程序实现 learning_topic/topic_helloworld_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-订阅“Hello World”话题消息 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( \\ String , \"chatter\" , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'I heard: \" %s \"' % msg . data ) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"topic_helloworld_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , ], }, 流程总结 对以上程序进行分析，如果我们想要实现一个订阅者，流程如下： 编程接口初始化 创建节点并初始化 创建订阅者对象 回调函数处理话题数据 销毁节点并关闭接口 好啦，Hello World例程大家一定还不过瘾，接下来我们基于话题通信，继续优化下之前的机器视觉例程。 案例二：机器视觉识别 在节点概念的讲解过程中，我们通过一个节点驱动了相机，并且实现了对红色物体的识别。功能虽然没问题，但是对于机器人开发来讲，并没有做到程序的模块化，更好的方式是将相机驱动和视觉识别做成两个节点，节点间的联系就是这个图像数据，通过话题周期传输即可。 运行效果 这个图像消息在ROS中是标准定义好的，如果未来要更换另一个相机，只需要修改驱动节点，视觉识别节点完全是软件功能，就可以保持不变了，这种模块化的设计思想，可以更好的保证软件的可移植性。 好啦，说干就干，我们先来看下效果如何？ 启动两个终端，分别运行以下两个节点，第一个节点驱动相机并发布图像话题，第二个节点订阅图像话题并实现视觉识别。 $ ros2 run learning_topic topic_webcam_pub $ ros2 run learning_topic topic_webcam_sub 将红色物体放入相机范围内，即可看到识别效果。 发布者代码解析 learning_topic/topic_webcam_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-发布图像话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 \"\"\" 创建一个发布者节点 \"\"\" class ImagePublisher ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . publisher_ = self . create_publisher ( Image , 'image_raw' , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . timer = self . create_timer ( 0.1 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） self . cap = cv2 . VideoCapture ( 0 ) # 创建一个视频采集对象，驱动相机采集图像（相机设备号） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息 def timer_callback ( self ): ret , frame = self . cap . read () # 一帧一帧读取图像 if ret == True : # 如果图像读取成功 self . publisher_ . publish ( self . cv_bridge . cv2_to_imgmsg ( frame , 'bgr8' )) # 发布图像消息 self . get_logger () . info ( 'Publishing video frame' ) # 输出日志信息，提示已经完成图像话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImagePublisher ( \"topic_webcam_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , 'topic_webcam_pub = learning_topic.topic_webcam_pub:main' , ], }, 订阅者代码解析 learning_topic/topic_webcam_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-订阅图像话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 10 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"topic_webcam_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , 'topic_webcam_pub = learning_topic.topic_webcam_pub:main' , 'topic_webcam_sub = learning_topic.topic_webcam_sub:main' , ], }, 案例三：机器视觉识别优化 通过话题对原本节点功能的解耦，似乎让视觉识别的例程焕然一新了，不过似乎还有哪里不太对劲，大家有感觉到么？ ROS的目标不是提高软件复用率么，现在视觉识别的节点可以复用了，相机驱动节点好像不行呀，每换一个相机，是不是都得换一个驱动节点？这当然是不可能的！ 常用的usb相机驱动一般都是通用的，ROS中也集成了usb相机的标准驱动，我们只需要通过这样一行指令，就可以安装好，无论你用什么样的相机，只要符合usb接口协议，就可以直接使用ROS中的相机驱动节点，发布标准的图像话题了。 $ sudo apt install ros-humble-usb-cam 这样，我们的代码又得到了进一步精简，刚才自己写的图像发布节点换成了这样一句指令，视觉识别节点不需要做任何变化。 $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_topic topic_webcam_sub 话题命令行操作 话题命令的常用操作如下： $ ros2 topic list # 查看话题列表 $ ros2 topic info <topic_name> # 查看话题信息 $ ros2 topic hz <topic_name> # 查看话题发布频率 $ ros2 topic bw <topic_name> # 查看话题传输带宽 $ ros2 topic echo <topic_name> # 查看话题数据 $ ros2 topic pub <topic_name> <msg_type> <msg_data> # 发布话题消息 思考题 关于话题通信的原理和实现方法我们就讲到这里，给大家留一个思考题：话题通信的特性是单向传输，适合周期性的数据传递，对于一个复杂的机器人系统来讲，这种特性肯定无法满足所有数据传输的需求，大家是否能够举几个例子，是话题通信无法完成的呢？ 参考链接 https://docs.ros.org/en/humble/Tutorials/Topics/Understanding-ROS2-Topics.html","text_tokens":["人","公众","变化","”","到","coding","imgmsg","填充","<","com","二","之为","之后","callback","转换成","消息","但是","approx","方向","retr","有","数据结构","区分","subscription","比如","learning","不然","python","bw","设计","基于","比方","]","兴趣","/","实时","setup","通信","不变","哪里","了解","cv2","符合","出去","太","，","第二","库","in","摇杆"," ","订阅","topic","命令","接口","可以","要","org","a","ret","另外","积木","这些","import","下限","这里","无关","spin","对应","挺","进行","publishernode","带宽","考题","过程","给","同学","回调","显示","保证","像","都","cvbridge","进一步","未来","入口","点","第一次","不过","drawcontours","换","命令行","并且","出来","能够","例子","150","world","各种各样","msgs","\\","一种","定时器","范围","定义","hz","接收数据","mask","左上","图像处理","raw","该","的","方式","数量","编程语言","解析","关于","检测","秒","会","频率","imagepublisher","现在","字符串","坐标","执行","化成",")","用户","接下","waitkey","要求","此时","usr","流程","可视","名","1","同样","不知","感觉","数值","可见","就是","固定","父类","与","称之为","他会","讲","timer","想","xy","contours","是不是","格式","每","每换","？","查看","二个","处理","一个","publish","指令","上角","“","优先级","后","仔细","type","docs","逻辑","思考题","优先","监控","+","data","不能","才能","指","渲染","read","做到","再","更好","微信","参数","name","感器","词","rgb","。","各种","subscribernode","可移植","类似","node","一次","视觉","apt","需求","3","某些","启动","计算","链接","操作","to","啦","来看","来讲","sensor","多个","组成","lower","一新","视频","放入","之间","也","get","驱动","findcontours","开发","几乎","之前","控制指令","输出","x","和","的话","不太","understanding","长度","模型","上","）","color","宽","功能","通信模型","拼接","guyuehome","似乎","主","终端","_","}","continue","控制","编写","另",":","想要","#","180","名称","随处可见","角度","[","机器","存在","tutorials","int","感兴","通用","其中","每个","可移植性","-","原理","移植","所谓","包含","单向","语言","思考","并","是否","英文","接下来","128","代码","en","话题","做成","完全","想象","稍后","as","两个","移植性","知道","继续","通过","video",".","用于","init","已经","值","关系","里",">","定时","信息","文件","中是","满足","接口定义","看到","得到","bridge","因为","安装","在","开始",",","255","建议","如下","个","率","%","参考","太小","接收","噪声","刚才","ros","类","案例","publishing","可能","特性","销毁","虽然","listener","周期性","留","class","更","节点","及","0.5","时候","从而","思想","install","编程","数据类型","没有","并不知道","cap","不是","没错","最","各样","随处","后缀","env","usb","系统","就要","例程","10","chatter","一下","circle","成功","h","机器人","创建","object","标准","用","run","heard","知识","为","exe","下","std","东西","转化","打","本身","ros2","inrange","这种","某种","destroy","互相","发送数据","说","中","：","保持","不行","www","hello","所有","可视化","排版","去除","最后","程序实现","桥梁","写","w","cvtcolor","b","分别","像素","topics","既然","np","做","硬件","5","退出","对象","长宽","必然","字符","中文","函数","过瘾","某","数据","还有","物体","周期","复杂","焕然","把","接口协议","更换","基本原理","唯一","super","逻辑性","任何","__","只要","焕然一新","举","想下","console","0","dds","原本","一句","颜色","很多","你","chain","*","2","名字","呀","传递","编译","scripts","效果","发布者","提高","被","它","好像","utf","千丝","理解","!","异步","块","说明","html","https","y","合适","那","报社","0.1","、","等待","程序","独立","for","main","hierarchy","receiving","苹果","千丝万缕","这样","完成","if","阅读","得","以","pub","一般","万缕","shape","detect","msg","大家","软件","自然","已","采集","面积","重要","numpy","boundingrect","了","imagesubscriber","加入","么","什么样","points","注意","一","转换","@","第一","平时","修改","多","红色","(","中心","获取","列表","shutdown","进入","create","模块化","s","示例","初始","实现","发送","直接","成","转化成","较强","总结","py","（","什么","info","分析","bgr2hsv","使用","一步","第二个","是从","如果","一篇","勾勒","传递数据","发出","谁","一份","设备","三","自己","将","frame","打开","轮廓","所在","结构","居","python3","def","img","\"","相机","问题","rclpy","{","8","高","初始化","自行","list","描述","还","是","无法","当然","none","这","收到","配置","对于","循环","这个","一些","应该","提示","i","目标","小编","bin","二值化","集成","webcam","不","成为","self","协议","cam","helloworld","对","以上","解","videocapture","日志","humble","string","运动","publisher","array","号","在生活中","联系","来","呢","类型","适合","几个","模块","需要","点画","red","概念","报纸","联系方式","发布","画面","from","感兴趣","90","hsv","还是","讲解","bgr8","sudo","叫","复用","作者","优化","imshow","一行","内","常用","cv","说干就干","传感","$","选项","文章","上限","精简","只","以下","基本","下来","队列","拍摄","我们","关闭","'","左上角","即可","没","包","但","等等","单位","间","识别","一定","古月","upper","sub","就","image","看","cnt","换成","数据传输","无论","阈值","者","传感器","传输","entry","本原","杂志","为例","魔性","听","=","！","从","一帧","据传","又","听说","一样","肯定","生活","统一","设置","根本","args","组织","先","echo","叫做","如何","opencv","好","第一个","读取","运行","作为","对劲","耦","让","方法","图像","true","bgr","logger"],"title":"话题","title_tokens":["话题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_1","text":"节点实现了机器人各种各样的功能，但这些功能并不是独立的，之间会有千丝万缕的联系，其中最重要的一种联系方式就是话题，它是 节点间传递数据的桥梁 。","text_tokens":["其中","一种","这些","各样","是","千丝万缕","桥梁","实现","万缕","机器人","并","功能","有","就是","话题","最","传递","的","。","方式","各种","重要","了","它","数据","千丝","会","传递数据","节点","联系","但","机器","，","间","不是"," ","各种各样","独立","之间","联系方式"],"title":"话题","title_tokens":["话题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_2","text":"以两个机器人节点为例。A节点的功能是驱动相机这个硬件设备，获取得到相机拍摄的图像信息，B节点的功能是视频监控，将相机拍摄到的图像实时显示给用户查看。 大家可以想一下，这两个节点是不是必然存在某种关系？没错，节点A要将获取的图像数据传输给节点B，有了数据，节点B才能做这样可视化的渲染。 此时从节点A到节点B传递图像数据的方式，在ROS中，我们就称之为 话题 ，它作为一个桥梁，实现了节点之间某一个方向上的数据传输。","text_tokens":["才能","到","渲染","之为","一下","实现","机器人","方向","有","。","实时","设备","将","某种","，"," ","相机","视频","中","之间","可以","要","驱动","a","可视化","是","桥梁","这","上","这个","b","功能","给","做","硬件","显示","必然","某","数据","机器","存在","话题","传递","的","方式","两个","它","拍摄","我们","关系","信息","用户","此时","得到","可视","就","在","数据传输","这样","传输","以","大家","为例","ros","从","称之为","据传","想","是不是","了","？","查看","一个","节点","作为","图像","不是","没错","获取","监控"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_3","text":"从话题本身的实现角度来看，使用了基于DDS的 发布/订阅模型 ，什么叫发布和订阅呢？ 话题数据传输的特性是从一个节点到另外一个节点，发送数据的对象称之为 发布者 ，接收数据的对象称之为 订阅者 ，每一个话题都需要有一个名字，传输的数据也需要有固定的数据类型。 打一个比方，大家平时应该也会看微信公众号，比如有一个公众号，它的名字叫做“古月居”，这个古月居就是话题名称，公众号的发布者是古月居的小编，他会把组织好的机器人知识排版成要求格式的公众号文章，发布出去，这个文章格式，就是话题的数据类型。如果大家对这个话题感兴趣，就可以订阅“古月居”，成为订阅者之后自然就可以收到古月居的公众号文章，没有订阅的话，也就无法收到。 类似这样的发布/订阅模型在生活中随处可见，比如订阅报纸、订阅杂志等等。","text_tokens":["公众","”","到","随处","之为","之后","微信","实现","发送","机器人","有","成","比如","什么","。","使用","知识","基于","是从","比方","类似","如果","兴趣","/","打","本身","来看","出去","，","居"," ","发送数据","订阅","也","可以","另外","和","排版","的话","是","无法","模型","收到","这个","应该","小编","对象","成为","都","对","数据","把","号","在生活中","呢","类型","名称","随处可见","角度","机器","需要","感兴","报纸","发布","感兴趣","接收数据","叫","dds","名字","话题","的","文章","发布者","它","会","等等","、","要求","古月","就","看","数据传输","这样","者","传输","可见","大家","接收","杂志","自然","就是","固定","从","称之为","他会","据传","特性","生活","了","格式","每","？","一个","组织","叫做","节点","好","平时","“","数据类型","没有"],"title":"发布/订阅模型","title_tokens":["/","订阅","模型","发布"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_4","text":"大家再仔细想下这些可以订阅的东西，是不是并不是唯一的，我们每个人可以订阅很多公众号、报纸、杂志，这些公众号、报纸、杂志也可以被很多人订阅，没错，ROS里的话题也是一样，发布者和订阅者的数量并不是唯一的，可以称之为是多对多的通信模型。 因为话题是多对多的模型，发布控制指令的摇杆可以有一个，也可以有2个、3个，订阅控制指令的机器人可以有1个，也可以有2个、3个，大家可以想象一下这个画面，似乎还是挺魔性的，如果存在多个发送指令的节点，建议大家要 注意区分优先级 ，不然机器人可能不知道该听谁的了。","text_tokens":["人","公众","再","之为","一下","发送","机器人","有","区分","。","不然","如果","3","东西","谁","通信","，","摇杆","多个"," ","订阅","也","要","可以","这些","控制指令","和","是","挺","模型","这个","通信模型","似乎","不","对","控制","号","机器","唯一","存在","报纸","画面","发布","每个","还是","想下","并","很多","2","话题","该","的","想象","发布者","数量","被","我们","知道","里","、","因为","1","者","建议","个","大家","杂志","魔性","听","ros","称之为","可能","一样","是不是","了","一个","注意","指令","节点","优先级","仔细","不是","多","没错","优先"],"title":"多对多通信","title_tokens":["多","通信","对"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_5","text":"话题通信还有一个特性，那就是异步，这个词可能有同学是第一次听说？所谓异步，只要是指发布者发出数据后，并不知道订阅者什么时候可以收到，类似古月居公众号发布一篇文章，你什么时候阅读的，古月居根本不知道，报社发出一份报纸，你什么时候收到，报社也是不知道的。这就叫做异步。 异步的特性也让话题更适合用于一些周期发布的数据，比如传感器的数据，运动控制的指令等等，如果某些逻辑性较强的指令，比如修改某一个参数，用话题传输就不太合适了。","text_tokens":["公众","指","参数","有","感器","较强","词","用","比如","什么","。","类似","一次","一篇","如果","某些","发出","一份","通信","太","，","居"," ","订阅","也","可以","是","这","收到","这个","一些","同学","不","某","数据","还有","周期","控制","运动","号","第一次","适合","逻辑性","报纸","发布","只要","所谓","你","话题","传感","的","文章","发布者","知道","用于","异步","等等","合适","那","报社","古月","就","者","不知","传感器","阅读","传输","就是","可能","听说","特性","了","？","一个","根本","叫做","更","指令","时候","第一","修改","后","并不知道","让","逻辑"],"title":"异步通信","title_tokens":["通信","异步"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_6","text":"最后，既然是数据传输，发布者和订阅者就得统一数据的描述格式，不能一个说英文，一个理解成了中文。在ROS中，话题通信数据的描述格式称之为消息，对应编程语言中数据结构的概念。比如这里的一个图像数据，就会包含图像的长宽像素值、每个像素的RGB等等，在ROS中都有标准定义。 消息是ROS中的一种接口定义方式 ，与编程语言无关，我们也可以通过 .msg 后缀的文件自行定义，有了这样的接口，各种节点就像积木块一样，通过各种各样的接口进行拼接，组成复杂的机器人系统。","text_tokens":["不能","后缀","各样","系统","之为","消息","机器人","有","成","数据结构","标准","rgb","比如","。","各种","通信","结构","，"," ","组成","说","订阅","中","也","接口","可以","积木","这里","自行","和","描述","无关","最后","是","对应","进行","像素","既然","拼接","长宽","中文","像","都","数据","复杂","机器","各种各样","概念","发布","每个","一种","定义","包含","语言","英文","话题","的","方式","发布者","编程语言","我们","理解","会","通过",".","块","值","等等","文件","、","接口定义","就","在","数据传输","这样","者","传输","得","msg","ros","与","称之为","据传","一样","统一","格式","了","一个","节点","编程","图像"],"title":"消息接口","title_tokens":["接口","消息"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#hello-world","text":"了解了话题的基本原理，接下来我们就要开始编写代码啦。 还是从Hello World例程开始，我们来创建一个发布者，发布话题“chatter”，周期发送“Hello World”这个字符串，消息类型是ROS中标准定义的String，再创建一个订阅者，订阅“chatter”这个话题，从而接收到“Hello World”这个字符串。","text_tokens":["”","hello","开始","到","定义","就要","是","还是","例程","原理","再","者","chatter","消息","发送","这个","创建","本原","接下来","接收","代码","ros","标准","从","话题","的","。","字符","基本","了","下来","发布者","我们","一个","周期","编写","string","来","字符串","从而","了解","类型","“","基本原理","啦","，"," ","接下","world","订阅","中","发布"],"title":"案例一：Hello World话题通信","title_tokens":["hello"," ","案例","world","话题","一","：","通信"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_7","text":"启动第一个终端，运行话题的发布者节点： $ ros2 run learning_topic topic_helloworld_pub 启动第二个终端，运行话题的订阅者节点： $ ros2 run learning_topic topic_helloworld_sub 可以看到发布者循环发布“Hello World”字符串消息，订阅者也以几乎同样的频率收到该话题的消息数据。","text_tokens":["几乎","”","hello","同样","者","收到","以","pub","循环","消息","run","话题","$","learning","的","看到","终端","字符","该","。","发布者","_","第二个","二个","helloworld","一个","数据","频率","启动","节点","ros2","字符串","topic","第一个","第一","“","运行","，","第二"," ","world","订阅","：","也","可以","sub","发布"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_8","text":"我们来看下发布者的实现方法。","text_tokens":["发布者","来看","我们","实现","方法","下","的","。","发布"],"title":"发布者代码解析","title_tokens":["发布者","代码","解析","发布"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_9","text":"learning_topic/topic_helloworld_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-发布“Hello World”话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . pub = self . create_publisher ( String , \"chatter\" , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . timer = self . create_timer ( 0.5 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） def timer_callback ( self ): # 创建定时器周期执行的回调函数 msg = String () # 创建一个String类型的消息对象 msg . data = 'Hello World' # 填充消息对象中的消息数据 self . pub . publish ( msg ) # 发布话题消息 self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) # 输出日志信息，提示已经完成话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = PublisherNode ( \"topic_helloworld_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , ], },","text_tokens":["data","”","shutdown","coding","env","系统","create","填充","com","10","s","示例","初始","chatter","callback","消息","name","创建","py","（","learning","info","python","node","]","为","std","/","setup","ros2","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","topic","中","接口","get","：","{","8","import","www","hello","输出","初始化","spin","进行","none","长度","publishernode","配置","）","循环","功能","提示","bin","guyuehome","回调","退出","对象","主","字符","函数","_","}","self","helloworld","数据","入口","周期","日志","编写","string","点",":","publisher","#","类型","[","super","需要","world","msgs","发布","from","__","定时器","-","console","并","作者","*","代码","话题","的","选项","编译","scripts","发布者","队列","关闭","知道","utf","秒","'",".","!","已经","说明","init","字符串","包","执行","单位","定时","信息","文件",")","、","等待","程序","古月","usr",",","名","main","完成","如下","pub","%","entry","msg","=","类","父类","publishing","timer","销毁","加入","设置","一个","args","points","publish","class","节点","0.5","@","“","后","让","(","logger"],"title":"程序实现","title_tokens":["程序实现","程序","实现"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_10","text":"对以上程序进行分析，如果我们想要实现一个发布者，流程如下： 编程接口初始化 创建节点并初始化 创建发布者对象 创建并填充话题消息 发布话题消息 销毁节点并关闭接口","text_tokens":["初始化","填充","进行","初始","如下","消息","实现","并","创建","发布","话题","对象","分析","发布者","销毁","我们","如果","关闭","对","一个","以上","想要","节点","编程","，"," ","程序","：","接口","流程"],"title":"流程总结","title_tokens":["总结","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_11","text":"我们再来看下订阅者的实现方法。","text_tokens":["来看","我们","方法","下","再","者","订阅","的","。","实现"],"title":"订阅者代码解析","title_tokens":["订阅","者","代码","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_12","text":"learning_topic/topic_helloworld_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-订阅“Hello World”话题消息 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( \\ String , \"chatter\" , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'I heard: \" %s \"' % msg . data ) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"topic_helloworld_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , ], },","text_tokens":["data","”","shutdown","coding","env","系统","create","com","10","s","示例","初始","chatter","callback","消息","name","创建","标准","py","subscription","（","learning","info","python","subscribernode","heard","node","]","std","/","setup","ros2","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","订阅","topic","接口","get","：","{","8","import","www","hello","输出","初始化","spin","进行","none","长度","收到","配置","）","循环","功能","提示","i","bin","guyuehome","回调","退出","对象","主","函数","_","}","self","helloworld","对","数据","入口","日志","编写","string","点",":","#","类型","[","super","需要","world","msgs","\\","from","__","定义","-","console","并","作者","*","代码","话题","的","选项","编译","scripts","队列","关闭","知道","utf","'",".","!","说明","init","包","执行","信息","文件",")","、","等待","程序","古月","usr","sub",",","名","main","完成","者","如下","pub","%","entry","msg","=","类","父类","销毁","加入","处理","设置","一个","listener","args","points","class","节点","@","“","后","让","(","logger"],"title":"程序实现","title_tokens":["程序实现","程序","实现"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_13","text":"对以上程序进行分析，如果我们想要实现一个订阅者，流程如下： 编程接口初始化 创建节点并初始化 创建订阅者对象 回调函数处理话题数据 销毁节点并关闭接口 好啦，Hello World例程大家一定还不过瘾，接下来我们基于话题通信，继续优化下之前的机器视觉例程。","text_tokens":["之前","hello","初始化","还","进行","例程","者","初始","如下","实现","并","创建","接下来","大家","优化","回调","话题","对象","的","分析","视觉","。","函数","不","下来","基于","销毁","过瘾","我们","如果","处理","对","关闭","一个","数据","以上","继续","下","一定","通信","想要","节点","好","啦","编程","，","机器"," ","world","程序","接下","订阅","：","接口","流程"],"title":"流程总结","title_tokens":["总结","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_14","text":"在节点概念的讲解过程中，我们通过一个节点驱动了相机，并且实现了对红色物体的识别。功能虽然没问题，但是对于机器人开发来讲，并没有做到程序的模块化，更好的方式是将相机驱动和视觉识别做成两个节点，节点间的联系就是这个图像数据，通过话题周期传输即可。","text_tokens":["在","和","模块化","是","做到","讲解","更好","对于","传输","但是","实现","机器人","并","这个","过程","功能","就是","话题","的","。","方式","做成","了","两个","视觉","我们","对","虽然","一个","数据","物体","通过","周期","即可","节点","联系","将","没","来讲","没有","并且","，","机器","模块","间","图像","红色","识别","相机","问题","程序","中","概念","驱动","开发"],"title":"案例二：机器视觉识别","title_tokens":["视觉","机器","识别","案例","二","："]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_15","text":"这个图像消息在ROS中是标准定义好的，如果未来要更换另一个相机，只需要修改驱动节点，视觉识别节点完全是软件功能，就可以保持不变了，这种模块化的设计思想，可以更好的保证软件的可移植性。 好啦，说干就干，我们先来看下效果如何？ 启动两个终端，分别运行以下两个节点，第一个节点驱动相机并发布图像话题，第二个节点订阅图像话题并实现视觉识别。 $ ros2 run learning_topic topic_webcam_pub $ ros2 run learning_topic topic_webcam_sub 将红色物体放入相机范围内，即可看到识别效果。","text_tokens":["模块化","更好","消息","实现","标准","run","learning","。","可移植","第二个","设计","视觉","如果","下","不变","启动","ros2","将","这种","啦","来看","，","第二"," ","相机","放入","订阅","topic","可以","驱动","要","保持","是","这个","分别","功能","保证","终端","webcam","_","未来","物体","另","更换","模块","需要","发布","范围","定义","可移植性","移植","并","内","说干就干","话题","$","的","完全","效果","只","以下","两个","移植性","我们","即可","中是","识别","看到","sub","就","在","pub","软件","ros","了","？","二个","一个","先","如何","节点","好","思想","第一","第一个","修改","运行","图像","红色"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_16","text":"learning_topic/topic_webcam_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-发布图像话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 \"\"\" 创建一个发布者节点 \"\"\" class ImagePublisher ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . publisher_ = self . create_publisher ( Image , 'image_raw' , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . timer = self . create_timer ( 0.1 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） self . cap = cv2 . VideoCapture ( 0 ) # 创建一个视频采集对象，驱动相机采集图像（相机设备号） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息 def timer_callback ( self ): ret , frame = self . cap . read () # 一帧一帧读取图像 if ret == True : # 如果图像读取成功 self . publisher_ . publish ( self . cv_bridge . cv2_to_imgmsg ( frame , 'bgr8' )) # 发布图像消息 self . get_logger () . info ( 'Publishing video frame' ) # 输出日志信息，提示已经完成图像话题发布 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImagePublisher ( \"topic_webcam_pub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , 'topic_webcam_pub = learning_topic.topic_webcam_pub:main' , ], },","text_tokens":["shutdown","coding","env","imgmsg","系统","create","read","com","10","示例","初始","callback","转换成","消息","成功","name","创建","py","（","learning","info","python","node","]","为","如果","/","setup","设备","ros2","将","frame","打开","to","cv2","库","sensor","，","居","python3","def","destroy"," ","\"","相机","视频","rclpy","topic","get","接口","驱动","：","{","8","ret","import","www","输出","初始化","spin","进行","none","长度","配置","）","循环","功能","提示","bin","guyuehome","回调","退出","对象","主","webcam","函数","_","}","cvbridge","self","helloworld","入口","周期","videocapture","日志","编写","点",":","publisher","号","#","类型","[","super","需要","msgs","发布","from","__","定时器","-","bgr8","console","0","图像处理","并","作者","raw","*","代码","cv","话题","的","选项","编译","稍后","scripts","发布者","队列","关闭","知道","utf","秒","'","video",".","!","用于","init","说明","imagepublisher","已经","包","执行","单位","0.1","定时","信息","文件",")","、","等待","程序","古月","usr","bridge","sub","image",",","名","main","换成","完成","if","如下","pub","entry","msg","=","ros","类","父类","与","采集","publishing","一帧","timer","销毁","加入","处理","设置","一个","args","points","publish","转换","class","节点","opencv","@","读取","后","让","cap","图像","(","true","logger"],"title":"发布者代码解析","title_tokens":["发布者","代码","解析","发布"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_17","text":"learning_topic/topic_webcam_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2话题示例-订阅图像话题 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 10 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"topic_webcam_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'topic_helloworld_pub = learning_topic.topic_helloworld_pub:main' , 'topic_helloworld_sub = learning_topic.topic_helloworld_sub:main' , 'topic_webcam_pub = learning_topic.topic_webcam_pub:main' , 'topic_webcam_sub = learning_topic.topic_webcam_sub:main' , ], },","text_tokens":["data","shutdown","coding","进入","env","imgmsg","系统","create","<","com","10","示例","初始","circle","callback","消息","name","approx","h","创建","retr","object","转化成","logger","py","subscription","（","learning","info","bgr2hsv","python","使用","node","]","为","勾勒","转化","/","setup","计算","ros2","inrange","将","frame","打开","to","cv2","轮廓","所在","库","sensor","，","居","python3","def","互相"," ","\"","lower","img","in","rclpy","订阅","topic","接口","findcontours","中","get","8","：","{","import","www","下限","x","初始化","list","和","高","输出","去除","spin","进行","none","长度","w","cvtcolor","模型","配置","）","循环","color","宽","像素","功能","一些","np","提示","bin","guyuehome","5","回调","二值化","对象","显示","主","退出","webcam","函数","_","destroy","}","cvbridge","self","helloworld","入口","continue","日志","编写","点",":","array","drawcontours","#","类型","180","[","出来","super","150","需要","int","点画","red","msgs","90","from","__","范围","-","hsv","bgr8","console","mask","左上","0","图像处理","并","作者","颜色","raw","chain","128","*","2","代码","imshow","cv","话题","的","选项","编译","scripts","as","上限","效果","队列","关闭","检测","utf","知道","'","video",".","!","左上角","用于","说明","init","y","坐标","包","化成","信息","文件",")","、","waitkey","等待","程序","upper","古月","usr","for","bridge","sub","得到","cnt","image",",","255","名","hierarchy","1","receiving","main","苹果","阈值","完成","者","if","如下","pub","shape","数值","detect","entry","太小","msg","噪声","=","ros","类","父类","与","从","已","面积","numpy","boundingrect","contours","xy","imagesubscriber","销毁","加入","处理","设置","一个","listener","args","points","转换","class","节点","opencv","上角","及","@","后","让","图像","红色","(","中心","bgr","+"],"title":"订阅者代码解析","title_tokens":["订阅","者","代码","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_18","text":"通过话题对原本节点功能的解耦，似乎让视觉识别的例程焕然一新了，不过似乎还有哪里不太对劲，大家有感觉到么？ ROS的目标不是提高软件复用率么，现在视觉识别的节点可以复用了，相机驱动节点好像不行呀，每换一个相机，是不是都得换一个驱动节点？这当然是不可能的！ 常用的usb相机驱动一般都是通用的，ROS中也集成了usb相机的标准驱动，我们只需要通过这样一行指令，就可以安装好，无论你用什么样的相机，只要符合usb接口协议，就可以直接使用ROS中的相机驱动节点，发布标准的图像话题了。 $ sudo apt install ros-humble-usb-cam 这样，我们的代码又得到了进一步精简，刚才自己写的图像发布节点换成了这样一句指令，视觉识别节点不需要做任何变化。 $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_topic topic_webcam_sub","text_tokens":["变化","到","usb","例程","直接","有","标准","用","run","learning","什么","。","使用","一步","node","视觉","apt","exe","自己","ros2","符合","，"," ","哪里","一新","相机","中","也","接口","驱动","可以","不行","topic","不太","是","写","当然","这","功能","目标","做","似乎","集成","webcam","不","_","都","协议","cam","进一步","对","还有","解","humble","焕然","接口协议","不过","换","需要","通用","发布","任何","只要","焕然一新","-","sudo","原本","复用","一句","你","代码","一行","呀","常用","话题","$","的","精简","只","提高","好像","我们","通过","现在","识别","得到","sub","就","安装","换成","无论","这样","得","一般","感觉","率","大家","软件","刚才","ros","！","又","可能","是不是","了","每换","？","么","一个","什么样","节点","指令","好","install","对劲","耦","让","图像","不是"],"title":"案例三：机器视觉识别优化","title_tokens":["：","视觉","优化","机器","识别","案例","三"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_19","text":"话题命令的常用操作如下： $ ros2 topic list # 查看话题列表 $ ros2 topic info <topic_name> # 查看话题信息 $ ros2 topic hz <topic_name> # 查看话题发布频率 $ ros2 topic bw <topic_name> # 查看话题传输带宽 $ ros2 topic echo <topic_name> # 查看话题数据 $ ros2 topic pub <topic_name> <msg_type> <msg_data> # 发布话题消息","text_tokens":["列表","：","data","list","hz","<","传输","如下","pub","消息","带宽","name","msg","常用","话题","$","info","的","bw","_","查看","数据","频率","echo","ros2","#","操作",">","信息","type"," ","命令","topic","发布"],"title":"话题命令行操作","title_tokens":["命令","命令行","操作","话题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_20","text":"关于话题通信的原理和实现方法我们就讲到这里，给大家留一个思考题：话题通信的特性是单向传输，适合周期性的数据传递，对于一个复杂的机器人系统来讲，这种特性肯定无法满足所有数据传输的需求，大家是否能够举几个例子，是话题通信无法完成的呢？","text_tokens":["就","所有","到","这里","和","系统","举","数据传输","是","无法","完成","原理","传输","对于","单向","实现","思考","考题","机器人","给","是否","大家","话题","传递","讲","的","据传","肯定","特性","需求","关于","我们","？","一个","数据","周期","周期性","复杂","留","通信","这种","呢","来讲","适合","几个","方法","，","机器","能够","满足","例子","：","思考题"],"title":"思考题","title_tokens":["思考","考题","思考题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.4_%E8%AF%9D%E9%A2%98/#_21","text":"https://docs.ros.org/en/humble/Tutorials/Topics/Understanding-ROS2-Topics.html","text_tokens":["https","topics","-","tutorials","en","docs","ros","understanding",".","humble","html","/",":","org","ros2"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/","text":"服务 话题通信可以实现多个ROS节点之间数据的单向传输，使用这种异步通信机制，发布者无法准确知道订阅者是否收到消息，本讲我们将一起学习ROS另外一种常用的通信方法—— 服务 ，可以实现类似 你问我答的同步通信 效果。 通信模型 在之前的课程中，我们通过一个节点驱动相机，发布图像话题，另外一个节点订阅图像话题，并实现对其中红色物体的识别，此时我们可以按照图像识别的频率，周期得到物体的位置。 这个位置信息可以继续发给机器人的上层应用使用，比如可以跟随目标运动，或者运动到目标位置附近。此时，我们并不需要这么高的频率一直订阅物体的位置，而是更希望在需要这个数据的时候，发一个查询的请求，然后尽快得到此时目标的最新位置。 这样的通信模型和话题单向传输有所不同，变成了发送一个请求，反馈一个应答的形式，好像是你问我答一样，这种通信机制在ROS中成为 服务，Service 。 客户端/服务器模型 从服务的实现机制上来看，这种你问我答的形式叫做 客户端/服务器模型 ，简称为CS模型，客户端在需要某些数据的时候，针对某个具体的服务，发送请求信息，服务器端收到请求之后，就会进行处理并反馈应答信息。 这种通信机制在生活中也很常见，比如我们经常浏览的各种网页，此时你的电脑浏览器就是客户端，通过域名或者各种操作，向网站服务器发送请求，服务器收到之后返回需要展现的页面数据。 同步通信 这个过程一般要求越快越好，假设服务器半天没有反应，你的浏览器一直转圈圈，那有可能是服务器宕机了，或者是网络不好，所以相比话题通信，在服务通信中，客户端可以通过接收到的应答信息，判断服务器端的状态，我们也称之为同步通信。 一对多通信 比如古月居这个网站，服务器是唯一存在的，并没有多个完全一样的古月居网站，但是可以访问古月居网站的客户端是不唯一的，大家每一个人都可以看到同样的界面。所以服务通信模型中，服务器端唯一，但客户端可以不唯一。 服务接口 和话题通信类似，服务通信的核心还是要传递数据，数据变成了两个部分，一个 请求的数据 ，比如请求苹果位置的命令，还有一个 反馈的数据 ，比如反馈苹果坐标位置的数据，这些数据和话题消息一样，在ROS中也是要标准定义的，话题使用.msg文件定义，服务使用的是.srv文件定义，后续我们会给大家介绍定义的方法。 案例一：加法求解器 大家现在对ROS服务通信应该有了基本了解，接下来我们就要开始编写代码啦。还是从一个相对简单的例程开始，也是ROS官方的一个例程，通过服务实现一个加法求解器的功能。 当我们需要计算两个加数的求和结果时，就通过客户端节点，将两个加数封装成请求数据，针对服务“add_two_ints”发送出去，提供这个服务的服务器端节点，收到请求数据后，开始进行加法计算，并将求和结果封装成应答数据，反馈给客户端，之后客户端就可以得到想要的结果啦。 运行效果 我们一起操作下这个例程，并且看下代码的实现原理。 启动两个终端，并运行如下节点，第一个节点是服务端，等待请求数据并提供求和功能，第二个节点是客户端，发送传入的两个加数并等待求和结果。 $ ros2 run learning_service service_adder_server $ ros2 run learning_service service_adder_client 2 3 客户端代码解析 我们来看下客户端的实现方法。 程序实现 learning_service/service_adder_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-发送两个加数，请求加法器计算 \"\"\" import sys import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( AddTwoInts , 'add_two_ints' ) # 创建服务客户端对象（服务接口类型，服务名） while not self . client . wait_for_service ( timeout_sec = 1.0 ): # 循环等待服务器端成功启动 self . get_logger () . info ( 'service not available, waiting again...' ) self . request = AddTwoInts . Request () # 创建服务请求的数据对象 def send_request ( self ): # 创建一个发送服务请求的函数 self . request . a = int ( sys . argv [ 1 ]) self . request . b = int ( sys . argv [ 2 ]) self . future = self . client . call_async ( self . request ) # 异步方式发送服务请求 def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = adderClient ( \"service_adder_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () # 发送服务请求 while rclpy . ok (): # ROS2系统正常运行 rclpy . spin_once ( node ) # 循环执行一次节点 if node . future . done (): # 数据是否处理完成 try : response = node . future . result () # 接收服务器端的反馈数据 except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( # 将收到的反馈信息打印输出 'Result of add_two_ints: for %d + %d = %d ' % ( node . request . a , node . request . b , response . sum )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , ], }, 流程总结 对以上程序进行分析，如果我们想要实现一个客户端，流程如下： 编程接口初始化 创建节点并初始化 创建客户端对象 创建并发送请求数据 等待服务器端应答数据 销毁节点并关闭接口 服务端代码解析 至于服务器端的实现，有点类似话题通信中的订阅者，并不知道请求数据什么时间出现，也用到了回调函数机制。 程序实现 learning_service/service_adder_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供加法器的服务器处理功能 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderServer ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . srv = self . create_service ( AddTwoInts , 'add_two_ints' , self . adder_callback ) # 创建服务器对象（接口类型、服务名、服务器回调函数） def adder_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 response . sum = request . a + request . b # 完成加法求和计算，将结果放到反馈的数据中 self . get_logger () . info ( 'Incoming request \\n a: %d b: %d ' % ( request . a , request . b )) # 输出日志信息，提示已经完成加法求和计算 return response # 反馈应答信息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = adderServer ( \"service_adder_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_server = learning_service.service_adder_server:main' , 'service_adder_server = learning_service.service_adder_server:main' , ], }, 流程总结 对以上程序进行分析，如果我们想要实现一个服务端，流程如下： 编程接口初始化 创建节点并初始化 创建服务器端对象 通过回调函数处进行服务 向客户端反馈应答结果 销毁节点并关闭接口 案例二：机器视觉识别 好啦，加法求解器已经实现了，回想下刚才我们提到的视觉识别流程，当我们需要知道目标物体位置的时候，通过服务通信的机制，岂不是更加合理。 运行效果 此时会有三个节点出现： 相机驱动节点 ，发布图像数据； 视觉识别节点 ，订阅图像数据，并且集成了一个服务器端对象，随时准备提供目标位置； 客户端节点 ，我们可以认为是一个机器人目标跟踪的节点，当需要根据目标运动时，就发送一次请求，然后拿到一个当前的目标位置。 启动三个终端，分别运行上述三个节点： $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_service service_object_server $ ros2 run learning_service service_object_client 客户端代码解析 learning_service/service_object_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-请求目标识别，等待目标位置应答 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 class objectClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( GetObjectPosition , 'get_target_position' ) while not self . client . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . request = GetObjectPosition . Request () def send_request ( self ): self . request . get = True self . future = self . client . call_async ( self . request ) def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = objectClient ( \"service_object_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () while rclpy . ok (): rclpy . spin_once ( node ) if node . future . done (): try : response = node . future . result () except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( 'Result of object position: \\n x: %d y: %d ' % ( response . x , response . y )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , 'service_adder_server = learning_service.service_adder_server:main' , 'service_object_client = learning_service.service_object_client:main' , ], }, 服务端代码解析 learning_service/service_object_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供目标识别服务 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 import numpy as np # Python数值计算库 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . srv = self . create_service ( GetObjectPosition , # 创建服务器对象（接口类型、服务名、服务器回调函数） 'get_target_position' , self . object_position_callback ) self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def object_position_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 if request . get == True : response . x = self . objectX # 目标物体的XY坐标 response . y = self . objectY self . get_logger () . info ( 'Object position \\n x: %d y: %d ' % ( response . x , response . y )) # 输出日志信息，提示已经反馈 else : response . x = 0 response . y = 0 self . get_logger () . info ( 'Invalid command' ) # 输出日志信息，提示已经反馈 return response def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"service_object_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , 'service_adder_server = learning_service.service_adder_server:main' , 'service_object_client = learning_service.service_object_client:main' , 'service_object_server = learning_service.service_object_server:main' , ], }, 服务命令行操作 服务命令的常用操作如下： $ ros2 service list # 查看服务列表 $ ros2 service type <service_name> # 查看服务数据类型 $ ros2 service call <service_name> <service_type> <service_data> # 发送服务请求 思考题 话题和服务是ROS中最为常用的两种数据通信方法，前者适合传感器、控制指令等周期性、单向传输的数据，后者适合一问一答，同步性要求更高的数据，比如获取机器视觉识别到的目标位置。 在机器人开发过程中，类似的通信应用比比皆是，ROS针对绝大部分通用场景，都设计了标准的话题和服务数据类型，比如图像数据、雷达数据、里程计数据等等，不过机器人软硬件繁杂，很多时候这些标准定义也无法满足我们的需求，这个时候，我们就要自定义通信接口了。 参考链接 https://docs.ros.org/en/ humble /Tutorials/Services/Understanding-ROS2-Services.html","text_tokens":["人","”","到","coding","waiting","imgmsg","<","com","尽快","二","之后","之为","一起","callback","消息","但是","srv","—","更加","approx","retr","有","objecty","subscription","比如","learning","python","宕机","设计","]","页面","/","setup","通信","了解","cv2","50","出去","库","，","第二","in"," ","订阅","命令","org","接口","可以","要","a","课程","另外","import","这些","下限","大部分","一直","spin","进行","发","考题","拿到","过程","给","处","当前","回调","请求","cs","显示","都","cvbridge","数据通信","入口","附近","sec","点","出现","不过","drawcontours","命令行","求和","并且","出来","150","msgs","形式","\\","一种","范围","软硬件","定义","two","adderclient","n","addtwoints","mask","左上","图像处理","raw","后续","越快","封装","网站","的","方式","return","解析","检测","等","认为","会","try","频率","一问一答","现在","坐标","执行","化成","本",")","接下","waitkey","要求","此时","usr","else","流程","希望","名","三个","同样","1","request","不知","准备","client","不同","数值","越好","准确","r","就是","常见","父类","与","判断","根据","称之为","讲","xy","contours","每","自定义","处理","二个","查看","一对","一个","两种","界面","结果","指令","上角","软硬","“","域名","后","上层","type","docs","思考题","+","data","incoming","返回","同步性","name","绝大","转圈","感器","正常","放到","变成","。","各种","类似","node","一次","视觉","学习","需求","3","反馈","interface","某些","器","启动","async","计算","状态","链接","...","操作","to","啦","来看","向","sensor","多个","lower","之间","也","应答","驱动","get","findcontours","开发","之前","；","控制指令","输出","当","x","和","介绍","服务","understanding","长度","模型","上","add","）","color","宽","功能","通信模型","guyuehome","客户","主","future","时","终端","有所不同","_","}","adder","continue","sum","发给","编写","控制",":","想要","自定","接口类型","#","except","180","比比皆是","电脑","[","机器","存在","tutorials","int","通信接口","服务器发送","通用","其中","position","-","半天","1.0","原理","单向","思考","并","是否","接下来","128","代码","传入","en","话题","完全","as","两个","知道","argv","继续","通过","video",".","target","已经","init","用于","command","send","exception","比比",">","信息","文件","满足","看到","求解","得到","bridge","随时","在","开始",",","255","加数","如下","图像识别","%","参考","太小","网络","接收","问","刚才","噪声","ros","类","案例","可能","销毁","listener","周期性","class","更","节点","及","时候","编程","数据类型","没有","并不知道","不是","response","用到","usb","env","系统","就要","例程","10","services","然后","circle","成功","call","法器","机器人","h","创建","result","object","标准","run","时间","为","exe","下","of","转化","雷达","简称","ros2","e","inrange","这种","destroy","互相","中","：","官方","www","去除","前者","程序实现","w","cvtcolor","应用","b","分别","像素","np","同步","again","硬件","5","转圈圈","退出","对象","ints","break","函数","有所","所以","数据","物体","还有","周期","服务器端","接口类","相对","这么","具体","经常","唯一","super","提供","__","console","not","反应","0","wait","颜色","很多","你","chain","而是","岂","*","2","后者","传递","编译","scripts","效果","发布者","好像","service","utf","并不需要","合理","!","异步","说明","html","https","y","、","等待","程序","for","客户端","位置","main","hierarchy","receiving","查询","苹果","这样","once","完成","打印输出","if","一般","有点","shape","detect","msg","大家","sys","越快越好","已","面积","numpy","boundingrect","核心","回想","了","imagesubscriber","加入","繁杂","答","points","圈圈","一","转换","getobjectposition","服务端","@","第一","展现","红色","多","(","中心","获取","列表","shutdown","进入","available","create","很","server","示例","初始","实现","发送","访问","里程","提到","成","转化成","总结","py","（","info","分析","什么","bgr2hsv","使用","objectx","第二个","如果","勾勒","大部","不好","传递数据","简单","将","frame","打开","轮廓","所在","居","python3","def","img","假设","\"","相机","那有","rclpy","{","加法","8","高","初始化","list","是","无法","none","收到","配置","最为","循环","while","这个","一些","相比","应该","提示","目标","bin","上述","打印","二值化","集成","机制","不","成为","跟踪","self","cam","对","以上","服务器","日志","humble","运动","array","在生活中","里程计","类型","适合","需要","浏览器","点画","red","发布","90","from","hsv","还是","浏览","failed","bgr8","务器","某个","作者","数据通","imshow","timeout","常用","cv","或者","$","传感","选项","上限","基本","下来","队列","我们","关闭","'","左上角","部分","最新","针对","包","但","等等","我","识别","upper","古月","sub","跟随","就","image","看","cnt","objectclient","阈值","者","传感器","传输","d","entry","网页","=","从","一样","adderserver","生活","场景","绝大部分","至于","设置","args","ok","按照","叫做","opencv","invalid","好","第一个","done","运行","让","方法","图像","加法器","true","bgr","logger"],"title":"服务","title_tokens":["服务"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_1","text":"话题通信可以实现多个ROS节点之间数据的单向传输，使用这种异步通信机制，发布者无法准确知道订阅者是否收到消息，本讲我们将一起学习ROS另外一种常用的通信方法—— 服务 ，可以实现类似 你问我答的同步通信 效果。","text_tokens":["另外","一种","无法","服务","者","传输","收到","单向","一起","消息","实现","—","是否","你","准确","问","同步","常用","ros","话题","机制","的","讲","。","使用","效果","发布者","类似","知道","我们","学习","答","数据","异步","节点","通信","将","这种","，","方法","我","多个","本"," ","订阅","之间","可以","发布"],"title":"服务","title_tokens":["服务"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_2","text":"在之前的课程中，我们通过一个节点驱动相机，发布图像话题，另外一个节点订阅图像话题，并实现对其中红色物体的识别，此时我们可以按照图像识别的频率，周期得到物体的位置。 这个位置信息可以继续发给机器人的上层应用使用，比如可以跟随目标运动，或者运动到目标位置附近。此时，我们并不需要这么高的频率一直订阅物体的位置，而是更希望在需要这个数据的时候，发一个查询的请求，然后尽快得到此时目标的最新位置。 这样的通信模型和话题单向传输有所不同，变成了发送一个请求，反馈一个应答的形式，好像是你问我答一样，这种通信机制在ROS中成为 服务，Service 。","text_tokens":["到","然后","尽快","实现","发送","机器人","变成","比如","。","使用","反馈","通信","这种","，"," ","相机","订阅","中","应答","可以","驱动","之前","课程","另外","高","和","一直","是","服务","发","模型","应用","这个","通信模型","目标","请求","机制","有所不同","有所","成为","对","数据","物体","周期","发给","附近","运动","这么","机器","需要","形式","发布","其中","单向","并","你","而是","话题","或者","的","我们","好像","service","并不需要","继续","通过","频率","最新","我","信息","识别","此时","得到","跟随","在","希望","位置","查询","这样","传输","图像识别","不同","问","ros","一样","了","答","一个","按照","更","节点","时候","图像","上层","红色"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_3","text":"从服务的实现机制上来看，这种你问我答的形式叫做 客户端/服务器模型 ，简称为CS模型，客户端在需要某些数据的时候，针对某个具体的服务，发送请求信息，服务器端收到请求之后，就会进行处理并反馈应答信息。 这种通信机制在生活中也很常见，比如我们经常浏览的各种网页，此时你的电脑浏览器就是客户端，通过域名或者各种操作，向网站服务器发送请求，服务器收到之后返回需要展现的页面数据。","text_tokens":["就","客户端","在","很","服务","进行","浏览","返回","务器","模型","上","收到","之后","某个","实现","发送","并","你","问","网页","就是","网站","常见","从","客户","cs","请求","机制","的","。","比如","各种","或者","生活","我们","为","处理","答","数据","服务器","会","通过","服务器端","反馈","某些","/","叫做","页面","具体","通信","在生活中","简称","时候","针对","这种","操作","域名","来看","电脑","向","展现","，","我","信息","经常","需要"," ","浏览器","此时","也","应答","形式","服务器发送"],"title":"客户端/服务器模型","title_tokens":["客户端","模型","服务","服务器","客户","务器","/"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_4","text":"这个过程一般要求越快越好，假设服务器半天没有反应，你的浏览器一直转圈圈，那有可能是服务器宕机了，或者是网络不好，所以相比话题通信，在服务通信中，客户端可以通过接收到的应答信息，判断服务器端的状态，我们也称之为同步通信。","text_tokens":["在","客户端","到","那有","一直","半天","是","服务","浏览","务器","之为","反应","一般","这个","过程","你","转圈","越好","相比","越快","网络","接收","同步","越快越好","转圈圈","客户","话题","或者","判断","称之为","的","。","可能","宕机","了","所以","我们","不好","服务器","通过","圈圈","服务器端","通信","状态","没有","，","信息","假设","浏览器","要求","中","也","应答","可以"],"title":"同步通信","title_tokens":["通信","同步"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_5","text":"比如古月居这个网站，服务器是唯一存在的，并没有多个完全一样的古月居网站，但是可以访问古月居网站的客户端是不唯一的，大家每一个人都可以看到同样的界面。所以服务通信模型中，服务器端唯一，但客户端可以不唯一。","text_tokens":["人","客户端","同样","是","服务","务器","模型","但是","访问","这个","并","通信模型","大家","网站","客户","比如","的","看到","。","完全","一样","中","不","所以","都","每","一个","服务器","服务器端","界面","通信","但","没有","，","唯一","居","存在","多个","古月","可以"],"title":"一对多通信","title_tokens":["多","通信","一对"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_6","text":"和话题通信类似，服务通信的核心还是要传递数据，数据变成了两个部分，一个 请求的数据 ，比如请求苹果位置的命令，还有一个 反馈的数据 ，比如反馈苹果坐标位置的数据，这些数据和话题消息一样，在ROS中也是要标准定义的，话题使用.msg文件定义，服务使用的是.srv文件定义，后续我们会给大家介绍定义的方法。","text_tokens":["这些","在","定义","和","位置","介绍","苹果","是","服务","还是","消息","srv","给","后续","msg","大家","ros","变成","标准","话题","请求","传递","比如","的","。","使用","一样","核心","类似","了","两个","我们","数据","一个","还有","传递数据","会","反馈",".","部分","通信","坐标","，","方法","文件"," ","命令","中","也","要"],"title":"服务接口","title_tokens":["服务","接口"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_7","text":"大家现在对ROS服务通信应该有了基本了解，接下来我们就要开始编写代码啦。还是从一个相对简单的例程开始，也是ROS官方的一个例程，通过服务实现一个加法求解器的功能。 当我们需要计算两个加数的求和结果时，就通过客户端节点，将两个加数封装成请求数据，针对服务“add_two_ints”发送出去，提供这个服务的服务器端节点，收到请求数据后，开始进行加法计算，并将求和结果封装成应答数据，反馈给客户端，之后客户端就可以得到想要的结果啦。","text_tokens":["”","就要","例程","之后","实现","发送","有","成","。","简单","反馈","器","通信","计算","将","了解","啦","出去","，"," ","也","应答","官方","可以","加法","当","是","服务","进行","收到","add","这个","功能","给","应该","客户","请求","时","ints","_","对","数据","服务器","服务器端","编写","相对","想要","求和","需要","提供","two","还是","务器","并","接下来","封装","代码","的","基本","下来","两个","我们","通过","现在","针对","接下","求解","得到","就","客户端","开始","加数","大家","ros","从","了","一个","结果","节点","“","后"],"title":"案例一：加法求解器","title_tokens":["器","案例","一","：","求解","加法"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_8","text":"我们一起操作下这个例程，并且看下代码的实现原理。 启动两个终端，并运行如下节点，第一个节点是服务端，等待请求数据并提供求和功能，第二个节点是客户端，发送传入的两个加数并等待求和结果。 $ ros2 run learning_service service_adder_server $ ros2 run learning_service service_adder_client 2 3","text_tokens":["看","客户端","是","服务","例程","原理","加数","server","如下","一起","client","实现","发送","这个","并","功能","2","代码","传入","run","客户","请求","$","learning","的","。","终端","两个","第二个","_","adder","我们","二个","service","一个","数据","下","3","结果","启动","节点","ros2","服务端","操作","第一","第一个","运行","求和","并且","，","第二","提供"," ","等待"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_9","text":"我们来看下客户端的实现方法。","text_tokens":["客户端","来看","我们","方法","下","客户","的","。","实现"],"title":"客户端代码解析","title_tokens":["代码","客户端","客户","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_10","text":"learning_service/service_adder_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-发送两个加数，请求加法器计算 \"\"\" import sys import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( AddTwoInts , 'add_two_ints' ) # 创建服务客户端对象（服务接口类型，服务名） while not self . client . wait_for_service ( timeout_sec = 1.0 ): # 循环等待服务器端成功启动 self . get_logger () . info ( 'service not available, waiting again...' ) self . request = AddTwoInts . Request () # 创建服务请求的数据对象 def send_request ( self ): # 创建一个发送服务请求的函数 self . request . a = int ( sys . argv [ 1 ]) self . request . b = int ( sys . argv [ 2 ]) self . future = self . client . call_async ( self . request ) # 异步方式发送服务请求 def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = adderClient ( \"service_adder_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () # 发送服务请求 while rclpy . ok (): # ROS2系统正常运行 rclpy . spin_once ( node ) # 循环执行一次节点 if node . future . done (): # 数据是否处理完成 try : response = node . future . result () # 接收服务器端的反馈数据 except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( # 将收到的反馈信息打印输出 'Result of add_two_ints: for %d + %d = %d ' % ( node . request . a , node . request . b , response . sum )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , ], },","text_tokens":["+","shutdown","coding","waiting","env","available","create","系统","com","示例","初始","成功","发送","法器","srv","name","call","创建","result","正常","py","（","learning","info","python","node","一次","]","interface","反馈","of","/","setup","启动","async","计算","ros2","e","将","...","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","get","：","接口","{","加法","8","a","import","www","输出","初始化","spin","服务","进行","none","收到","配置","add","）","循环","while","b","功能","bin","guyuehome","again","打印","客户","请求","对象","future","ints","break","函数","_","}","adder","self","数据","入口","服务器","sum","接口类","sec","服务器端","编写","点",":","自定","接口类型","#","except","类型","[","super","需要","int","from","__","定义","two","-","adderclient","1.0","failed","console","addtwoints","务器","not","wait","并","作者","是否","*","2","代码","timeout","的","选项","方式","编译","scripts","as","两个","关闭","知道","service","utf","'","argv","try",".","!","说明","init","异步","send","exception","包","执行","信息","文件",")","等待","程序","古月","usr","for","else","客户端",",","名","main","1","once","完成","打印输出","加数","request","if","如下","client","%","d","entry","接收","r","=","sys","类","父类","销毁","自定义","加入","处理","设置","一个","args","ok","points","class","节点","@","done","运行","后","让","加法器","response","(","logger"],"title":"程序实现","title_tokens":["程序实现","程序","实现"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_11","text":"对以上程序进行分析，如果我们想要实现一个客户端，流程如下： 编程接口初始化 创建节点并初始化 创建客户端对象 创建并发送请求数据 等待服务器端应答数据 销毁节点并关闭接口","text_tokens":["客户端","初始化","进行","服务","初始","务器","如下","实现","发送","并","创建","客户","请求","对象","分析","应答","销毁","我们","如果","关闭","对","一个","数据","以上","服务器","服务器端","想要","节点","编程","，"," ","等待","程序","：","接口","流程"],"title":"流程总结","title_tokens":["总结","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_12","text":"至于服务器端的实现，有点类似话题通信中的订阅者，并不知道请求数据什么时间出现，也用到了回调函数机制。","text_tokens":["服务","者","不知","务器","实现","有点","回调","话题","请求","机制","的","什么","时间","。","函数","类似","了","知道","至于","数据","服务器","服务器端","出现","通信","并不知道","，","订阅","中","也","用到"],"title":"服务端代码解析","title_tokens":["服务端","服务","解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_13","text":"learning_service/service_adder_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供加法器的服务器处理功能 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderServer ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . srv = self . create_service ( AddTwoInts , 'add_two_ints' , self . adder_callback ) # 创建服务器对象（接口类型、服务名、服务器回调函数） def adder_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 response . sum = request . a + request . b # 完成加法求和计算，将结果放到反馈的数据中 self . get_logger () . info ( 'Incoming request \\n a: %d b: %d ' % ( request . a , request . b )) # 输出日志信息，提示已经完成加法求和计算 return response # 反馈应答信息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = adderServer ( \"service_adder_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_server = learning_service.service_adder_server:main' , 'service_adder_server = learning_service.service_adder_server:main' , ], },","text_tokens":["shutdown","coding","env","系统","create","incoming","com","server","示例","初始","callback","法器","srv","name","创建","放到","logger","py","（","learning","info","python","node","]","interface","反馈","/","setup","计算","ros2","将","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","中","get","接口","应答","：","{","加法","8","a","import","www","输出","初始化","spin","服务","进行","none","收到","配置","add","）","循环","b","功能","提示","bin","guyuehome","回调","请求","对象","主","退出","ints","函数","_","}","adder","self","对","数据","入口","服务器","sum","接口类","日志","编写","点",":","自定","接口类型","#","类型","求和","[","super","需要","提供","\\","from","__","定义","two","-","console","n","务器","addtwoints","并","作者","*","代码","的","选项","return","编译","scripts","关闭","知道","service","utf","'",".","!","已经","说明","init","包","执行","信息","文件",")","、","等待","程序","古月","usr",",","名","main","完成","request","如下","%","d","entry","=","类","父类","adderserver","销毁","自定义","加入","处理","设置","args","points","class","结果","节点","@","后","让","加法器","response","(","+"],"title":"程序实现","title_tokens":["程序实现","程序","实现"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_14","text":"对以上程序进行分析，如果我们想要实现一个服务端，流程如下： 编程接口初始化 创建节点并初始化 创建服务器端对象 通过回调函数处进行服务 向客户端反馈应答结果 销毁节点并关闭接口","text_tokens":["客户端","初始化","进行","服务","初始","务器","如下","实现","并","创建","处","回调","客户","对象","分析","应答","函数","销毁","我们","如果","关闭","对","一个","以上","服务器","通过","服务器端","反馈","结果","想要","节点","服务端","编程","向","，"," ","程序","：","接口","流程"],"title":"流程总结","title_tokens":["总结","流程"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_15","text":"好啦，加法求解器已经实现了，回想下刚才我们提到的视觉识别流程，当我们需要知道目标物体位置的时候，通过服务通信的机制，岂不是更加合理。","text_tokens":["当","位置","服务","实现","更加","提到","岂","目标","刚才","机制","的","。","回想","了","视觉","我们","知道","合理","下","物体","通过","器","已经","通信","好","时候","啦","，","加法","需要","识别","不是","求解","流程"],"title":"案例二：机器视觉识别","title_tokens":["视觉","机器","识别","案例","二","："]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_16","text":"此时会有三个节点出现： 相机驱动节点 ，发布图像数据； 视觉识别节点 ，订阅图像数据，并且集成了一个服务器端对象，随时准备提供目标位置； 客户端节点 ，我们可以认为是一个机器人目标跟踪的节点，当需要根据目标运动时，就发送一次请求，然后拿到一个当前的目标位置。 启动三个终端，分别运行上述三个节点： $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_service service_object_server $ ros2 run learning_service service_object_client","text_tokens":["随时","；","就","客户端","usb","当","位置","三个","是","服务","server","然后","务器","准备","client","发送","机器人","拿到","分别","有","此时","object","目标","上述","可以","当前","run","客户","根据","对象","集成","请求","的","。","时","终端","$","learning","了","_","跟踪","视觉","我们","一次","cam","node","exe","数据","一个","service","认为","会","服务器","服务器端","出现","运动","启动","节点","ros2","运行","并且","，","图像","机器","需要","识别"," ","提供","相机","订阅","：","驱动","发布"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_17","text":"learning_service/service_object_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-请求目标识别，等待目标位置应答 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 class objectClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( GetObjectPosition , 'get_target_position' ) while not self . client . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . request = GetObjectPosition . Request () def send_request ( self ): self . request . get = True self . future = self . client . call_async ( self . request ) def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = objectClient ( \"service_object_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () while rclpy . ok (): rclpy . spin_once ( node ) if node . future . done (): try : response = node . future . result () except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( 'Result of object position: \\n x: %d y: %d ' % ( response . x , response . y )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , 'service_adder_server = learning_service.service_adder_server:main' , 'service_object_client = learning_service.service_object_client:main' , ], },","text_tokens":["shutdown","coding","waiting","env","available","create","系统","com","server","示例","初始","call","srv","name","创建","result","object","py","learning","info","python","node","]","interface","of","/","setup","async","ros2","e","...","打开","库","，","destroy","居","python3","def"," ","\"","rclpy","get","：","接口","应答","{","8","import","www","x","初始化","spin","服务","进行","none","配置","while","功能","目标","bin","guyuehome","again","请求","对象","future","break","_","}","self","adder","入口","sec","编写","点",":","自定","#","except","[","super","需要","\\","position","from","__","定义","-","1.0","failed","n","console","not","wait","并","作者","*","代码","timeout","的","选项","编译","scripts","as","关闭","知道","service","utf","'","try",".","!","target","说明","init","send","exception","y","包","文件","识别",")","等待","程序","古月","usr","for","else",",","位置","objectclient","main","once","完成","request","if","如下","client","%","d","entry","r","=","类","父类","销毁","自定义","加入","设置","args","ok","points","class","节点","getobjectposition","@","done","后","让","response","(","true","logger"],"title":"客户端代码解析","title_tokens":["代码","客户端","客户","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_18","text":"learning_service/service_object_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供目标识别服务 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 import numpy as np # Python数值计算库 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . srv = self . create_service ( GetObjectPosition , # 创建服务器对象（接口类型、服务名、服务器回调函数） 'get_target_position' , self . object_position_callback ) self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def object_position_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 if request . get == True : response . x = self . objectX # 目标物体的XY坐标 response . y = self . objectY self . get_logger () . info ( 'Object position \\n x: %d y: %d ' % ( response . x , response . y )) # 输出日志信息，提示已经反馈 else : response . x = 0 response . y = 0 self . get_logger () . info ( 'Invalid command' ) # 输出日志信息，提示已经反馈 return response def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"service_object_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'service_adder_client = learning_service.service_adder_client:main' , 'service_adder_server = learning_service.service_adder_server:main' , 'service_object_client = learning_service.service_object_client:main' , 'service_object_server = learning_service.service_object_server:main' , ], },","text_tokens":["data","shutdown","coding","进入","env","imgmsg","系统","create","<","com","server","10","示例","初始","circle","callback","消息","srv","name","approx","h","创建","retr","object","转化成","objecty","logger","py","subscription","（","learning","info","bgr2hsv","python","使用","objectx","node","]","为","勾勒","interface","反馈","转化","/","setup","计算","ros2","inrange","将","frame","打开","to","cv2","轮廓","所在","50","库","sensor","，","居","python3","def","互相"," ","\"","lower","img","in","rclpy","订阅","get","接口","findcontours","中","：","8","{","import","www","下限","x","初始化","list","和","高","输出","去除","spin","服务","进行","none","长度","w","cvtcolor","模型","收到","配置","）","循环","color","宽","像素","功能","一些","np","提示","目标","bin","guyuehome","5","回调","二值化","对象","显示","请求","主","退出","函数","_","destroy","}","cvbridge","self","adder","对","数据","入口","continue","服务器","物体","接口类","日志","编写","点",":","array","自定","接口类型","#","drawcontours","类型","180","[","出来","super","150","提供","需要","int","点画","red","msgs","\\","90","position","from","__","范围","定义","-","hsv","bgr8","console","mask","务器","n","左上","0","图像处理","并","作者","颜色","raw","chain","128","*","2","代码","imshow","cv","话题","的","选项","return","编译","as","上限","效果","scripts","队列","关闭","检测","service","utf","知道","'","video",".","!","左上角","target","用于","说明","init","已经","command","y","坐标","包","执行","化成","信息","文件","识别",")","、","waitkey","等待","程序","upper","古月","usr","for","bridge","sub","得到","else","cnt","image",",","255","名","hierarchy","1","receiving","main","苹果","阈值","完成","者","request","if","如下","client","shape","数值","detect","%","d","entry","太小","msg","噪声","=","ros","类","父类","与","从","已","面积","numpy","boundingrect","contours","xy","imagesubscriber","自定义","销毁","处理","加入","设置","一个","listener","args","points","转换","class","节点","opencv","getobjectposition","上角","及","invalid","@","后","让","图像","红色","response","(","true","中心","bgr","+"],"title":"服务端代码解析","title_tokens":["服务端","服务","解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_19","text":"服务命令的常用操作如下： $ ros2 service list # 查看服务列表 $ ros2 service type <service_name> # 查看服务数据类型 $ ros2 service call <service_name> <service_type> <service_data> # 发送服务请求","text_tokens":["列表","data","list","<","服务","如下","call","name","发送","常用","请求","$","的","_","service","查看","数据","ros2","#","操作","类型","数据类型",">","type"," ","命令","："],"title":"服务命令行操作","title_tokens":["命令","服务","操作","命令行"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_20","text":"话题和服务是ROS中最为常用的两种数据通信方法，前者适合传感器、控制指令等周期性、单向传输的数据，后者适合一问一答，同步性要求更高的数据，比如获取机器视觉识别到的目标位置。 在机器人开发过程中，类似的通信应用比比皆是，ROS针对绝大部分通用场景，都设计了标准的话题和服务数据类型，比如图像数据、雷达数据、里程计数据等等，不过机器人软硬件繁杂，很多时候这些标准定义也无法满足我们的需求，这个时候，我们就要自定义通信接口了。","text_tokens":["到","就要","同步性","机器人","里程","绝大","感器","标准","比如","。","类似","设计","需求","视觉","大部","雷达","通信","，"," ","中","也","接口","开发","高","控制指令","大部分","这些","和","前者","是","无法","服务","最为","应用","这个","过程","目标","同步","硬件","都","数据通信","数据","周期","控制","不过","自定","里程计","类型","比比皆是","适合","机器","通信接口","通用","软硬件","定义","单向","很多","数据通","常用","后者","话题","传感","的","我们","等","一问一答","部分","针对","比比","等等","满足","识别","、","要求","在","位置","传感器","传输","ros","场景","了","自定义","繁杂","两种","绝大部分","周期性","更","指令","软硬","时候","数据类型","方法","图像","获取"],"title":"思考题","title_tokens":["思考","考题","思考题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.5_%E6%9C%8D%E5%8A%A1/#_21","text":"https://docs.ros.org/en/ humble /Tutorials/Services/Understanding-ROS2-Services.html","text_tokens":["https","-","tutorials","en","docs","ros"," ","understanding",".","humble","services","/","html",":","org","ros2"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/","text":"通信接口 在ROS系统中，无论话题还是服务，或者我们后续将要学习的动作，都会用到一个重要的概念—— 通信接口 。 通信并不是一个人自言自语，而是两个甚至更多个人，你来我往的交流，交流的内容是什么呢？为了让大家都好理解，我们可以给传递的数据定义一个标准的结构，这就是通信接口。 接口的定义 接口的概念在各个领域随处可见，无论是硬件结构还是软件开发，都有广泛的应用。 比如生活中最为常见的插头和插座，两者必须匹配才能使用，电脑和手机上的USB接口也是，什么Micro-USB、TypeC等等，都是关于接口的具体定义。 软件开发中，接口的使用就更多了，比如我们在编写程序时，使用的函数和函数的输入输出也称之为接口，每一次调用函数的时候，就像是把主程序和调用函数通过这个接口连接到一起，系统才能正常工作。 更为形象的是图形化编程中使用的程序模块，每一个模块都有固定的结构和形状，只有两个模块相互匹配，才能在一起工作，这就很好的讲代码形象化了。 所以什么是接口，它是一种相互关系，只有彼此匹配，才能建立连接。 回到ROS的通信系统，它的主要目的就是传输数据，那就得让大家高效的建立连接，并且准确包装和解析传输的数据内容，话题、服务等机制也就诞生了，他们传输的数据，都要 符合通信接口的标准定义 。 比如摄像头驱动发布的图像话题，由每个像素点的R、G、B三原色值组成，控制机器人运动的速度指令，由线速度和角速度组成，进行机器人配置的服务，有配置的参数和反馈的结果组成等等，类似这些常用的定义，在ROS系统中都有提供，我们也可以自己开发。 这些接口看上去像是给我们加了一些约束，但却是ROS系统的精髓所在 。举个例子，我们使用相机驱动节点的时候，完全不用关注它是如何驱动相机的，只要一句话运行，我们就可以知道发布出来的图像数据是什么样的了，直接开始我们的应用开发；类似的，键盘控制我们也可以安装一个ROS包，如何实现的呢？不用关心，反正它发布出来的肯定是线速度和角速度。 ROS通信接口 接口可以让程序之间的依赖降低，便于我们使用别人的代码，也方便别人使用我们的代码，这就是ROS的核心目标，减少重复造轮子。 ROS有三种常用的通信机制，分别是 话题、服务、动作 ，通过每一种通信种定义的接口，各种节点才能有机的联系到一起。 语言无关 为了保证每一个节点可以使用不同语言编程，ROS将这些接口的设计做成了和 语言无关 的，比如这里看到的int32表示32位的整型数，int64表示64位的整型数，bool表示布尔值，还可以定义数组、结构体，这些定义在编译过程中，会自动生成对应到C++、Python等语言里的数据结构。 话题通信接口的定义使用的是.msg文件，由于是单向传输，只需要描述传输的每一帧数据是什么就行，比如在这个定义里，会传输两个32位的整型数，x、y，我们可以用来传输二维坐标的数值。 服务通信接口的定义使用的是.srv文件，包含请求和应答两部分定义，通过中间的“---”区分，比如之前我们学习的加法求和功能，请求数据是两个64位整型数a和b，应答是求和的结果sum。 动作是另外一种通信机制，用来描述机器人的一个运动过程，使用.action文件定义，比如我们让小海龟转90度，一边转一边周期反馈当前的状态，此时接口的定义分成了三个部分，分别是动作的目标，比如是开始运动，运动的结果，最终旋转的90度是否完成，还有一个周期反馈，比如每隔1s反馈一下当前转到第10度、20度还是30度了，让我们知道运动的进度。 标准接口 大家可能好奇ROS系统到底给我们定义了哪些接口呢？我们可以在ROS安装路径中的share文件夹中找到，涵盖众多标准定义，大家可以打开几个看看。 案例一：服务接口的定义与使用 了解了通信接口的概念，接下来我们再从代码实现的角度，研究下如何定义以及使用一个接口。 在之前服务概念讲解的课程中，我们编写了这样一个例程，我们再来回顾下。 有三个节点，第一个驱动相机发布图像话题，第二个是机器视觉识别节点，封装了一个服务的服务端对象，提供目标识别位置的查询服务，第三个节点在需要目标位置的时候，就可以发送请求，收到位置进行使用了。 接口定义 在这个例程中，我们使用GetObjectPosition.srv定义了服务通信的接口： learning_interface/srv/GetObjectPosition.srv bool get # 获取目标位置的指令 --- int32 x # 目标的X坐标 int32 y # 目标的Y坐标 定义中有两个部分，上边是获取目标位置的指令，get为true的话，就表示我们需要一次位置，服务端就会反馈这个x、y坐标了。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"srv/GetObjectPosition.srv\" ) ... 功能包的package.xml文件中也需要添加代码生成的功能依赖： ... <build_depend> rosidl_default_generators </build_depend> <exec_depend> rosidl_default_runtime </exec_depend> <member_of_group> rosidl_interface_packages </member_of_group> ... 程序调用 我们在代码中再来重点看下接口的使用方法。 客户端接口调用 learning_service/service_object_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-请求目标识别，等待目标位置应答 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 class objectClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( GetObjectPosition , 'get_target_position' ) while not self . client . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . request = GetObjectPosition . Request () def send_request ( self ): self . request . get = True self . future = self . client . call_async ( self . request ) def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = objectClient ( \"service_object_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () while rclpy . ok (): rclpy . spin_once ( node ) if node . future . done (): try : response = node . future . result () except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( 'Result of object position: \\n x: %d y: %d ' % ( response . x , response . y )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 服务端接口调用 learning_service/service_object_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供目标识别服务 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 import numpy as np # Python数值计算库 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . srv = self . create_service ( GetObjectPosition , # 创建服务器对象（接口类型、服务名、服务器回调函数） 'get_target_position' , self . object_position_callback ) self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def object_position_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 if request . get == True : response . x = self . objectX # 目标物体的XY坐标 response . y = self . objectY self . get_logger () . info ( 'Object position \\n x: %d y: %d ' % ( response . x , response . y )) # 输出日志信息，提示已经反馈 else : response . x = 0 response . y = 0 self . get_logger () . info ( 'Invalid command' ) # 输出日志信息，提示已经反馈 return response def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"service_object_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 案例二：话题接口的定义与使用 话题通信接口的定义也是类似的，继续从之前的机器视觉案例中来衍生，我们想把服务换成话题，周期发布目标识别的位置，不管有没有人需要。 运行效果 现在我们会运行三个节点： 第一个节点，将驱动相机并发布图像话题，此时的话题数据使用的是ROS中标准定义的Image图像消息； 第二个节点，会运行视觉识别功能，识别目标的位置，这个位置我们希望封装成话题消息，发布出去，谁需要使用谁就来订阅； 第三个节点，订阅位置话题，打印到终端中。 启动三个终端，分别运行以上节点： $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_topic interface_object_pub $ ros2 run learning_topic interface_object_sub 接口定义 在这个例程中，我们使用ObjectPosition.msg定义了服务通信的接口： learning_interface/msg/ObjectPosition.msg int32 x # 表示目标的X坐标 int32 y # 表示目标的Y坐标 话题消息的内容是一个位置，我们使用x、y坐标值进行描述。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"msg/ObjectPosition.msg\" ) ... 程序调用 我们在代码中再来重点看下接口的使用方法。 发布者接口调用 learning_topic/interface_object_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2接口示例-发布目标位置 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 from learning_interface.msg import ObjectPosition # 自定义的目标位置消息 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . pub = self . create_publisher ( ObjectPosition , \"object_position\" , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , # 将苹果的图像中心点画出来 ( 0 , 255 , 0 ), - 1 ) self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 position = ObjectPosition () self . object_detect ( image ) # 苹果检测 position . x , position . y = int ( self . objectX ), int ( self . objectY ) self . pub . publish ( position ) # 发布目标位置 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"topic_webcam_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 订阅者接口调用 learning_topic/interface_object_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2接口示例-订阅目标位置 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 from learning_interface.msg import ObjectPosition # 自定义的目标位置消息 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( \\ ObjectPosition , \"/object_position\" , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度 def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'Target Position: \"( %d , %d )\"' % ( msg . x , msg . y )) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"interface_position_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 接口命令行操作 接口命令的常用操作如下： $ ros2 interface list # 查看系统接口列表 $ ros2 interface show <interface_name> # 查看某个接口的详细定义 $ ros2 interface package <package_name> # 查看某个功能包中的接口定义 参考链接 https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html https://docs.ros.org/en/humble/Tutorials/Single-Package-Define-And-Use-Interface.html","text_tokens":["人","”","到","看上","coding","waiting","imgmsg","<","体","com","二","之为","一起","重点","callback","消息","srv","—","approx","有没有","retr","有","数据结构","objecty","区分","subscription","重复","比如","learning","python","default","设计","]","/","回顾","通信","了解","符合","cv2","50","插座","出去","库","，","第二","降低","in"," ","为了","订阅","topic","命令","接口","可以","要","org","a","课程","另外","import","这些","下限","这里","about","无关","spin","对应","进行","txt","过程","给","用来","当前","回调","请求","显示","保证","bool","一边","都","各个领域","cvbridge","加","入口","sec","drawcontours","int32","中间","代码生成","命令行","求和","并且","例子","出来","150","msgs","\\","一种","小海龟","范围","定义","n","精髓","mask","左上","形象","图像处理","raw","两者","后续","封装","详细","micro","你来我往","只有","的","最终","布尔值","return","解析","主要","关于","等","由","检测","会","try","show","现在","字符串","坐标","执行","64","进度","化成","包中",")","接下","waitkey","此时","usr","else","group","名","希望","三个","1","减少","request","and","旋转","client","不同","数值","可见","准确","r","bgr","就是","主程序","常见","调用","固定","原色","与","称之为","根据","讲","父类","想","generate","xy","contours","每","自定义","？","二个","处理","查看","一个","publish","结果","指令","c++","上角","上去","匹配","“","后","docs","+","data","找到","才能","再","领域","参数","name","看上去","形象化","方便","正常","建立","。","各种","路径","subscribernode","软件开发","类似","node","一次","视觉","学习","single","生成","反馈","interface","启动","async","计算","状态","链接","...","操作","to","sensor","组成","lower","之间","也","应答","驱动","get","开发","中有","之前","；","findcontours","输出","x","和","数","的话","服务","长度","模型","上","）","工作","color","宽","功能","guyuehome","客户","主","future","时","终端","package","布尔","_","}","runtime","continue","sum","将要","share","编写","控制","种","就行","以及","packages",":","自定","接口类型","#","诞生","except","180","随处可见","电脑","形状","角度","[","机器","tutorials","int","通信接口","position","每个","广泛","-","1.0","关注","包含","exec","单向","语言","并","插头","1s","是否","接下来","甚至","自语","128","代码","en","话题","完全","做成","as","两个","知道","交流","继续","通过","video",".","target","用于","init","已经","true","send","exception","command","值","关系","depend","里",">","信息","文件","接口定义","更为","看到","bridge","得到","安装","interfaces","在","开始",",","编写程序","255","如下","三原色","像是","%","参考","太小","噪声","ros","类","案例","看看","可能","销毁","30","listener","不用","摄像头","class","更","像素点","节点","及","时候","众多","编程","没有","坐标值","不是","response","整型","用到","位","随处","usb","env","系统","10","例程","action","一下","circle","call","h","机器人","创建","result","回到","三种","object","摄像","标准","run","由于","为","exe","下","std","of","转化","ros2","required","e","inrange","包装","destroy","互相","中","：","每隔","第三","度","www","彼此","去除","cmakelists","w","cvtcolor","应用","线速度","b","分别","像素","np","硬件","again","5","涵盖","退出","反正","对象","手机","字符","break","函数","图形","所以","数据","还有","物体","输入输出","周期","接口类","具体","把","关心","super","提供","__","传输数据","g","只要","---","not","标值","0","一句","wait","颜色","却是","chain","而是","*","2","转到","传递","编译","便于","效果","高效","发布者","它","有机","service","utf","理解","32","!","速度","说明","html","https","y","轮子","那","目的","、","等待","程序","for","上边","客户端","位置","main","hierarchy","receiving","查询","苹果","这样","once","完成","project","objectposition","if","得","小海","pub","图形化","shape","detect","调用函数","msg","大家","软件","分成","已","转","面积","重要","numpy","boundingrect","核心","了","imagesubscriber","像头","不管","什么样","一","转换","getobjectposition","服务端","自言自语","@","第一","member","自动","研究","多","红色","(","中心","获取","列表","shutdown","进入","available","文件夹","create","很","件夹","server","示例","初始","到底","实现","发送","直接","约束","rosidl","转化成","成","编译器","py","哪些","（","什么","info","bgr2hsv","使用","衍生","objectx","第二个","勾勒","内容","谁","自己","好奇","将","frame","打开","轮廓","所在","build","结构","举个","居","python3","def","img","\"","相机","{","rclpy","键盘","加法","8","高","初始化","list","描述","还","是","generators","none","这","收到","最为","配置","标准接口","循环","while","这个","一些","提示","目标","bin","打印","二值化","机制","webcam","self","cam","对","以上","服务器","日志","humble","string","运动","array","publisher","依赖","联系","来","呢","类型","几个","find","模块","别人","需要","点画","两","red","概念","int64","第三个","发布","90","from","typec","表示","hsv","还是","讲解","failed","bgr8","务器","三原","某个","输入","作者","个人","timeout","常用","imshow","cv","或者","$","选项","各个","上限","只","下来","数组","我们","关闭","话","队列","'","添加","define","concepts","左上角","部分","包","二维","但","等等","无论是","角速度","识别","upper","古月","sub","就","image","连接","看","cnt","objectclient","换成","无论","阈值","者","传输","程序模块","造","d","use","=","从","一帧","动作","肯定","生活","转到第","相互","xml","中来","args","ok","20","如何","opencv","invalid","好","第一个","done","运行","让","方法","图像","他们","海龟","必须","logger"],"title":"通信接口","title_tokens":["通信","接口","通信接口"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_1","text":"在ROS系统中，无论话题还是服务，或者我们后续将要学习的动作，都会用到一个重要的概念—— 通信接口 。 通信并不是一个人自言自语，而是两个甚至更多个人，你来我往的交流，交流的内容是什么呢？为了让大家都好理解，我们可以给传递的数据定义一个标准的结构，这就是通信接口。","text_tokens":["人","在","定义","系统","无论","是","还是","服务","这","—","并","给","后续","而是","自语","甚至","大家","个人","就是","ros","标准","你来我往","话题","或者","传递","的","。","什么","动作","重要","两个","都","我们","学习","？","交流","一个","内容","数据","理解","会","将要","更","通信","好","自言自语","呢","结构","让","，","不是"," ","多","为了","通信接口","中","概念","接口","可以","用到"],"title":"通信接口","title_tokens":["通信","接口","通信接口"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_2","text":"接口的概念在各个领域随处可见，无论是硬件结构还是软件开发，都有广泛的应用。 比如生活中最为常见的插头和插座，两者必须匹配才能使用，电脑和手机上的USB接口也是，什么Micro-USB、TypeC等等，都是关于接口的具体定义。 软件开发中，接口的使用就更多了，比如我们在编写程序时，使用的函数和函数的输入输出也称之为接口，每一次调用函数的时候，就像是把主程序和调用函数通过这个接口连接到一起，系统才能正常工作。 更为形象的是图形化编程中使用的程序模块，每一个模块都有固定的结构和形状，只有两个模块相互匹配，才能在一起工作，这就很好的讲代码形象化了。 所以什么是接口，它是一种相互关系，只有彼此匹配，才能建立连接。 回到ROS的通信系统，它的主要目的就是传输数据，那就得让大家高效的建立连接，并且准确包装和解析传输的数据内容，话题、服务等机制也就诞生了，他们传输的数据，都要 符合通信接口的标准定义 。 比如摄像头驱动发布的图像话题，由每个像素点的R、G、B三原色值组成，控制机器人运动的速度指令，由线速度和角速度组成，进行机器人配置的服务，有配置的参数和反馈的结果组成等等，类似这些常用的定义，在ROS系统中都有提供，我们也可以自己开发。 这些接口看上去像是给我们加了一些约束，但却是ROS系统的精髓所在 。举个例子，我们使用相机驱动节点的时候，完全不用关注它是如何驱动相机的，只要一句话运行，我们就可以知道发布出来的图像数据是什么样的了，直接开始我们的应用开发；类似的，键盘控制我们也可以安装一个ROS包，如何实现的呢？不用关心，反正它发布出来的肯定是线速度和角速度。","text_tokens":["才能","随处","usb","到","看上","系统","很","领域","之为","一起","参数","实现","机器人","回到","看上去","形象化","有","直接","摄像","正常","约束","建立","标准","比如","什么","。","使用","软件开发","类似","一次","内容","反馈","自己","通信","符合","包装","所在","结构","插座","，","举个"," ","组成","相机","中","也","接口","要","驱动","开发","可以","键盘","；","这些","输出","和","彼此","是","服务","进行","这","上","最为","配置","应用","工作","线速度","这个","b","像素","给","一些","硬件","反正","机制","手机","时","函数","图形","所以","各个领域","都","加","数据","输入输出","编写","控制","运动","具体","把","关心","诞生","呢","随处可见","电脑","形状","并且","机器","例子","模块","出来","提供","通信接口","概念","发布","一种","广泛","传输数据","每个","g","定义","只要","typec","-","关注","还是","精髓","三原","形象","一句","插头","输入","却是","两者","代码","常用","micro","只有","话题","的","完全","各个","高效","两个","解析","主要","关于","我们","它","等","由","话","知道","通过","速度","值","包","但","等等","关系","那","目的","无论是","角速度","、","程序","更为","就","安装","在","连接","开始","编写程序","无论","传输","程序模块","得","图形化","三原色","像是","可见","调用函数","准确","大家","软件","r","就是","主程序","ros","常见","调用","固定","原色","称之为","讲","肯定","生活","了","每","相互","？","一个","像头","不用","什么样","摄像头","结果","更","如何","像素点","指令","节点","好","上去","时候","匹配","运行","编程","让","图像","多","他们","必须"],"title":"接口的定义","title_tokens":["的","接口","定义"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#ros","text":"接口可以让程序之间的依赖降低，便于我们使用别人的代码，也方便别人使用我们的代码，这就是ROS的核心目标，减少重复造轮子。 ROS有三种常用的通信机制，分别是 话题、服务、动作 ，通过每一种通信种定义的接口，各种节点才能有机的联系到一起。","text_tokens":["一种","才能","到","定义","是","减少","服务","这","一起","造","分别","方便","有","三种","代码","就是","目标","常用","ros","重复","话题","机制","的","。","动作","各种","使用","便于","核心","每","我们","有机","通过","种","通信","依赖","节点","联系","轮子","让","，","降低","别人"," ","、","程序","之间","也","接口","可以"],"title":"ROS通信接口","title_tokens":["ros","通信","接口","通信接口"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_3","text":"为了保证每一个节点可以使用不同语言编程，ROS将这些接口的设计做成了和 语言无关 的，比如这里看到的int32表示32位的整型数，int64表示64位的整型数，bool表示布尔值，还可以定义数组、结构体，这些定义在编译过程中，会自动生成对应到C++、Python等语言里的数据结构。 话题通信接口的定义使用的是.msg文件，由于是单向传输，只需要描述传输的每一帧数据是什么就行，比如在这个定义里，会传输两个32位的整型数，x、y，我们可以用来传输二维坐标的数值。 服务通信接口的定义使用的是.srv文件，包含请求和应答两部分定义，通过中间的“---”区分，比如之前我们学习的加法求和功能，请求数据是两个64位整型数a和b，应答是求和的结果sum。 动作是另外一种通信机制，用来描述机器人的一个运动过程，使用.action文件定义，比如我们让小海龟转90度，一边转一边周期反馈当前的状态，此时接口的定义分成了三个部分，分别是动作的目标，比如是开始运动，运动的结果，最终旋转的90度是否完成，还有一个周期反馈，比如每隔1s反馈一下当前转到第10度、20度还是30度了，让我们知道运动的进度。","text_tokens":["位","”","到","体","10","action","一下","srv","机器人","数据结构","区分","比如","什么","。","使用","python","由于","设计","学习","生成","反馈","通信","状态","将","结构","，","为了"," ","中","接口","可以","应答","每隔","加法","之前","a","另外","这些","度","x","这里","和","描述","无关","数","还","对应","是","服务","这个","b","过程","功能","分别","目标","用来","当前","请求","保证","机制","bool","一边","布尔","数据","还有","sum","周期","就行","运动","int32","中间","求和","机器","需要","通信接口","两","int64","90","一种","小海龟","定义","---","表示","还是","包含","单向","语言","1s","是否","转到","话题","的","最终","做成","布尔值","编译","只","两个","数组","我们","等","知道","会","32","通过",".","部分","y","二维","坐标","里","64","进度","文件","、","看到","此时","在","开始","三个","完成","传输","旋转","小海","不同","数值","msg","分成","ros","一帧","转","动作","了","转到第","每","一个","30","20","结果","节点","c++","“","编程","让","自动","整型","海龟"],"title":"语言无关","title_tokens":["无关","语言"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_4","text":"大家可能好奇ROS系统到底给我们定义了哪些接口呢？我们可以在ROS安装路径中的share文件夹中找到，涵盖众多标准定义，大家可以打开几个看看。","text_tokens":["安装","找到","在","定义","系统","文件夹","件夹","到底","给","大家","ros","标准","涵盖","哪些","看看","的","。","可能","路径","了","我们","？","share","好奇","众多","呢","打开","几个","，","文件","中","接口","可以"],"title":"标准接口","title_tokens":["标准","接口","标准接口"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_5","text":"了解了通信接口的概念，接下来我们再从代码实现的角度，研究下如何定义以及使用一个接口。 在之前服务概念讲解的课程中，我们编写了这样一个例程，我们再来回顾下。 有三个节点，第一个驱动相机发布图像话题，第二个是机器视觉识别节点，封装了一个服务的服务端对象，提供目标识别位置的查询服务，第三个节点在需要目标位置的时候，就可以发送请求，收到位置进行使用了。","text_tokens":["之前","课程","就","在","第三","定义","位置","三个","查询","是","这样","服务","进行","再","讲解","例程","收到","实现","发送","接下来","有","封装","代码","目标","可以","从","话题","对象","请求","的","。","使用","了","下来","第二个","视觉","我们","二个","一个","下","以及","编写","回顾","如何","通信","节点","来","服务端","时候","了解","第一","第一个","第三个","角度","，","图像","第二","机器","研究","识别"," ","提供","接下","通信接口","相机","需要","中","概念","接口","驱动","发布"],"title":"案例一：服务接口的定义与使用","title_tokens":["定义","服务","案例","与","一","：","的","接口","使用"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_6","text":"在这个例程中，我们使用GetObjectPosition.srv定义了服务通信的接口： learning_interface/srv/GetObjectPosition.srv bool get # 获取目标位置的指令 --- int32 x # 目标的X坐标 int32 y # 目标的Y坐标 定义中有两个部分，上边是获取目标位置的指令，get为true的话，就表示我们需要一次位置，服务端就会反馈这个x、y坐标了。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"srv/GetObjectPosition.srv\" ) ... 功能包的package.xml文件中也需要添加代码生成的功能依赖： ... <build_depend> rosidl_default_generators </build_depend> <exec_depend> rosidl_default_runtime </exec_depend> <member_of_group> rosidl_interface_packages </member_of_group> ...","text_tokens":["<","例程","srv","name","编译器","learning","。","使用","default","一次","为","生成","interface","反馈","of","/","通信","required","...","build","，"," ","\"","{","get","中","：","接口","也","中有","x","的话","还","是","generators","服务","cmakelists","txt","配置","获取","这个","功能","过程","目标","package","bool","_","}","runtime","packages","依赖","#","int32","代码生成","find","需要","定义","---","表示","exec","语言","代码","$","的","选项","编译","两个","我们","添加","会",".","部分","y","坐标","包","depend",">","文件",")","、","接口定义","上边","就","interfaces","在","group","位置","完成","project","不同","根据","generate","了","xml","指令","getobjectposition","服务端","后","member","让","自动","(","true","rosidl"],"title":"接口定义","title_tokens":["接口定义","接口","定义"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_7","text":"我们在代码中再来重点看下接口的使用方法。","text_tokens":["在","看","我们","代码","使用","方法","下","。","再","中","的","接口","重点","来"],"title":"程序调用","title_tokens":["调用","程序"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_8","text":"learning_service/service_object_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-请求目标识别，等待目标位置应答 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 class objectClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . client = self . create_client ( GetObjectPosition , 'get_target_position' ) while not self . client . wait_for_service ( timeout_sec = 1.0 ): self . get_logger () . info ( 'service not available, waiting again...' ) self . request = GetObjectPosition . Request () def send_request ( self ): self . request . get = True self . future = self . client . call_async ( self . request ) def main ( args = None ): rclpy . init ( args = args ) # ROS2 Python接口初始化 node = objectClient ( \"service_object_client\" ) # 创建ROS2节点对象并进行初始化 node . send_request () while rclpy . ok (): rclpy . spin_once ( node ) if node . future . done (): try : response = node . future . result () except Exception as e : node . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : node . get_logger () . info ( 'Result of object position: \\n x: %d y: %d ' % ( response . x , response . y )) break node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口","text_tokens":["shutdown","coding","waiting","env","available","create","com","示例","初始","call","srv","name","创建","result","object","py","learning","info","python","node","interface","of","/","async","ros2","e","...","库","，","destroy","居","python3","def"," ","\"","rclpy","get","接口","应答","8","import","www","x","初始化","spin","服务","进行","none","while","目标","bin","guyuehome","again","请求","对象","future","break","_","self","sec",":","自定","#","except","super","\\","position","from","__","定义","-","1.0","failed","n","not","wait","并","作者","*","timeout","的","as","关闭","service","utf","'","try",".","!","target","说明","init","send","exception","y","识别",")","等待","古月","usr","for","else",",","位置","objectclient","main","once","request","if","client","%","d","r","=","类","父类","销毁","自定义","args","ok","class","节点","getobjectposition","@","done","response","(","true","logger"],"title":"客户端接口调用","title_tokens":["调用","接口","客户端","客户"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_9","text":"learning_service/service_object_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2服务示例-提供目标识别服务 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 import numpy as np # Python数值计算库 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 from learning_interface.srv import GetObjectPosition # 自定义的服务接口 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . srv = self . create_service ( GetObjectPosition , # 创建服务器对象（接口类型、服务名、服务器回调函数） 'get_target_position' , self . object_position_callback ) self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def object_position_callback ( self , request , response ): # 创建回调函数，执行收到请求后对数据的处理 if request . get == True : response . x = self . objectX # 目标物体的XY坐标 response . y = self . objectY self . get_logger () . info ( 'Object position \\n x: %d y: %d ' % ( response . x , response . y )) # 输出日志信息，提示已经反馈 else : response . x = 0 response . y = 0 self . get_logger () . info ( 'Invalid command' ) # 输出日志信息，提示已经反馈 return response def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"service_object_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口","text_tokens":["data","shutdown","coding","进入","env","imgmsg","create","<","com","server","10","示例","初始","circle","callback","消息","srv","name","approx","h","创建","retr","object","转化成","objecty","logger","py","subscription","（","learning","info","bgr2hsv","python","使用","objectx","node","]","为","勾勒","interface","反馈","转化","/","计算","ros2","inrange","将","frame","to","cv2","轮廓","所在","50","库","sensor","，","居","python3","def","互相"," ","\"","lower","img","in","rclpy","订阅","get","接口","findcontours","中","8","import","www","下限","x","初始化","list","和","高","输出","去除","spin","服务","进行","none","长度","w","cvtcolor","模型","收到","）","循环","color","宽","像素","一些","np","提示","目标","bin","guyuehome","5","回调","二值化","对象","显示","请求","主","退出","函数","_","destroy","cvbridge","self","对","数据","入口","continue","服务器","物体","接口类","日志",":","array","自定","接口类型","#","drawcontours","类型","180","[","出来","super","150","提供","int","点画","red","msgs","\\","90","position","from","__","范围","定义","-","hsv","bgr8","mask","务器","n","左上","0","图像处理","并","作者","颜色","raw","chain","128","*","2","imshow","cv","话题","的","return","as","上限","效果","队列","关闭","检测","service","utf","'","video",".","!","左上角","target","用于","说明","init","已经","command","y","坐标","执行","化成","信息","识别",")","、","waitkey","等待","upper","古月","usr","for","bridge","sub","得到","else","cnt","image",",","255","名","hierarchy","1","receiving","main","苹果","阈值","者","request","if","shape","数值","detect","%","d","太小","msg","噪声","=","ros","类","父类","与","从","已","面积","numpy","boundingrect","contours","xy","imagesubscriber","自定义","销毁","处理","一个","listener","args","转换","class","节点","opencv","getobjectposition","上角","及","invalid","@","后","图像","红色","response","(","true","中心","bgr","+"],"title":"服务端接口调用","title_tokens":["服务端","服务","接口","调用"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_10","text":"话题通信接口的定义也是类似的，继续从之前的机器视觉案例中来衍生，我们想把服务换成话题，周期发布目标识别的位置，不管有没有人需要。","text_tokens":["之前","人","定义","位置","换成","是","服务","有没有","目标","案例","从","话题","的","。","想","衍生","类似","视觉","我们","不管","中来","继续","周期","通信","把","没有","，","机器","需要","识别","通信接口","也","接口","发布"],"title":"案例二：话题接口的定义与使用","title_tokens":["定义","案例","与","话题","二","：","的","接口","使用"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_11","text":"现在我们会运行三个节点： 第一个节点，将驱动相机并发布图像话题，此时的话题数据使用的是ROS中标准定义的Image图像消息； 第二个节点，会运行视觉识别功能，识别目标的位置，这个位置我们希望封装成话题消息，发布出去，谁需要使用谁就来订阅； 第三个节点，订阅位置话题，打印到终端中。 启动三个终端，分别运行以上节点： $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_topic interface_object_pub $ ros2 run learning_topic interface_object_sub","text_tokens":["；","就","image","到","usb","定义","位置","三个","希望","是","pub","消息","并","这个","功能","分别","此时","object","封装","成","目标","ros","标准","打印","run","话题","$","learning","的","。","终端","使用","中","第二个","_","node","视觉","我们","二个","cam","exe","一个","数据","以上","会","interface","谁","启动","节点","现在","来","将","ros2","topic","第三个","第一","第一个","运行","出去","，","图像","第二","需要","识别"," ","相机","订阅","：","第三","驱动","sub","发布"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_12","text":"在这个例程中，我们使用ObjectPosition.msg定义了服务通信的接口： learning_interface/msg/ObjectPosition.msg int32 x # 表示目标的X坐标 int32 y # 表示目标的Y坐标 话题消息的内容是一个位置，我们使用x、y坐标值进行描述。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"msg/ObjectPosition.msg\" ) ...","text_tokens":["例程","消息","name","编译器","learning","。","使用","default","内容","生成","interface","/","通信","required","...","，"," ","\"","{","中","：","接口","x","描述","还","是","generators","服务","进行","cmakelists","txt","配置","这个","功能","过程","目标","package","_","}","#","int32","find","需要","定义","表示","标值","语言","代码","话题","$","的","选项","编译","我们",".","y","坐标","包",")","、","接口定义","interfaces","在","位置","objectposition","完成","project","不同","msg","根据","generate","了","一个","后","坐标值","让","自动","(","rosidl"],"title":"接口定义","title_tokens":["接口定义","接口","定义"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_13","text":"我们在代码中再来重点看下接口的使用方法。","text_tokens":["在","看","我们","代码","使用","方法","下","。","再","中","的","接口","重点","来"],"title":"程序调用","title_tokens":["调用","程序"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_14","text":"learning_topic/interface_object_pub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2接口示例-发布目标位置 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 from learning_interface.msg import ObjectPosition # 自定义的目标位置消息 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , 'image_raw' , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self . pub = self . create_publisher ( ObjectPosition , \"object_position\" , 10 ) # 创建发布者对象（消息类型、话题名、队列长度） self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . objectX = 0 self . objectY = 0 def object_detect ( self , image ): hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , # 将苹果的图像中心点画出来 ( 0 , 255 , 0 ), - 1 ) self . objectX = int ( x + w / 2 ) self . objectY = int ( y + h / 2 ) cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , 'bgr8' ) # 将ROS的图像消息转化成OpenCV图像 position = ObjectPosition () self . object_detect ( image ) # 苹果检测 position . x , position . y = int ( self . objectX ), int ( self . objectY ) self . pub . publish ( position ) # 发布目标位置 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"topic_webcam_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口","text_tokens":["data","shutdown","coding","进入","env","imgmsg","create","<","com","10","示例","初始","circle","callback","消息","name","approx","h","创建","retr","object","转化成","objecty","logger","py","subscription","（","learning","info","bgr2hsv","python","使用","objectx","node","]","为","勾勒","interface","转化","/","计算","ros2","inrange","将","frame","to","cv2","轮廓","所在","50","库","sensor","，","居","python3","def","互相"," ","\"","lower","img","in","rclpy","topic","订阅","接口","findcontours","中","get","8","import","www","下限","x","初始化","list","和","高","输出","去除","spin","进行","none","长度","w","cvtcolor","模型","）","循环","color","宽","像素","一些","np","提示","目标","bin","guyuehome","5","回调","二值化","对象","显示","主","退出","webcam","函数","_","destroy","cvbridge","self","入口","continue","日志",":","array","publisher","自定","drawcontours","#","类型","180","[","出来","super","150","int","点画","red","msgs","发布","90","position","from","__","范围","定义","-","hsv","bgr8","mask","左上","0","图像处理","并","作者","颜色","raw","chain","128","*","2","imshow","cv","话题","的","as","上限","效果","发布者","队列","关闭","检测","utf","'","video",".","!","左上角","用于","说明","init","y","坐标","化成","信息",")","、","waitkey","等待","upper","古月","usr","for","bridge","sub","得到","cnt","image",",","255","位置","名","hierarchy","1","receiving","苹果","main","objectposition","阈值","者","if","pub","shape","数值","detect","太小","msg","噪声","=","ros","类","父类","与","从","已","面积","numpy","boundingrect","contours","xy","imagesubscriber","自定义","销毁","处理","一个","listener","args","publish","转换","class","节点","opencv","上角","及","@","后","图像","红色","(","中心","bgr","+"],"title":"发布者接口调用","title_tokens":["接口","发布者","调用","发布"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_15","text":"learning_topic/interface_object_sub.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2接口示例-订阅目标位置 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 from learning_interface.msg import ObjectPosition # 自定义的目标位置消息 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( \\ ObjectPosition , \"/object_position\" , self . listener_callback , 10 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度 def listener_callback ( self , msg ): # 创建回调函数，执行收到话题消息后对数据的处理 self . get_logger () . info ( 'Target Position: \"( %d , %d )\"' % ( msg . x , msg . y )) # 输出日志信息，提示订阅收到的话题消息 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = SubscriberNode ( \"interface_position_sub\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口","text_tokens":["shutdown","coding","env","create","com","10","示例","初始","callback","消息","name","创建","object","py","subscription","（","learning","info","python","subscribernode","node","std","interface","/","ros2","库","，","destroy","居","python3","def"," ","\"","rclpy","订阅","topic","接口","get","8","import","www","x","初始化","输出","spin","进行","none","长度","收到","循环","提示","目标","bin","guyuehome","回调","退出","对象","主","字符","函数","_","self","对","数据","入口","日志","string",":","自定","#","类型","super","msgs","\\","position","from","__","定义","-","并","作者","*","话题","的","队列","关闭","utf","'",".","!","target","说明","init","字符串","y","执行","信息",")","、","等待","古月","usr","sub",",","名","位置","main","objectposition","者","%","d","msg","=","类","父类","销毁","自定义","处理","一个","listener","args","class","节点","@","后","(","logger"],"title":"订阅者接口调用","title_tokens":["订阅","接口","者","调用"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_16","text":"接口命令的常用操作如下： $ ros2 interface list # 查看系统接口列表 $ ros2 interface show <interface_name> # 查看某个接口的详细定义 $ ros2 interface package <package_name> # 查看某个功能包中的接口定义","text_tokens":["列表","list","定义","系统","<","如下","某个","name","功能","常用","详细","$","的","package","_","查看","show","interface","ros2","#","操作",">","包中"," ","接口定义","命令","：","接口"],"title":"接口命令行操作","title_tokens":["命令","操作","接口","命令行"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.6_%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3/#_17","text":"https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html https://docs.ros.org/en/humble/Tutorials/Single-Package-Define-And-Use-Interface.html","text_tokens":["interfaces","about","-","and","use","en","ros","package","single","define",".","humble","concepts","/","interface",":","html","https","tutorials","docs"," ","org"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/","text":"动作 机器人是一个复杂的智能系统，并不仅仅是键盘遥控运动、识别某个目标这么简单，我们需要实现的是送餐、送货、分拣等满足具体场景需求的机器人。 在这些应用功能的实现中，另外一种ROS通信机制也会被常常用到——那就是 动作 。从这个名字上就可以很好理解这个概念的含义，这种通信机制的目的就是便于 对机器人某一完整行为的流程进行管理 。 通信模型 举个例子，比如我们想让机器人转个圈，这肯定不是一下就可以完成的，机器人得一点一点旋转，直到360度才能结束，假设机器人并不在我们眼前，发出指令后，我们根本不知道机器人到底有没有开始转圈，转到哪里了？ OK，现在我们需要的是一个反馈，比如每隔1s，告诉我们当前转到多少度了，10度、20度、30度，一段时间之后，到了360度，再发送一个信息，表示动作执行完成。 这样一个需要执行一段时间的行为，使用动作的通信机制就更为合适，就像装了一个进度条，我们可以随时把控进度，如果运动过程当中，我们还可以随时发送一个取消运动的命令。 客户端/服务器模型 动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态。 客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。 一对多通信 和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个，毕竟只有一个机器人，先执行完成一个动作，才能执行下一个动作。 同步通信 既然有反馈，那动作也是一种同步通信机制，之前我们也介绍过，动作过程中的数据通信接口，使用.action文件进行定义。 由服务和话题合成 大家再仔细看下上边的动图，是不是还会发现一个隐藏的秘密。 动作的三个通信模块，竟然有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应带，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者。 没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的。 案例一：小海龟的动作 我们再用小海龟的案例加深对动作概念的理解。 按照以下命令启动小海龟仿真器，接下来使用action命令控制小海龟的动作，可以让海龟运动到某一指定的姿态： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key $ ros2 action info /turtle1/rotate_absolute $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: -1.57}\" $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: -1.57}\" --feedback 案例二：机器人画圆 如何通过代码来实现动作的编程呢？ 动作虽然是基于话题和服务实现的，但在实际使用中，并不会直接使用话题和服务的编程方法，而是有一套针对动作特性封装好的编程接口，接下来我们就一起试一试。 假设我们有一个机器人，我们希望通过动作的通信方法，让机器人转个圈，请编程实现动作通信中，客户端和服务器端的实现过程。 运行效果 启动两个终端，分别运行一下命令，启动动作示例的服务端和客户端： $ ros2 run learning_action action_move_server $ ros2 run learning_action action_move_client 终端中，我们可以看到客户端发送动作目标之后，服务器端开始模拟机器人运动，每30度发送一次反馈信息，最终完成运动，并反馈结束运动的信息。 接下来我们就分析下这个例程实现背后的原理。 接口定义 例程使用的动作并不是ROS中的标准定义，我们通过MoveCircle.action进行自定义： learning_interface/action/MoveCircle.action bool enable # 定义动作的目标，表示动作开始的指令 --- bool finish # 定义动作的结果，表示是否成功执行 --- int32 state # 定义动作的反馈，表示当前执行到的位置 包含三个部分： 第一块是 动作的目标 ，enable为true时，表示开始运动； 第二块是 动作的执行结果 ，finish为true，表示动作执行完成； 第三块是 动作的周期反馈 ，表示当前机器人旋转到的角度。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"action/MoveCircle.action\" ) ... 通信模型 通信模型就是这样，客户端发送给一个动作目标，服务器控制机器人开始运动，并周期反馈，结束后反馈结束信息。 思路理清楚，接下来开始写代码。相比之前话题和服务的程序，动作通信的例程相对较长，我们一起来运行并分析一下。 服务端代码解析 learning_action/action_move_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2动作示例-负责执行圆周运动动作的服务端 \"\"\" import time import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionServer # ROS2 动作服务器类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionServer ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . _action_server = ActionServer ( # 创建动作服务器（接口类型、动作名、回调函数） self , MoveCircle , 'move_circle' , self . execute_callback ) def execute_callback ( self , goal_handle ): # 执行收到动作目标之后的处理函数 self . get_logger () . info ( 'Moving circle...' ) feedback_msg = MoveCircle . Feedback () # 创建一个动作反馈信息的消息 for i in range ( 0 , 360 , 30 ): # 从0到360度，执行圆周运动，并周期反馈信息 feedback_msg . state = i # 创建反馈信息，表示当前执行到的角度 self . get_logger () . info ( 'Publishing feedback: %d ' % feedback_msg . state ) goal_handle . publish_feedback ( feedback_msg ) # 发布反馈信息 time . sleep ( 0.5 ) goal_handle . succeed () # 动作执行成功 result = MoveCircle . Result () # 创建结果消息 result . finish = True return result # 反馈最终动作执行的结果 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = MoveCircleActionServer ( \"action_move_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'action_move_server = learning_action.action_move_server:main' , ], }, 客户端代码解析 learning_action/action_move_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2动作示例-请求执行圆周运动动作的客户端 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionClient # ROS2 动作客户端类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . _action_client = ActionClient ( # 创建动作客户端（接口类型、动作名） self , MoveCircle , 'move_circle' ) def send_goal ( self , enable ): # 创建一个发送动作目标的函数 goal_msg = MoveCircle . Goal () # 创建一个动作目标的消息 goal_msg . enable = enable # 设置动作目标为使能，希望机器人开始运动 self . _action_client . wait_for_server () # 等待动作的服务器端启动 self . _send_goal_future = self . _action_client . send_goal_async ( # 异步方式发送动作的目标 goal_msg , # 动作目标 feedback_callback = self . feedback_callback ) # 处理周期反馈消息的回调函数 self . _send_goal_future . add_done_callback ( self . goal_response_callback ) # 设置一个服务器收到目标之后反馈时的回调函数 def goal_response_callback ( self , future ): # 创建一个服务器收到目标之后反馈时的回调函数 goal_handle = future . result () # 接收动作的结果 if not goal_handle . accepted : # 如果动作被拒绝执行 self . get_logger () . info ( 'Goal rejected :(' ) return self . get_logger () . info ( 'Goal accepted :)' ) # 动作被顺利执行 self . _get_result_future = goal_handle . get_result_async () # 异步获取动作最终执行的结果反馈 self . _get_result_future . add_done_callback ( self . get_result_callback ) # 设置一个收到最终结果的回调函数 def get_result_callback ( self , future ): # 创建一个收到最终结果的回调函数 result = future . result () . result # 读取动作执行的结果 self . get_logger () . info ( 'Result: { %d }' % result . finish ) # 日志输出执行结果 def feedback_callback ( self , feedback_msg ): # 创建处理周期反馈消息的回调函数 feedback = feedback_msg . feedback # 读取反馈的数据 self . get_logger () . info ( 'Received feedback: { %d }' % feedback . state ) def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = MoveCircleActionClient ( \"action_move_client\" ) # 创建ROS2节点对象并进行初始化 node . send_goal ( True ) # 发送动作目标 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'action_move_client = learning_action.action_move_client:main' , 'action_move_server = learning_action.action_move_server:main' , ], }, 动作命令行操作 动作命令的常用操作如下： $ ros2 action list # 查看服务列表 $ ros2 action info <action_name> # 查看服务数据类型 $ ros2 action send_goal <action_name> <action_type> <action_data> # 发送服务请求 参考链接 https://docs.ros.org/en/humble/Tutorials/Understanding-ROS2-Actions.html","text_tokens":["到","coding","<","com","rotate","二","之后","一起","callback","但是","消息","—","有没有","有","同时","比如","learning","第三块","python","思路","default","基于","]","圆周运动","/","实时","setup","通信","库","，","第二","能","in"," ","订阅","命令","较长","接口","可以","org","received","另外","import","这些","movecircle","spin","进行","请","结束","txt","过程","当前","回调","请求","抓取","像","bool","一边","都","一段时间","入口","--","点","int32","命令行","例子","清楚","一种","小海龟","定义","仿真","负责","当中","取消","封装","只有","的","某一","最终","return","方式","解析","等","由","会","现在","state","坐标","执行","进度",")","接下","usr","流程","希望","名","整个","三个","一段","旋转","client","动","不同","就是","movecircleactionclient","调用","姿态","根据","父类","想","generate","装","是不是","每","自定义","？","处理","查看","一对","一个","管理","publish","结果","指令","指定","后","handle","仔细","type","遥控","理","docs","data","才能","再","name","一点一点","转圈","就此结束","。","应用层","类似","node","需求","一次","生成","反馈","interface","启动","async","状态","链接","...","操作","其实","多个","哪里","get","也","真器","不仅仅","之前","；","turtle","当","输出","和","介绍","服务","understanding","模型","上","）","add","功能","通信模型","guyuehome","隐藏","360","rejected","客户","主","future","时","终端","package","_","}","顺利","控制","编写",":","自定","接口类型","不会","#","角度","[","机器","tutorials","通信接口","sleep","-","turtle1","原理","段时间","包含","语言","处理函数","并","1s","是否","接下来","其","代码","en","话题","两个","知道","通过",".","多少","init","true","send","actionclient",">","信息","文件","满足","只能","接口定义","更为","看到","teleop","再用","随时","interfaces","在","开始","仿真器",",","三块","如下","进度条","%","参考","接收","ros","类","案例","publishing","直到","可能","特性","销毁","absolute","控","虽然","圆周","30","还会","class","节点","0.5","编程","实际","没有","数据类型","不是","没错","response","用到","机械","env","系统","不仅","10","例程","action","一下","circle","成功","机器人","创建","result","标准","run","feedback","时间","一点","为","下","ros2","required","这种","destroy","中","：","每隔","第三","度","www","cmakelists","写","应用","圈","画圆","分别","背后","既然","movecircleactionserver","同步","退出","对象","actionserver","函数","某","数据","周期","复杂","服务器端","接口类","相对","这么","发送给","具体","把","super","送货","臂","__","---","accepted","console","not","0","actions","wait","而是","*","名字","enable","编译","scripts","便于","效果","发布者","moving","被","utf","理解","key","!","说明","异步","html","多少度","https","合适","那","一块","目的","告诉","、","等待","程序","起来","就此","for","上边","客户端","finish","位置","main","这样","完成","project","if","得","所处","小海","msg","大家","转","试一试","了","加入","智能","points","一","服务端","@","第一","应带","分拣","自动","多","(","获取","常常","列表","shutdown","过","很","server","示例","初始","到底","实现","发送","直接","编译器","py","发现","达到","（","什么","info","分析","使用","如果","底层","简单","送给","发出","打开","含义","举个","居","python3","def","假设","\"","{","rclpy","键盘","完整","导航","加深","8","初始化","list","还","是","generators","rotateabsolute","none","move","这","收到","配置","循环","毕竟","这个","相比","i","目标","bin","转个","机制","干什么","一套","不","self","对","服务器","theta","日志","humble","运动","眼前","来","呢","类型","模拟","succeed","find","模块","需要","秘密","概念","第二块","发布","from","表示","务器","拒绝执行","某个","行为","送餐","goal","作者","turtlesim","常用","第一块","$","动图","选项","以下","合成","下来","我们","关闭","'","time","部分","针对","包","但","range","拒绝","识别","古月","使","就","看","者","1.57","d","entry","=","从","又","动作","一样","肯定","场景","仅仅","设置","根本","args","ok","先","20","按照","如何","好","done","读取","运行","二块","execute","让","方法","竟然","海龟","rosidl","logger"],"title":"动作","title_tokens":["动作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_1","text":"机器人是一个复杂的智能系统，并不仅仅是键盘遥控运动、识别某个目标这么简单，我们需要实现的是送餐、送货、分拣等满足具体场景需求的机器人。 在这些应用功能的实现中，另外一种ROS通信机制也会被常常用到——那就是 动作 。从这个名字上就可以很好理解这个概念的含义，这种通信机制的目的就是便于 对机器人某一完整行为的流程进行管理 。","text_tokens":["另外","一种","这些","在","就","流程","系统","不仅","是","很","进行","上","概念","某个","应用","实现","送餐","机器人","并","—","功能","这个","行为","目标","就是","名字","ros","从","也","机制","的","。","某一","动作","便于","场景","需求","仅仅","我们","等","被","对","一个","管理","用到","智能","会","复杂","简单","理解","运动","这么","具体","通信","好","这种","含义","那","机器","，","分拣","目的","需要","遥控","识别","、","满足"," ","送货","中","键盘","可以","常常","完整","不仅仅"],"title":"动作","title_tokens":["动作"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_2","text":"举个例子，比如我们想让机器人转个圈，这肯定不是一下就可以完成的，机器人得一点一点旋转，直到360度才能结束，假设机器人并不在我们眼前，发出指令后，我们根本不知道机器人到底有没有开始转圈，转到哪里了？ OK，现在我们需要的是一个反馈，比如每隔1s，告诉我们当前转到多少度了，10度、20度、30度，一段时间之后，到了360度，再发送一个信息，表示动作执行完成。 这样一个需要执行一段时间的行为，使用动作的通信机制就更为合适，就像装了一个进度条，我们可以随时把控进度，如果运动过程当中，我们还可以随时发送一个取消运动的命令。","text_tokens":["才能","到","10","再","之后","一下","到底","发送","机器人","有没有","一点一点","转圈","比如","。","时间","使用","一点","如果","反馈","发出","通信","，","举个","假设","哪里"," ","命令","每隔","可以","度","还","是","这","结束","圈","过程","360","当前","转个","机制","像","不","一段时间","运动","把","眼前","例子","机器","需要","表示","段时间","当中","行为","并","1s","取消","的","我们","知道","多少","现在","多少度","执行","合适","进度","告诉","信息","、","更为","随时","就","在","开始","这样","完成","一段","旋转","得","进度条","直到","转","想","动作","肯定","装","了","？","控","根本","一个","30","ok","20","指令","后","没有","让","不是"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_3","text":"动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态。 客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。","text_tokens":["臂","就","机械","客户端","开始","当","和","整个","是","就此","服务","再","务器","模型","收到","之后","所处","结束","发送","机器人","动","这个","过程","目标","就此结束","当前","姿态","客户","达到","同时","的","什么","想","动作","干什么","使用","。","可能","抓取","又","一边","类似","如果","一个","服务器","周期","服务器端","控制","反馈","运动","实时","通信","状态","坐标","执行","后","让","，","机器","信息"," ","起来","中","也","导航"],"title":"客户端/服务器模型","title_tokens":["客户端","模型","服务","服务器","客户","务器","/"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_4","text":"和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个，毕竟只有一个机器人，先执行完成一个动作，才能执行下一个动作。","text_tokens":["客户端","才能","和","服务","完成","务器","但是","发送","毕竟","机器人","有","大家","客户","只有","的","。","动作","一样","都","一个","下","服务器","服务器端","先","运动","通信","执行","，","机器","多个","只能","命令","中","可以"],"title":"一对多通信","title_tokens":["多","通信","一对"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_5","text":"既然有反馈，那动作也是一种同步通信机制，之前我们也介绍过，动作过程中的数据通信接口，使用.action文件进行定义。","text_tokens":["之前","一种","定义","介绍","过","是","进行","action","过程","既然","有","同步","机制","的","。","动作","使用","我们","数据","反馈",".","通信","那","，","文件","通信接口","中","也","接口"],"title":"同步通信","title_tokens":["通信","同步"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_6","text":"大家再仔细看下上边的动图，是不是还会发现一个隐藏的秘密。 动作的三个通信模块，竟然有两个是服务，一个是话题，当客户端发送运动目标时，使用的是服务的请求调用，服务器端也会反馈一个应带，表示收到命令。动作的反馈过程，其实就是一个话题的周期发布，服务器端是发布者，客户端是订阅者。 没错，动作是一种应用层的通信机制，其底层就是基于话题和服务来实现的。","text_tokens":["上边","一种","看","客户端","当","和","三个","表示","是","服务","再","者","务器","收到","应用","发送","实现","过程","有","大家","目标","就是","其","隐藏","调用","发现","话题","客户","请求","机制","的","。","动图","动作","时","使用","是不是","发布者","两个","应用层","基于","一个","下","服务器","会","周期","服务器端","反馈","还会","运动","底层","通信","订阅","来","其实","仔细","，","应带","模块","不是","秘密"," ","没错","竟然","命令","也","发布"],"title":"由服务和话题合成","title_tokens":["合成","和","由","服务","话题"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_7","text":"我们再用小海龟的案例加深对动作概念的理解。 按照以下命令启动小海龟仿真器，接下来使用action命令控制小海龟的动作，可以让海龟运动到某一指定的姿态： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key $ ros2 action info /turtle1/rotate_absolute $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: -1.57}\" $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: -1.57}\" --feedback","text_tokens":["：","小海龟","仿真器","到","turtle","-","仿真","turtle1","rotateabsolute","rotate","action","小海","goal","1.57","turtlesim","接下来","案例","姿态","真器","run","$","feedback","的","。","info","动作","使用","以下","下来","_","node","absolute","我们","}","对","某","{","理解","key","按照","控制","运动","一","/","启动","theta",":","send","ros2","指定","让","，","--"," ","\"","接下","命令","海龟","概念","可以","teleop","加深","再用"],"title":"案例一：小海龟的动作","title_tokens":["小海龟","动作","案例","一","：","的","小海","海龟"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_8","text":"如何通过代码来实现动作的编程呢？ 动作虽然是基于话题和服务实现的，但在实际使用中，并不会直接使用话题和服务的编程方法，而是有一套针对动作特性封装好的编程接口，接下来我们就一起试一试。 假设我们有一个机器人，我们希望通过动作的通信方法，让机器人转个圈，请编程实现动作通信中，客户端和服务器端的实现过程。","text_tokens":["就","在","客户端","希望","和","是","服务","请","务器","一起","圈","实现","机器人","并","过程","直接","而是","有","接下来","封装","代码","客户","话题","转个","的","。","动作","一套","使用","试一试","特性","下来","基于","我们","？","虽然","一个","服务器","通过","服务器端","如何","通信","来","不会","好","针对","呢","但","编程","实际","让","，","方法","机器"," ","假设","接下","中","接口"],"title":"案例二：机器人画圆","title_tokens":["画圆","机器人","机器","案例","二","："]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_9","text":"启动两个终端，分别运行一下命令，启动动作示例的服务端和客户端： $ ros2 run learning_action action_move_server $ ros2 run learning_action action_move_client 终端中，我们可以看到客户端发送动作目标之后，服务器端开始模拟机器人运动，每30度发送一次反馈信息，最终完成运动，并反馈结束运动的信息。 接下来我们就分析下这个例程实现背后的原理。","text_tokens":["度","就","客户端","开始","和","服务","完成","例程","move","server","原理","示例","action","之后","一下","务器","client","结束","发送","实现","机器人","并","分别","这个","背后","接下来","目标","run","客户","$","learning","的","看到","终端","动作","最终","。","分析","中","两个","_","一次","每","我们","下来","30","下","服务器","服务器端","反馈","运动","启动","ros2","服务端","模拟","运行","，","机器","信息"," ","接下","命令","：","可以"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_10","text":"例程使用的动作并不是ROS中的标准定义，我们通过MoveCircle.action进行自定义： learning_interface/action/MoveCircle.action bool enable # 定义动作的目标，表示动作开始的指令 --- bool finish # 定义动作的结果，表示是否成功执行 --- int32 state # 定义动作的反馈，表示当前执行到的位置 包含三个部分： 第一块是 动作的目标 ，enable为true时，表示开始运动； 第二块是 动作的执行结果 ，finish为true，表示动作执行完成； 第三块是 动作的周期反馈 ，表示当前机器人旋转到的角度。 完成定义后，还需要在功能包的CMakeLists.txt中配置编译选项，让编译器在编译过程中，根据接口定义，自动生成不同语言的代码： ... find_package ( rosidl_default_generators REQUIRED ) rosidl_generate_interfaces ( ${ PROJECT_NAME } \"action/MoveCircle.action\" ) ...","text_tokens":["到","例程","action","成功","name","机器人","编译器","标准","learning","第三块","。","使用","default","为","生成","interface","反馈","/","required","...","，","第二"," ","\"","{","：","中","第三","接口","；","movecircle","还","是","generators","进行","cmakelists","txt","配置","功能","过程","目标","当前","时","package","bool","_","}","周期","运动","自定","#","int32","角度","机器","find","需要","第二块","定义","---","表示","包含","语言","并","是否","代码","第一块","$","的","enable","选项","编译","我们","通过",".","部分","state","包","执行","一块",")","接口定义","interfaces","在","开始","finish","位置","三个","三块","完成","project","旋转","不同","ros","根据","动作","generate","自定义","结果","指令","第一","后","二块","让","自动","不是","(","true","rosidl"],"title":"接口定义","title_tokens":["接口定义","接口","定义"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_11","text":"通信模型就是这样，客户端发送给一个动作目标，服务器控制机器人开始运动，并周期反馈，结束后反馈结束信息。 思路理清楚，接下来开始写代码。相比之前话题和服务的程序，动作通信的例程相对较长，我们一起来运行并分析一下。","text_tokens":["之前","清楚","客户端","开始","和","这样","服务","写","例程","务器","模型","结束","一下","发送","机器人","并","通信模型","接下来","相比","目标","就是","代码","客户","话题","的","。","分析","动作","思路","下来","我们","一个","服务器","周期","反馈","送给","控制","发送给","运动","相对","通信","一","运行","后","，","机器","信息","理"," ","接下","程序","起来","较长"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_12","text":"learning_action/action_move_server.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2动作示例-负责执行圆周运动动作的服务端 \"\"\" import time import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionServer # ROS2 动作服务器类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionServer ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . _action_server = ActionServer ( # 创建动作服务器（接口类型、动作名、回调函数） self , MoveCircle , 'move_circle' , self . execute_callback ) def execute_callback ( self , goal_handle ): # 执行收到动作目标之后的处理函数 self . get_logger () . info ( 'Moving circle...' ) feedback_msg = MoveCircle . Feedback () # 创建一个动作反馈信息的消息 for i in range ( 0 , 360 , 30 ): # 从0到360度，执行圆周运动，并周期反馈信息 feedback_msg . state = i # 创建反馈信息，表示当前执行到的角度 self . get_logger () . info ( 'Publishing feedback: %d ' % feedback_msg . state ) goal_handle . publish_feedback ( feedback_msg ) # 发布反馈信息 time . sleep ( 0.5 ) goal_handle . succeed () # 动作执行成功 result = MoveCircle . Result () # 创建结果消息 result . finish = True return result # 反馈最终动作执行的结果 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = MoveCircleActionServer ( \"action_move_server\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'action_move_server = learning_action.action_move_server:main' , ], },","text_tokens":["shutdown","coding","到","env","系统","com","server","示例","action","初始","之后","circle","callback","成功","消息","name","创建","result","py","（","feedback","learning","info","python","node","]","interface","圆周运动","反馈","/","setup","ros2","...","打开","库","，","destroy","居","python3","def","in"," ","\"","rclpy","get","：","接口","{","8","度","import","www","初始化","movecircle","spin","服务","进行","none","move","收到","配置","）","循环","功能","movecircleactionserver","i","目标","bin","guyuehome","360","当前","回调","退出","主","对象","actionserver","函数","_","}","self","入口","服务器","周期","接口类","编写","点","运动",":","自定","接口类型","#","类型","succeed","角度","[","super","需要","发布","from","__","定义","sleep","-","表示","负责","console","务器","0","goal","处理函数","并","作者","*","代码","的","选项","最终","return","编译","scripts","moving","关闭","知道","utf","'","time",".","!","说明","init","state","包","执行","range","信息","文件",")","、","等待","程序","古月","usr","for",",","finish","名","main","完成","如下","%","d","entry","msg","=","类","父类","从","publishing","动作","销毁","自定义","加入","处理","圆周","设置","一个","30","args","points","publish","class","结果","节点","0.5","服务端","@","handle","execute","后","让","(","true","logger"],"title":"服务端代码解析","title_tokens":["服务端","服务","解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_13","text":"learning_action/action_move_client.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2动作示例-请求执行圆周运动动作的客户端 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionClient # ROS2 动作客户端类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionClient ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . _action_client = ActionClient ( # 创建动作客户端（接口类型、动作名） self , MoveCircle , 'move_circle' ) def send_goal ( self , enable ): # 创建一个发送动作目标的函数 goal_msg = MoveCircle . Goal () # 创建一个动作目标的消息 goal_msg . enable = enable # 设置动作目标为使能，希望机器人开始运动 self . _action_client . wait_for_server () # 等待动作的服务器端启动 self . _send_goal_future = self . _action_client . send_goal_async ( # 异步方式发送动作的目标 goal_msg , # 动作目标 feedback_callback = self . feedback_callback ) # 处理周期反馈消息的回调函数 self . _send_goal_future . add_done_callback ( self . goal_response_callback ) # 设置一个服务器收到目标之后反馈时的回调函数 def goal_response_callback ( self , future ): # 创建一个服务器收到目标之后反馈时的回调函数 goal_handle = future . result () # 接收动作的结果 if not goal_handle . accepted : # 如果动作被拒绝执行 self . get_logger () . info ( 'Goal rejected :(' ) return self . get_logger () . info ( 'Goal accepted :)' ) # 动作被顺利执行 self . _get_result_future = goal_handle . get_result_async () # 异步获取动作最终执行的结果反馈 self . _get_result_future . add_done_callback ( self . get_result_callback ) # 设置一个收到最终结果的回调函数 def get_result_callback ( self , future ): # 创建一个收到最终结果的回调函数 result = future . result () . result # 读取动作执行的结果 self . get_logger () . info ( 'Result: { %d }' % result . finish ) # 日志输出执行结果 def feedback_callback ( self , feedback_msg ): # 创建处理周期反馈消息的回调函数 feedback = feedback_msg . feedback # 读取反馈的数据 self . get_logger () . info ( 'Received feedback: { %d }' % feedback . state ) def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = MoveCircleActionClient ( \"action_move_client\" ) # 创建ROS2节点对象并进行初始化 node . send_goal ( True ) # 发送动作目标 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'action_move_client = learning_action.action_move_client:main' , 'action_move_server = learning_action.action_move_server:main' , ], },","text_tokens":["shutdown","coding","env","系统","com","server","示例","action","初始","之后","circle","callback","消息","发送","name","机器人","创建","result","py","（","feedback","learning","info","python","node","]","为","如果","interface","圆周运动","反馈","/","setup","启动","async","ros2","打开","库","能","，","居","python3","def","destroy"," ","\"","rclpy","get","{","接口","：","8","received","import","www","输出","初始化","movecircle","spin","服务","进行","none","move","收到","配置","）","add","循环","功能","目标","bin","guyuehome","rejected","客户","请求","回调","主","future","对象","退出","时","函数","_","}","self","数据","入口","服务器","周期","顺利","接口类","服务器端","日志","运动","编写",":","点","自定","接口类型","#","类型","[","机器","super","需要","from","__","定义","accepted","-","console","务器","not","拒绝执行","goal","wait","并","作者","*","代码","的","enable","方式","return","最终","编译","选项","scripts","被","关闭","知道","utf","'",".","!","说明","init","actionclient","send","异步","state","包","执行","拒绝","文件",")","、","等待","程序","古月","usr","for","使","客户端",",","开始","名","希望","finish","main","完成","if","如下","client","%","d","entry","msg","接收","=","movecircleactionclient","类","父类","动作","销毁","自定义","加入","处理","圆周","设置","一个","args","points","class","结果","节点","@","done","读取","handle","后","让","response","(","true","获取","logger"],"title":"客户端代码解析","title_tokens":["代码","客户端","客户","解析"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_14","text":"动作命令的常用操作如下： $ ros2 action list # 查看服务列表 $ ros2 action info <action_name> # 查看服务数据类型 $ ros2 action send_goal <action_name> <action_type> <action_data> # 发送服务请求","text_tokens":["列表","data","list","<","服务","action","如下","goal","name","发送","常用","请求","$","info","的","动作","_","查看","数据","send","ros2","#","操作","类型","数据类型",">","type"," ","命令","："],"title":"动作命令行操作","title_tokens":["命令","操作","动作","命令行"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.7_%E5%8A%A8%E4%BD%9C/#_15","text":"https://docs.ros.org/en/humble/Tutorials/Understanding-ROS2-Actions.html","text_tokens":["https","-","tutorials","en","docs","ros","understanding",".","humble","html","/",":","actions","org","ros2"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/","text":"参数 话题、服务、动作，不知道这三种通信机制大家是否已经了解清楚，本节我们再来介绍一种ROS系统中常用的数据传输方式—— 参数 。 类似C++编程中的全局变量，可以便于在多个程序中共享某些数据， 参数是ROS机器人系统中的全局字典，可以运行多个节点中共享数据。 通信模型 比如在机器视觉识别的时候，有很多参数都会影响视觉识别的效果。 在NodeA相机驱动节点中，就需要考虑很多问题，相机连接到哪个usb端口，使用的图像分辨率是多少，曝光度和编码格式分别是什么，这些都可以通过参数设置，我们可以通过配置文件或者程序进行设置。 NodeB节点中也是一样，图像识别使用的阈值是多少，整个图像面积很大，那个部分是我们关注的核心区域，识别过程是否需要美颜等等，就像我们使用美颜相机一样，我们可以通过滑动条或者输入框设置很多参数，不同参数设置后，都会改变执行功能的一些效果。 这就是参数的作用。 全局字典 在ROS系统中，参数是以 全局字典 的形态存在的，什么叫字典？就像真实的字典一样，由名称和数值组成，也叫做键和值，合成 键值 。或者我们也可以理解为，就像编程中的参数一样，有一个参数名 ，然后跟一个等号，后边就是参数值了，在使用的时候，访问这个参数名即可。 可动态监控 在ROS2中，参数的特性非常丰富，比如某一个节点共享了一个参数，其他节点都可以访问，如果某一个节点对参数进行了修改，其他节点也有办法立刻知道，从而获取最新的数值。这在 参数的高级编程 中，大家都可能会用到。 案例一：小海龟例程中的参数 在小海龟的例程中，仿真器也提供了不少参数，我们一起来通过这个例程，熟悉下参数的含义和命令行的使用方法。 启动两个终端，分别运行小海龟仿真器和键盘控制节点： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key 查看参数列表 当前系统中有哪些参数呢？我们可以启动一个终端，并使用如下命令查询： $ ros2 param list 参数查询与修改 如果想要查询或者修改某个参数的值，可以在param命令后边跟get或者set子命令： $ ros2 param describe turtlesim background_b # 查看某个参数的描述信息 $ ros2 param get turtlesim background_b # 查询某个参数的值 $ ros2 param set turtlesim background_b 10 # 修改某个参数的值 参数文件保存与加载 一个一个查询/修改参数太麻烦了，不如试一试参数文件，ROS中的参数文件使用yaml格式，可以在param命令后边跟dump子命令，将某个节点的参数都保存到文件中，或者通过load命令一次性加载某个参数文件中的所有内容： $ ros2 param dump turtlesim >> turtlesim.yaml # 将某个节点的参数保存到参数文件中 $ ros2 param load turtlesim turtlesim.yaml # 一次性加载某一个文件中的所有参数 案例二：参数编程 接下来就要开始写程序了，在程序中设置参数和读取参数都比较简单，一两句函数就可以实现，我们先来体验一下这几个函数的使用方法。 运行效果 启动一个终端，先运行第一句指令，启动param_declare节点，终端中可以看到循环打印的日志信息，其中的“mbot”就是我们设置的一个参数值，参数名称是“robot_name”，通过命令行修改这个参数，看下终端中会发生什么？ $ ros2 run learning_parameter param_declare $ ros2 param set param_declare robot_name turtle 代码解析 我们来看下在代码中，如何声明、创建、修改一个参数的值。 learning_parameter/param_declare.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2参数示例-创建、读取、修改参数 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 class ParameterNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . timer = self . create_timer ( 2 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） self . declare_parameter ( 'robot_name' , 'mbot' ) # 创建一个参数，并设置参数的默认值 def timer_callback ( self ): # 创建定时器周期执行的回调函数 robot_name_param = self . get_parameter ( 'robot_name' ) . get_parameter_value () . string_value # 从ROS2系统中读取参数的值 self . get_logger () . info ( 'Hello %s !' % robot_name_param ) # 输出日志信息，打印读取到的参数值 new_name_param = rclpy . parameter . Parameter ( 'robot_name' , # 重新将参数值设置为指定值 rclpy . Parameter . Type . STRING , 'mbot' ) all_new_parameters = [ new_name_param ] self . set_parameters ( all_new_parameters ) # 将重新创建的参数列表发送给ROS2系统 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ParameterNode ( \"param_declare\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'param_declare = learning_parameter.param_declare:main' , ], }, 案例三：机器视觉应用 参数大家已经会使用了，如何在机器人中应用呢？ 继续优化机器视觉的示例，物体识别对光线比较敏感，不同的环境大家使用的阈值也是不同的，每次在代码中修改阈值还挺麻烦，不如我们就把阈值提炼成参数，运行过程中就可以动态设置，不是大大提高了程序的易用性么？ 说干就干，我们先来看下效果如何，再看下代码中的变化。 运行效果 启动三个终端，分别运行： 相机驱动节点 视觉识别节点 修改红色阈值 $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_parameter param_object_detect $ ros2 param set param_object_detect red_h_upper 180 在启动的视觉识别节点中，我们故意将视觉识别中红色阈值的上限设置为0，如果不修改参数，将无法实现目标识别。 为了便于调整阈值，我们在节点中将红色阈值的限位修改为了ROS参数，通过命令行修改该参数的值，就可以实现视觉识别啦。 代码解析 我们来看下在视觉识别的代码中，是如何通过参数来设置阈值的。 learning_parameter/param_object_detect.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2参数示例-设置目标识别的颜色阈值参数 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） 'image_raw' , self . listener_callback , 10 ) self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . declare_parameter ( 'red_h_upper' , 0 ) # 创建一个参数，表示阈值上限 self . declare_parameter ( 'red_h_lower' , 0 ) # 创建一个参数，表示阈值下限 def object_detect ( self , image ): upper_red [ 0 ] = self . get_parameter ( 'red_h_upper' ) . get_parameter_value () . integer_value # 读取阈值上限的参数值 lower_red [ 0 ] = self . get_parameter ( 'red_h_lower' ) . get_parameter_value () . integer_value # 读取阈值下限的参数值 self . get_logger () . info ( 'Get Red H Upper: %d , Lower: %d ' % ( upper_red [ 0 ], lower_red [ 0 ])) # 通过日志打印读取到的参数值 hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , \"bgr8\" ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"param_object_detect\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'param_declare = learning_parameter.param_declare:main' , 'param_object_detect = learning_parameter.param_object_detect:main' , ], }, 参考链接 https://docs.ros.org/en/humble/Tutorials/Parameters/Understanding-ROS2-Parameters.html","text_tokens":["变化","”","到","coding","imgmsg","<","其他","com","二","callback","消息","approx","—","retr","有","subscription","节","比如","learning","python","丰富","]","提炼","/","setup","通信","load","了解","配置文件","cv2","50","太","，","nodea","库","in"," ","为了","命令","订阅","org","接口","可以","import","这些","下限","spin","挺","进行","过程","当前","大大提高","回调","显示","作用","分辨","像","都","cvbridge","入口","点","parameter","drawcontours","美颜","命令行","出来","150","办法","msgs","清楚","一种","全局变量","小海龟","定时器","范围","仿真","非常","mask","左上","图像处理","raw","实现目标","该","的","一次性","方式","解析","由","等","秒","检测","会","declare","坐标","执行","化成","本",")","接下","waitkey","usr","比较简单","体验","名","整个","三个","1","易用","integer","不同","数值","就是","父类","与","timer","xy","contours","格式","？","查看","处理","一个","c++","指令","上角","指定","“","后","type","端口","docs","监控","+","data","mbot","敏感","再","参数","name","。","类似","node","一次","视觉","某些","all","哪个","启动","计算","链接","后边","to","啦","来看","sensor","多个","组成","lower","键值","get","也","真器","驱动","findcontours","中有","turtle","输出","x","和","介绍","服务","understanding","长度","模型","）","color","宽","功能","通信模型","麻烦","guyuehome","主","每次","终端","_","}","continue","控制","编写",":","想要","#","180","名称","区域","[","机器","存在","tutorials","int","可","nodeb","其中","background","全局","保存","-","辨率","关注","形态","并","是否","接下来","128","代码","en","字典","话题","as","两个","知道","继续","通过","video",".","多少","已经","init","用于","大大","值",">","定时","信息","文件","看到","一两","teleop","bridge","得到","输入框","在","仿真器","开始",",","255","改变","如下","图像识别","%","参考","太小","键和值","噪声","ros","类","案例","可能","特性","销毁","listener","子","不少","class","节点","及","时候","从而","编程","不是","加载","用到","发生","usb","env","系统","就要","例程","10","然后","一下","circle","h","机器人","两句","创建","三种","声明","object","run","为","exe","下","new","robot","转化","条","编码","ros2","inrange","destroy","互相","中","：","度","所有","www","hello","去除","跟","写","w","cvtcolor","应用","b","分别","像素","np","5","退出","对象","考虑","函数","某","数据","物体","周期","发送给","把","super","提供","比较","__","console","0","一句","颜色","很多","chain","*","2","编译","scripts","便于","效果","提高","utf","立刻","理解","key","!","说明","html","https","y","、","等待","程序","起来","for","main","hierarchy","receiving","查询","苹果","完成","if","parameters","以","小海","describe","shape","detect","msg","大家","已","第一句","面积","试一试","numpy","boundingrect","核心","了","imagesubscriber","参数值","加入","变量","么","points","一","转换","param","@","第一","value","修改","红色","默认","(","中心","set","获取","列表","shutdown","进入","create","s","示例","初始","实现","访问","发送","曝光","很大","成","转化成","py","哪些","（","什么","info","影响","bgr2hsv","使用","dump","如果","勾勒","内容","简单","送给","一两句","三","将","frame","打开","含义","轮廓","所在","居","python3","def","img","\"","相机","问题","rclpy","{","键盘","8","高","初始化","list","描述","还","是","无法","none","这","配置","循环","这个","一些","提示","目标","bin","打印","二值化","机制","不","self","cam","对","日志","humble","string","参数设置","array","号","来","不如","呢","类型","共享","几个","动态","滑动","需要","点画","red","90","调整","from","yaml","传输方式","表示","hsv","bgr8","某个","叫","重新","输入","作者","turtlesim","易用性","优化","imshow","常用","cv","说干就干","或者","$","选项","环境","上限","那个","合成","下来","队列","我们","关闭","默认值","'","光线","左上角","真实","即可","部分","最新","包","等等","单位","识别","upper","古月","parameternode","sub","就","熟悉","连接","看","image","cnt","阈值","者","传输","entry","d","故意","=","从","中将","动作","一样","设置","分辨率","args","限位","先","叫做","如何","opencv","高级","读取","运行","让","方法","图像","海龟","bgr","logger"],"title":"参数","title_tokens":["参数"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_1","text":"话题、服务、动作，不知道这三种通信机制大家是否已经了解清楚，本节我们再来介绍一种ROS系统中常用的数据传输方式—— 参数 。 类似C++编程中的全局变量，可以便于在多个程序中共享某些数据， 参数是ROS机器人系统中的全局字典，可以运行多个节点中共享数据。","text_tokens":["清楚","一种","全局变量","在","全局","系统","介绍","传输方式","是","服务","再","这","传输","参数","—","机器人","是否","三种","大家","常用","ros","字典","节","话题","机制","的","。","方式","动作","便于","不","类似","知道","我们","变量","数据","某些","已经","通信","c++","节点","来","了解","共享","编程","运行","，","机器","本","多个"," ","、","程序","中","可以"],"title":"参数","title_tokens":["参数"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_2","text":"比如在机器视觉识别的时候，有很多参数都会影响视觉识别的效果。 在NodeA相机驱动节点中，就需要考虑很多问题，相机连接到哪个usb端口，使用的图像分辨率是多少，曝光度和编码格式分别是什么，这些都可以通过参数设置，我们可以通过配置文件或者程序进行设置。 NodeB节点中也是一样，图像识别使用的阈值是多少，整个图像面积很大，那个部分是我们关注的核心区域，识别过程是否需要美颜等等，就像我们使用美颜相机一样，我们可以通过滑动条或者输入框设置很多参数，不同参数设置后，都会改变执行功能的一些效果。 这就是参数的作用。","text_tokens":["到","usb","参数","曝光","很大","有","比如","什么","。","影响","使用","视觉","哪个","条","编码","配置文件","，","nodea"," ","相机","问题","中","也","可以","驱动","度","这些","和","是","进行","这","配置","分别","过程","功能","一些","考虑","作用","分辨","像","都","参数设置","美颜","区域","机器","滑动","需要","nodeb","辨率","关注","输入","很多","是否","或者","的","效果","那个","我们","会","通过","多少","部分","等等","执行","文件","识别","程序","输入框","就","在","连接","整个","阈值","改变","图像识别","不同","就是","面积","一样","核心","格式","设置","分辨率","节点","时候","后","图像","端口"],"title":"通信模型","title_tokens":["模型","通信","通信模型"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_3","text":"在ROS系统中，参数是以 全局字典 的形态存在的，什么叫字典？就像真实的字典一样，由名称和数值组成，也叫做键和值，合成 键值 。或者我们也可以理解为，就像编程中的参数一样，有一个参数名 ，然后跟一个等号，后边就是参数值了，在使用的时候，访问这个参数名即可。","text_tokens":["就","在","名","全局","和","系统","是","跟","然后","形态","以","参数","叫","访问","数值","这个","键和值","有","就是","ros","字典","或者","什么","的","。","使用","一样","像","合成","了","参数值","我们","？","由","为","等","一个","理解","真实","即可","叫做","号","时候","后边","名称","编程","，","存在"," ","组成","键值","中","也","可以"],"title":"全局字典","title_tokens":["全局","字典"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_4","text":"在ROS2中，参数的特性非常丰富，比如某一个节点共享了一个参数，其他节点都可以访问，如果某一个节点对参数进行了修改，其他节点也有办法立刻知道，从而获取最新的数值。这在 参数的高级编程 中，大家都可能会用到。","text_tokens":["在","其他","进行","非常","这","参数","获取","访问","数值","有","大家","比如","的","。","可能","特性","丰富","了","都","知道","如果","某","对","一个","立刻","会","最新","节点","ros2","从而","高级","修改","共享","编程","，"," ","办法","中","也","可以","用到"],"title":"可动态监控","title_tokens":["监控","动态","可"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_5","text":"在小海龟的例程中，仿真器也提供了不少参数，我们一起来通过这个例程，熟悉下参数的含义和命令行的使用方法。 启动两个终端，分别运行小海龟仿真器和键盘控制节点： $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key","text_tokens":["：","小海龟","熟悉","在","仿真器","turtle","和","仿真","例程","键盘","小海","海龟","参数","命令","这个","分别","turtlesim","run","也","$","的","。","终端","使用","了","两个","_","node","我们","下","通过","key","控制","不少","一","启动","节点","ros2","含义","命令行","运行","，","方法","提供"," ","起来","中","真器","teleop"],"title":"案例一：小海龟例程中的参数","title_tokens":["中","小海龟","参数","例程","案例","一","：","的","小海","海龟"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_6","text":"当前系统中有哪些参数呢？我们可以启动一个终端，并使用如下命令查询： $ ros2 param list","text_tokens":["list","系统","查询","如下","参数","并","当前","哪些","$","终端","使用","我们","？","一个","启动","ros2","param","呢","，"," ","命令","：","可以","中有"],"title":"查看参数列表","title_tokens":["列表","查看","参数"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_7","text":"如果想要查询或者修改某个参数的值，可以在param命令后边跟get或者set子命令： $ ros2 param describe turtlesim background_b # 查看某个参数的描述信息 $ ros2 param get turtlesim background_b # 查询某个参数的值 $ ros2 param set turtlesim background_b 10 # 修改某个参数的值","text_tokens":["：","background","在","描述","查询","跟","10","某个","参数","describe","b","turtlesim","可以","或者","$","的","_","如果","查看","子","想要","ros2","#","值","param","后边","修改","，","信息"," ","命令","get","set"],"title":"参数查询与修改","title_tokens":["查询","与","参数","修改"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_8","text":"一个一个查询/修改参数太麻烦了，不如试一试参数文件，ROS中的参数文件使用yaml格式，可以在param命令后边跟dump子命令，将某个节点的参数都保存到文件中，或者通过load命令一次性加载某个参数文件中的所有内容： $ ros2 param dump turtlesim >> turtlesim.yaml # 将某个节点的参数保存到参数文件中 $ ros2 param load turtlesim turtlesim.yaml # 一次性加载某一个文件中的所有参数","text_tokens":["：","所有","在","到","yaml","保存","查询","跟","参数","某个","turtlesim","麻烦","ros","或者","$","的","一次性","试一试","使用","了","格式","都","一次","dump","某","一个","内容","子","通过",".","/","节点","load","不如","将","ros2","param","后边","#","修改",">","太","，","文件"," ","命令","中","加载","可以"],"title":"参数文件保存与加载","title_tokens":["保存","文件","与","加载","参数"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_9","text":"接下来就要开始写程序了，在程序中设置参数和读取参数都比较简单，一两句函数就可以实现，我们先来体验一下这几个函数的使用方法。","text_tokens":["就","在","开始","和","就要","写","这","一下","参数","实现","两句","接下来","的","。","使用","函数","下来","了","都","我们","设置","简单","先","一两句","来","读取","几个","，","方法","比较","接下","程序","中","一两","比较简单","可以","体验"],"title":"案例二：参数编程","title_tokens":["编程","案例","二","：","参数"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_10","text":"启动一个终端，先运行第一句指令，启动param_declare节点，终端中可以看到循环打印的日志信息，其中的“mbot”就是我们设置的一个参数值，参数名称是“robot_name”，通过命令行修改这个参数，看下终端中会发生什么？ $ ros2 run learning_parameter param_declare $ ros2 param set param_declare robot_name turtle","text_tokens":["其中","”","看","发生","turtle","是","mbot","参数","循环","name","一句","数值","这个","就是","第一句","打印","run","$","learning","的","什么","终端","中","_","参数值","我们","？","设置","一个","下","会","通过","declare","日志","先","robot","parameter","启动","节点","指令","set","ros2","param","第一","“","名称","运行","命令行","修改","，","信息"," ","命令","看到","可以"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_11","text":"我们来看下在代码中，如何声明、创建、修改一个参数的值。 learning_parameter/param_declare.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2参数示例-创建、读取、修改参数 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 class ParameterNode ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . timer = self . create_timer ( 2 , self . timer_callback ) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） self . declare_parameter ( 'robot_name' , 'mbot' ) # 创建一个参数，并设置参数的默认值 def timer_callback ( self ): # 创建定时器周期执行的回调函数 robot_name_param = self . get_parameter ( 'robot_name' ) . get_parameter_value () . string_value # 从ROS2系统中读取参数的值 self . get_logger () . info ( 'Hello %s !' % robot_name_param ) # 输出日志信息，打印读取到的参数值 new_name_param = rclpy . parameter . Parameter ( 'robot_name' , # 重新将参数值设置为指定值 rclpy . Parameter . Type . STRING , 'mbot' ) all_new_parameters = [ new_name_param ] self . set_parameters ( all_new_parameters ) # 将重新创建的参数列表发送给ROS2系统 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ParameterNode ( \"param_declare\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'param_declare = learning_parameter.param_declare:main' , ], },","text_tokens":["列表","shutdown","coding","到","env","系统","create","mbot","com","s","示例","初始","参数","callback","发送","name","创建","声明","py","（","learning","info","。","python","node","]","为","下","送给","new","/","robot","all","setup","ros2","将","打开","来看","库","，","destroy","居","python3","def"," ","\"","rclpy","中","get","接口","：","{","8","import","www","hello","输出","初始化","spin","进行","none","配置","）","循环","功能","bin","guyuehome","打印","回调","退出","主","对象","函数","_","}","self","入口","周期","日志","编写","string","parameter","发送给",":","点","#","[","super","需要","from","__","定时器","-","console","重新","并","作者","*","2","代码","的","选项","编译","scripts","我们","关闭","utf","秒","默认值","'","知道","declare",".","!","init","说明","值","包","执行","单位","定时","信息","文件",")","、","等待","程序","古月","usr","parameternode","在",",","main","完成","parameters","如下","数值","%","entry","=","类","父类","从","timer","销毁","参数值","加入","设置","一个","args","points","class","如何","节点","param","@","指定","value","修改","读取","后","让","type","默认","(","set","logger"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_12","text":"参数大家已经会使用了，如何在机器人中应用呢？ 继续优化机器视觉的示例，物体识别对光线比较敏感，不同的环境大家使用的阈值也是不同的，每次在代码中修改阈值还挺麻烦，不如我们就把阈值提炼成参数，运行过程中就可以动态设置，不是大大提高了程序的易用性么？ 说干就干，我们先来看下效果如何，再看下代码中的变化。","text_tokens":["变化","就","在","看","还","易用","是","挺","阈值","敏感","再","示例","应用","参数","机器人","不同","过程","易用性","麻烦","大家","优化","成","代码","大大提高","说干就干","的","每次","。","使用","环境","效果","了","提高","视觉","我们","？","对","设置","么","下","继续","会","物体","光线","提炼","先","如何","已经","把","不如","大大","呢","修改","运行","来看","动态","，","机器","识别"," ","比较","不是","程序","中","也","可以"],"title":"案例三：机器视觉应用","title_tokens":["：","视觉","机器","案例","三","应用"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_13","text":"启动三个终端，分别运行： 相机驱动节点 视觉识别节点 修改红色阈值 $ ros2 run usb_cam usb_cam_node_exe $ ros2 run learning_parameter param_object_detect $ ros2 param set param_object_detect red_h_upper 180 在启动的视觉识别节点中，我们故意将视觉识别中红色阈值的上限设置为0，如果不修改参数，将无法实现目标识别。 为了便于调整阈值，我们在节点中将红色阈值的限位修改为了ROS参数，通过命令行修改该参数的值，就可以实现视觉识别啦。","text_tokens":["调整","就","在","usb","三个","无法","阈值","upper","0","参数","命令","实现","h","分别","detect","故意","object","目标","可以","实现目标","ros","run","$","learning","的","。","终端","中将","该","便于","上限","中","不","_","node","视觉","我们","cam","为","exe","设置","如果","限位","通过","parameter","启动","节点","set","ros2","将","param","值","180","命令行","修改","运行","啦","，","识别"," ","红色","相机","为了","red","：","驱动"],"title":"运行效果","title_tokens":["运行","效果"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_14","text":"我们来看下在视觉识别的代码中，是如何通过参数来设置阈值的。 learning_parameter/param_object_detect.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @作者: 古月居(www.guyuehome.com) @说明: ROS2参数示例-设置目标识别的颜色阈值参数 \"\"\" import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red = np . array ([ 0 , 90 , 128 ]) # 红色的HSV阈值下限 upper_red = np . array ([ 180 , 255 , 255 ]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber ( Node ): def __init__ ( self , name ): super () . __init__ ( name ) # ROS2节点父类初始化 self . sub = self . create_subscription ( Image , # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） 'image_raw' , self . listener_callback , 10 ) self . cv_bridge = CvBridge () # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self . declare_parameter ( 'red_h_upper' , 0 ) # 创建一个参数，表示阈值上限 self . declare_parameter ( 'red_h_lower' , 0 ) # 创建一个参数，表示阈值下限 def object_detect ( self , image ): upper_red [ 0 ] = self . get_parameter ( 'red_h_upper' ) . get_parameter_value () . integer_value # 读取阈值上限的参数值 lower_red [ 0 ] = self . get_parameter ( 'red_h_lower' ) . get_parameter_value () . integer_value # 读取阈值下限的参数值 self . get_logger () . info ( 'Get Red H Upper: %d , Lower: %d ' % ( upper_red [ 0 ], lower_red [ 0 ])) # 通过日志打印读取到的参数值 hsv_img = cv2 . cvtColor ( image , cv2 . COLOR_BGR2HSV ) # 图像从BGR颜色模型转换为HSV模型 mask_red = cv2 . inRange ( hsv_img , lower_red , upper_red ) # 图像二值化 contours , hierarchy = cv2 . findContours ( mask_red , cv2 . RETR_LIST , cv2 . CHAIN_APPROX_NONE ) # 图像中轮廓检测 for cnt in contours : # 去除一些轮廓面积太小的噪声 if cnt . shape [ 0 ] < 150 : continue ( x , y , w , h ) = cv2 . boundingRect ( cnt ) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2 . drawContours ( image , [ cnt ], - 1 , ( 0 , 255 , 0 ), 2 ) # 将苹果的轮廓勾勒出来 cv2 . circle ( image , ( int ( x + w / 2 ), int ( y + h / 2 )), 5 , ( 0 , 255 , 0 ), - 1 ) # 将苹果的图像中心点画出来 cv2 . imshow ( \"object\" , image ) # 使用OpenCV显示处理后的图像效果 cv2 . waitKey ( 50 ) def listener_callback ( self , data ): self . get_logger () . info ( 'Receiving video frame' ) # 输出日志信息，提示已进入回调函数 image = self . cv_bridge . imgmsg_to_cv2 ( data , \"bgr8\" ) # 将ROS的图像消息转化成OpenCV图像 self . object_detect ( image ) # 苹果检测 def main ( args = None ): # ROS2节点主入口main函数 rclpy . init ( args = args ) # ROS2 Python接口初始化 node = ImageSubscriber ( \"param_object_detect\" ) # 创建ROS2节点对象并进行初始化 rclpy . spin ( node ) # 循环等待ROS2退出 node . destroy_node () # 销毁节点对象 rclpy . shutdown () # 关闭ROS2 Python接口 完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置： entry_points = { 'console_scripts' : [ 'param_declare = learning_parameter.param_declare:main' , 'param_object_detect = learning_parameter.param_object_detect:main' , ], },","text_tokens":["data","+","shutdown","coding","到","env","进入","imgmsg","系统","create","<","com","10","示例","初始","circle","参数","callback","消息","name","h","approx","创建","retr","object","转化成","py","subscription","（","learning","info","。","bgr2hsv","python","使用","node","视觉","]","为","勾勒","下","转化","/","setup","计算","ros2","inrange","将","frame","打开","to","cv2","轮廓","来看","所在","50","库","，","sensor","居","python3","def","互相"," ","\"","lower","img","in","rclpy","中","订阅","接口","get","findcontours","：","8","{","import","www","下限","x","初始化","list","和","高","输出","去除","spin","是","进行","none","长度","w","cvtcolor","模型","配置","）","循环","color","宽","像素","功能","一些","np","提示","目标","bin","guyuehome","5","打印","回调","二值化","对象","显示","主","退出","函数","_","destroy","}","cvbridge","self","入口","continue","日志","编写","点","parameter",":","array","来","#","drawcontours","类型","180","[","出来","super","150","需要","int","点画","red","msgs","90","from","__","范围","-","表示","hsv","bgr8","console","mask","左上","0","图像处理","并","作者","颜色","raw","chain","128","*","2","代码","imshow","cv","话题","的","选项","编译","scripts","as","上限","效果","队列","我们","检测","utf","关闭","知道","'","通过","declare",".","!","左上角","video","用于","说明","init","y","坐标","包","化成","信息","文件","识别",")","、","waitkey","等待","程序","upper","古月","usr","for","bridge","sub","得到","cnt","image","在",",","255","名","hierarchy","1","receiving","main","苹果","阈值","完成","者","if","integer","如下","shape","数值","detect","%","d","entry","太小","msg","噪声","=","ros","类","父类","与","从","已","面积","numpy","boundingrect","contours","xy","imagesubscriber","参数值","销毁","处理","加入","设置","一个","listener","args","points","转换","class","如何","节点","opencv","上角","及","param","@","value","读取","后","让","图像","红色","(","中心","bgr","logger"],"title":"代码解析","title_tokens":["解析","代码"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.8_%E5%8F%82%E6%95%B0/#_15","text":"https://docs.ros.org/en/humble/Tutorials/Parameters/Understanding-ROS2-Parameters.html","text_tokens":["https","-","tutorials","parameters","en","docs","ros","understanding",".","humble","html","/",":","org","ros2"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/","text":"分布式通信 智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？ 这就是分布式系统， 可以实现多计算平台上的任务分配。 分布式通信 什么叫分布式？ 之前我们也讲过，在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中，这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。 比如这款机器人系统中，有两个计算平台。 机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用 树莓派 作为控制器，主要实现传感器驱动和电机控制等功能，不过视觉处理和应用功能就不适合在树莓派里运行了，我们放在另外一个性能更强的 笔记本电脑 中，此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。 两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的，不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便。 接下来，我们就带领大家一起来感受下ROS分布式系统的魅力。 分布式网络搭建 除了我使用的笔记本电脑之外，另外一个计算平台我们选择了树莓派，模拟一个放置在机器人上的控制器。 树莓派配置 在开发之前，我们需要先配置好树莓派的环境，网上也有很多资料，大家都可以参考。 装系统 我们先要给树莓派装系统，这里我们选择的是 Ubuntu Mate 针对树莓派的镜像，下载镜像之后，烧写到树莓派的SD卡中就可以启动系统了。 Ubuntu MATE镜像下载链接： https://ubuntu-mate.org/download/ 安装ROS2 在安装好的Ubuntu Mate系统中，安装ROS2，和电脑端安装的流程一样。 编译代码 将我们课程的代码也下载到树莓派中，进行编译。 远程桌面 如果大家有显示器，可以直接在树莓派上连接键盘鼠标显示器使用，如果使用不方便的话，也可以在树莓派上配置好远程桌面，就可以通过网络访问树莓派的桌面系统了。 以上步骤的整体流程和电脑端操作基本一致，大家也可以参考如下链接配置树莓派： https://blog.csdn.net/qq_52785580/article/details/122599728 分布式数据传输 树莓派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？ 简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。 Attention 如使用虚拟机，请将虚拟机网络修改为 桥接模式 在树莓派端，使用如下命令启动一个发布者节点： $ ros2 run demo_nodes_cpp talker #树莓派端 接下来在电脑端，使用如下命令启动一个订阅者节点： $ ros2 run demo_nodes_py listener #PC端 神奇的事情就这样发生了，只要两个计算机安装好ROS2，并且处于同一网络中，他们就可以实现之前讲过的话题、服务、动作等通信了，感觉就像在一个电脑里一样。 不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联，而是可以分组通信，小组之间是无法实现通信的。 分布式网络分组 没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样，处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和树莓派端的.bashrc中加入这样一句配置，即可将两者分配到一个小组中： $ export ROS_DOMAIN_ID = <your_domain_id> 如果分配的ID不同，则两者无法实现通信。 案例一：小海龟分布式控制 分布式通信网络似乎已经建立成功了，是否真有我们想的这么神奇，我们继续测试之前学习过的一些例程。 先来试试ROS中的经典案例——小海龟。 我们可以在电脑端启动小海龟仿真器，树莓派上启动键盘控制节点，或者反过来也可以，依然可以流畅的控制小海龟运动： $ ros2 run turtlesim turtlesim_node # PC端 $ ros2 run turtlesim turtle_teleop_key # 树莓派端 案例二：话题分布式通信 我们之前编写的例程是否可以在不修改任何代码的情况下，直接使用呢？ 先试试话题通信，树莓派作为发布者，发布Hello World字符串，电脑作为订阅者，订阅Hello World字符串： $ ros2 run learning_topic topic_helloworld_pub # 树莓派端 $ ros2 run learning_topic topic_helloworld_sub # PC端 案例三：服务分布式通信 话题没有问题，服务也不在话下。 我们电脑端运行服务器程序，树莓派端运行客户端程序，还是可以顺利实现加法求和功能： $ ros2 run learning_service service_adder_server # PC端 $ ros2 run learning_service service_adder_client 2 3 # 树莓派端 案例四：机器视觉分布式应用 以上这些功能还不够复杂？没问题，视觉识别的例程安排上。 接下来，我们将使用树莓派连接摄像头，模拟一个小型机器人，可以采集实时图像，然后再通过分布式网络，将图像发给电脑端的处理节点，识别图像中的红色物体： $ ros2 run usb_cam usb_cam_node_exe # 树莓派端 $ ros2 run learning_topic topic_webcam_sub # PC端 没有任何问题，视觉识别的效果如下。 好啦，我们在分布式网络中测试了ROS一系列例程，都没有任何问题，在实际的机器人开发中，类似的方法会频繁用到，ROS为分布式网络的搭建提供了非常友好的支持，我们几乎不需要任何配置，代码也不需要做任何修改， 只要使用ROS系统，一切都会变得如此轻松 。 参考链接 https://docs.ros.org/en/humble/Concepts/About-Domain-ID.html","text_tokens":["变化","到","看上","任务","<","算机","体积","二","之后","domain","—","有","试试","比如","learning","笔记本电脑","设计","平台","qq","情况","/","实时","通信","之一","小","，","局域","id","资源"," ","org","命令","订阅","topic","可以","ubuntu","课程","另外","这些","这里","mate","about","挺","进行","请","给","于是","显示","卡中","分布式系统","位于","像","都","派端","出现","事情","不过","命令行","求和","并且","而言","attention","world","小海龟","鼠标","步骤","仿真","非常","两者","的","如此","主要","等","由","桥接","会","带来","一切","字符串","接下","流程","希望","典型","框架","client","变得","感觉","不同","一致","就是","简而言之","之外","讲","想","装","每","处理","？","一个","分组","上去","your","反过来","后","压力","docs","控制器","监控","四","才能","拆解","再","处于","支持","看上去","感器","方便","建立","。","各种","打通","类似","node","视觉","学习","3","sd","启动","计算","链接","操作","啦","多个","组成","下载","也","此外","驱动","之间","开发","中有","之前","如","真器","几乎","turtle","和","csdn","派装","的话","魅力","服务","上","分布式","功能","似乎","卡顿","客户","局域网","不在","_","adder","顺利","互通","发给","控制","编写","基本一致",":","#","经典","更强","带领","电脑","机器","放在","一系列","-","一系","确保","并","是否","接下来","代码","计算能力","en","话题","同一","完全","两个","继续","通过",".","已经","里",">","信息","分布","性能","轻松","teleop","安装","模式","在","仿真器","export","系列","测试","如下","个","参考","网络","先要","ros","小组","案例","派里","可能","派","listener","反过","摄像头","友好","节点","除了","实际","没有","不是","不够","用到","发生","usb","系统","客户端程序","例程","然后","一下","article","成功","机器人","计算机","122599728","摄像","用","run","为","exe","下","ros2","分配","nodes","这种","虚拟","放置","details","中","：","不在话下","hello","桌面","远程","应用","流畅","做","款","树莓","字符","数据","bashrc","物体","复杂","这么","具体","经常","提供","比较","任何","只要","镜像","布式","原本","采用","一句","很多","你","而是","岂","2","编译","效果","发布者","service","消耗","key","html","https","、","程序","起来","上边","局域网络","客户端","较","这样","完成","小海","pub","有点","顺利实现","所","大家","52785580","小型","采集","网上","了","加入","像头","智能","减轻","一","讲过","选择","笔记","修改","频繁","烧写","多","红色","同一个","端","过","server","实现","访问","直接","py","什么","demo","使用","如果","全都","talker","搭建","三","download","将","资料","结构","显示器","问题","端的","键盘","加法","还","是","无法","感受","这","配置","毕竟","一些","神奇","任务分配","机制","过来","webcam","不","pc","cam","helloworld","以上","服务器","humble","运动","整体","来","呢","模拟","适合","需要","分布式应用","发布","遇到","还是","务器","blog","互联","叫","turtlesim","繁多","或者","传感","$","环境","只","基本","下来","我们","则","concepts","即可","服务器程序","没","针对","放","我","依然","识别","sub","就","连接","数据传输","者","传感器","传输","net","=","电机","据传","虚拟机","远程桌面","动作","一样","相互","真有","笔记本","先","能力","cpp","好","安排","运行","作为","方法","图像","他们","海龟"],"title":"分布式通信","title_tokens":["分布","布式","通信","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_1","text":"智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？ 这就是分布式系统， 可以实现多计算平台上的任务分配。","text_tokens":["这些","遇到","到","拆解","系统","任务","算机","这","上","布式","分布式","实现","机器人","功能","计算机","岂","任务分配","就是","计算能力","卡顿","繁多","的","。","分布式系统","处理","等","如果","？","一个","平台","全都","智能","会","情况","能力","出现","减轻","计算","将","分配","运行","里","机器","，","经常","压力","多个","不是"," ","不够","、","放在","分布","多","中","可以"],"title":"分布式通信","title_tokens":["分布","布式","通信","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_2","text":"什么叫分布式？ 之前我们也讲过，在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中，这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。 比如这款机器人系统中，有两个计算平台。 机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用 树莓派 作为控制器，主要实现传感器驱动和电机控制等功能，不过视觉处理和应用功能就不适合在树莓派里运行了，我们放在另外一个性能更强的 笔记本电脑 中，此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。 两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的，不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便。 接下来，我们就带领大家一起来感受下ROS分布式系统的魅力。","text_tokens":["变化","到","看上","系统","任务","过","算机","体积","实现","机器人","计算机","看上去","有","感器","方便","比如","什么","。","各种","笔记本电脑","设计","视觉","为","平台","下","通信","之一","计算","将","分配","这种","小","结构","，","资源"," ","组成","中","也","此外","可以","驱动","之间","开发","之前","另外","这些","和","远程","还","是","挺","魅力","感受","这","上","配置","应用","毕竟","分布式","功能","做","于是","款","树莓","分布式系统","位于","不","都","数据","复杂","控制","运动","不过","更强","带领","电脑","适合","并且","机器","需要","比较","放在","任何","非常","布式","叫","原本","采用","接下来","传感","的","完全","环境","只","两个","下来","主要","我们","由","等","消耗","已经","放","信息","分布","性能","接下","起来","上边","就","在","较","典型","框架","传感器","传输","有点","不同","大家","就是","ros","电机","派里","讲","可能","了","每","？","处理","相互","一个","派","笔记本","减轻","一","节点","好","上去","笔记","运行","作为","压力","多","控制器","监控"],"title":"分布式通信","title_tokens":["分布","布式","通信","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_3","text":"除了我使用的笔记本电脑之外，另外一个计算平台我们选择了树莓派，模拟一个放置在机器人上的控制器。","text_tokens":["另外","在","上","机器人","之外","的","。","树莓","笔记本电脑","使用","了","我们","平台","一个","派","笔记本","控制","计算","选择","笔记","除了","模拟","电脑","放置","，","我","机器","控制器"],"title":"分布式网络搭建","title_tokens":["网络","分布","搭建","布式","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_4","text":"在开发之前，我们需要先配置好树莓派的环境，网上也有很多资料，大家都可以参考。","text_tokens":["之前","在","配置","很多","参考","有","大家","的","。","树莓","环境","网上","都","我们","派","先","好","资料","，","需要","也","可以","开发"],"title":"树莓派配置","title_tokens":["配置","树莓","派"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_5","text":"我们先要给树莓派装系统，这里我们选择的是 Ubuntu Mate 针对树莓派的镜像，下载镜像之后，烧写到树莓派的SD卡中就可以启动系统了。 Ubuntu MATE镜像下载链接： https://ubuntu-mate.org/download/","text_tokens":["：","就","到","这里","mate","派装","系统","-","是","镜像","之后","给","先要","的","。","树莓","卡中","了","我们","派",".","/",":","sd","启动","download","选择","链接","针对","https","，","烧写"," ","org","下载","可以","ubuntu"],"title":"装系统","title_tokens":["系统","装"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#ros2","text":"在安装好的Ubuntu Mate系统中，安装ROS2，和电脑端安装的流程一样。","text_tokens":["一样","安装","在","mate","和","电脑","系统","端","流程","，"," ","ros2","中","的","。","ubuntu","好"],"title":"安装ROS2","title_tokens":["安装","ros2"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_6","text":"将我们课程的代码也下载到树莓派中，进行编译。","text_tokens":["将","课程","中","到","我们","代码","派","，","进行","也","下载","的","。","树莓","编译"],"title":"编译代码","title_tokens":["代码","编译"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_7","text":"如果大家有显示器，可以直接在树莓派上连接键盘鼠标显示器使用，如果使用不方便的话，也可以在树莓派上配置好远程桌面，就可以通过网络访问树莓派的桌面系统了。 以上步骤的整体流程和电脑端操作基本一致，大家也可以参考如下链接配置树莓派： https://blog.csdn.net/qq_52785580/article/details/122599728","text_tokens":["就","在","连接","桌面","和","鼠标","系统","的话","远程","步骤","端","csdn","上","配置","如下","blog","article","访问","一致","net","参考","直接","有","大家","方便","网络","52785580","122599728","也","显示","的","远程桌面","树莓","。","使用","不","基本","了","_","如果","派","qq","以上","通过",".","基本一致","整体",":","/","好","链接","https","操作","电脑","，","details"," ","显示器","：","键盘","可以","流程"],"title":"远程桌面","title_tokens":["远程","远程桌面","桌面"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_8","text":"树莓派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？ 简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。 Attention 如使用虚拟机，请将虚拟机网络修改为 桥接模式 在树莓派端，使用如下命令启动一个发布者节点： $ ros2 run demo_nodes_cpp talker #树莓派端 接下来在电脑端，使用如下命令启动一个订阅者节点： $ ros2 run demo_nodes_py listener #PC端 神奇的事情就这样发生了，只要两个计算机安装好ROS2，并且处于同一网络中，他们就可以实现之前讲过的话题、服务、动作等通信了，感觉就像在一个电脑里一样。 不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联，而是可以分组通信，小组之间是无法实现通信的。","text_tokens":["发生","到","端","算机","处于","一下","实现","计算机","直接","用","run","py","什么","。","demo","使用","打通","为","平台","如果","talker","通信","启动","计算","ros2","将","nodes","虚拟","，","局域"," ","问题","命令","：","中","如","订阅","可以","也","中有","之前","之间","和","是","无法","服务","请","这","配置","神奇","做","树莓","局域网","像","不","_","派端","都","pc","互通","事情","具体","不过","#","呢","命令行","电脑","而言","attention","并且","需要","发布","只要","互联","确保","并","很多","你","接下来","而是","话题","$","同一","的","效果","发布者","下来","两个","我们","桥接","等","会","带来","已经","里","、","接下","就","局域网络","连接","模式","在","安装","希望","这样","完成","者","测试","如下","个","感觉","所","网络","简而言之","小组","虚拟机","动作","一样","了","？","派","一个","listener","能力","讲过","节点","cpp","分组","好","修改","后","他们","同一个"],"title":"分布式数据传输","title_tokens":["数据传输","数据","分布","据传","传输","布式","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_9","text":"没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样，处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和树莓派端的.bashrc中加入这样一句配置，即可将两者分配到一个小组中： $ export ROS_DOMAIN_ID = <your_domain_id> 如果分配的ID不同，则两者无法实现通信。","text_tokens":["：","就","才能","在","到","和","export","<","算机","这样","无法","处于","配置","domain","实现","一句","不同","计算机","两者","=","小组","ros","$","同一","机制","的","树莓","。","一样","了","类似","_","我们","加入","如果","一个","派","bashrc",".","则","即可","通信","分组","计算","ros2","将","没","分配","your","电脑",">","，","id","提供"," ","问题","端的","中","同一个","可以"],"title":"分布式网络分组","title_tokens":["网络","分布","布式","分组","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_10","text":"分布式通信网络似乎已经建立成功了，是否真有我们想的这么神奇，我们继续测试之前学习过的一些例程。 先来试试ROS中的经典案例——小海龟。 我们可以在电脑端启动小海龟仿真器，树莓派上启动键盘控制节点，或者反过来也可以，依然可以流畅的控制小海龟运动： $ ros2 run turtlesim turtlesim_node # PC端 $ ros2 run turtlesim turtle_teleop_key # 树莓派端","text_tokens":["之前","：","小海龟","在","仿真器","turtle","端","过","仿真","例程","键盘","测试","上","布式","成功","小海","海龟","分布式","流畅","—","turtlesim","是否","一些","run","神奇","网络","建立","ros","似乎","案例","试试","或者","也","过来","的","。","想","树莓","$","了","_","node","pc","我们","学习","派端","真有","派","继续","反过","key","先","控制","这么","运动","已经","通信","启动","节点","来","ros2","#","经典","反过来","电脑","，","依然","分布"," ","中","真器","可以","teleop"],"title":"案例一：小海龟分布式控制","title_tokens":["小海龟","分布","案例","控制","一","：","布式","小海","海龟","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_11","text":"我们之前编写的例程是否可以在不修改任何代码的情况下，直接使用呢？ 先试试话题通信，树莓派作为发布者，发布Hello World字符串，电脑作为订阅者，订阅Hello World字符串： $ ros2 run learning_topic topic_helloworld_pub # 树莓派端 $ ros2 run learning_topic topic_helloworld_sub # PC端","text_tokens":["之前","任何","在","hello","端","例程","者","pub","是否","直接","代码","run","试试","话题","$","learning","的","树莓","字符","使用","不","发布者","_","派端","pc","我们","？","helloworld","派","下","情况","编写","先","通信","ros2","字符串","topic","#","呢","修改","作为","电脑","，"," ","world","订阅","：","可以","sub","发布"],"title":"案例二：话题分布式通信","title_tokens":["通信","分布","案例","话题","二","：","布式","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_12","text":"话题没有问题，服务也不在话下。 我们电脑端运行服务器程序，树莓派端运行客户端程序，还是可以顺利实现加法求和功能： $ ros2 run learning_service service_adder_server # PC端 $ ros2 run learning_service service_adder_client 2 3 # 树莓派端","text_tokens":["客户端","端","客户端程序","服务","还是","server","务器","client","实现","顺利实现","功能","2","run","客户","话题","$","learning","。","树莓","不在","_","派端","adder","我们","pc","service","3","服务器","顺利","服务器程序","ros2","#","运行","电脑","没有","求和","，"," ","问题","程序","：","也","不在话下","可以","加法"],"title":"案例三：服务分布式通信","title_tokens":["：","通信","服务","分布","案例","三","布式","分布式"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_13","text":"以上这些功能还不够复杂？没问题，视觉识别的例程安排上。 接下来，我们将使用树莓派连接摄像头，模拟一个小型机器人，可以采集实时图像，然后再通过分布式网络，将图像发给电脑端的处理节点，识别图像中的红色物体： $ ros2 run usb_cam usb_cam_node_exe # 树莓派端 $ ros2 run learning_topic topic_webcam_sub # PC端 没有任何问题，视觉识别的效果如下。 好啦，我们在分布式网络中测试了ROS一系列例程，都没有任何问题，在实际的机器人开发中，类似的方法会频繁用到，ROS为分布式网络的搭建提供了非常友好的支持，我们几乎不需要任何配置，代码也不需要做任何修改， 只要使用ROS系统，一切都会变得如此轻松 。","text_tokens":["usb","端","系统","例程","再","然后","机器人","支持","摄像","run","learning","。","使用","类似","node","视觉","为","exe","实时","搭建","ros2","将","啦","，"," ","问题","端的","：","topic","中","可以","也","开发","几乎","这些","还","上","配置","分布式","功能","做","树莓","webcam","不","_","派端","都","pc","cam","以上","物体","复杂","发给","#","模拟","电脑","机器","需要","提供","一系列","任何","只要","非常","一系","布式","接下来","代码","$","的","效果","如此","下来","我们","会","通过","一切","没","识别","分布","接下","轻松","sub","连接","在","系列","测试","如下","变得","网络","ros","小型","采集","了","？","处理","派","像头","一个","摄像头","友好","节点","好","安排","修改","实际","频繁","没有","方法","图像","红色","不够","用到"],"title":"案例四：机器视觉分布式应用","title_tokens":["视觉","机器","分布式","分布","案例","分布式应用","：","布式","应用","四"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.9_%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/#_14","text":"https://docs.ros.org/en/humble/Concepts/About-Domain-ID.html","text_tokens":["https","about","-","id","en","docs","ros","html",".","humble","concepts","/",":","org","domain"],"title":"参考链接","title_tokens":["链接","参考"]},{"location":"ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2_%E6%A6%82%E5%BF%B5%E6%80%BB%E8%A7%88/","text":"从本节开始，我们将进入第二个篇章，以ROS2的核心概念为线索，详细讲解ROS2的应用开发方法。","text_tokens":["开始","进入","讲解","以","应用","本节","线索","详细","的","。","从本节","核心","第二个","我们","二个","篇章","为","ros2","将","开发方法","，","第二","方法","概念","开发"],"title":"概念总览","title_tokens":["总览","概念"]}]}